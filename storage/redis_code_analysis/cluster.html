<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>集群（cluster） &mdash; huangz/note</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'present',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="huangz/note" href="../../index.html" />
    <link rel="up" title="Redis 源码分析" href="index.html" />
    <link rel="next" title="重用 Redis 模块" href="../reuse-redis-module/index.html" />
    <link rel="prev" title="Sentinel" href="sentinel.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->





</head>
<body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../reuse-redis-module/index.html" title="重用 Redis 模块"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="sentinel.html" title="Sentinel"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">huangz/note</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Redis 源码分析</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cluster">
<h1>集群（cluster）<a class="headerlink" href="#cluster" title="Permalink to this headline">¶</a></h1>
<p>本次注释包含 <code class="docutils literal"><span class="pre">cluster.h</span></code> 文件和 <code class="docutils literal"><span class="pre">cluster.c</span></code> 文件，
源文件来自 Redis 项目 <code class="docutils literal"><span class="pre">unstable</span></code> 分支的最新文件，
最后一次提交来自：</p>
<div class="highlight-c"><div class="highlight"><pre>commit e78938425536748e63932ccebb7248f6389db102
Author: antirez &lt;antirez@gmail.com&gt;
Date:   Mon Dec 23 12:48:39 2013 +0100
</pre></div>
</div>
<p>两个注释文件的代码都可以在 <a class="reference external" href="https://github.com/huangz1990/blog/blob/master/storage/redis_code_analysis/cluster">https://github.com/huangz1990/blog/blob/master/storage/redis_code_analysis/cluster</a> 找到。</p>
<div class="section" id="cluster-h">
<h2>cluster.h<a class="headerlink" href="#cluster-h" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#ifndef __REDIS_CLUSTER_H</span>
<span class="cp">#define __REDIS_CLUSTER_H</span>

<span class="cm">/*-----------------------------------------------------------------------------</span>
<span class="cm"> * Redis cluster data structures, defines, exported API.</span>
<span class="cm"> *----------------------------------------------------------------------------*/</span>

<span class="c1">// 槽数量</span>
<span class="cp">#define REDIS_CLUSTER_SLOTS 16384</span>
<span class="c1">// 动作执行正常</span>
<span class="cp">#define REDIS_CLUSTER_OK 0          </span><span class="cm">/* Everything looks ok */</span><span class="cp"></span>
<span class="c1">// 表示 OK 之外的另一种 CASE （不一定是错误或者失败）</span>
<span class="cp">#define REDIS_CLUSTER_FAIL 1        </span><span class="cm">/* The cluster can&#39;t work */</span><span class="cp"></span>
<span class="c1">// 节点名字的长度</span>
<span class="cp">#define REDIS_CLUSTER_NAMELEN 40    </span><span class="cm">/* sha1 hex length */</span><span class="cp"></span>
<span class="c1">// 集群的实际端口号 = 用户指定的端口号 + REDIS_CLUSTER_PORT_INCR</span>
<span class="cp">#define REDIS_CLUSTER_PORT_INCR 10000 </span><span class="cm">/* Cluster port = baseport + PORT_INCR */</span><span class="cp"></span>
<span class="c1">// IPv6 地址的长度</span>
<span class="cp">#define REDIS_CLUSTER_IPLEN INET6_ADDRSTRLEN </span><span class="cm">/* IPv6 address string length */</span><span class="cp"></span>


<span class="cm">/* The following defines are amunt of time, sometimes expressed as</span>
<span class="cm"> * multiplicators of the node timeout value (when ending with MULT). </span>
<span class="cm"> *</span>
<span class="cm"> * 以下是和时间有关的一些常量，</span>
<span class="cm"> * 以 _MULTI 结尾的常量会作为时间值的乘法因子来使用。</span>
<span class="cm"> */</span>
<span class="c1">// 默认节点超时时限</span>
<span class="cp">#define REDIS_CLUSTER_DEFAULT_NODE_TIMEOUT 15000</span>
<span class="c1">// 检验失效报告的乘法因子</span>
<span class="cp">#define REDIS_CLUSTER_FAIL_REPORT_VALIDITY_MULT 2 </span><span class="cm">/* Fail report validity. */</span><span class="cp"></span>
<span class="c1">// 撤销主节点 FAIL 状态的乘法因子</span>
<span class="cp">#define REDIS_CLUSTER_FAIL_UNDO_TIME_MULT 2 </span><span class="cm">/* Undo fail if master is back. */</span><span class="cp"></span>
<span class="c1">// 撤销主节点 FAIL 状态的加法因子</span>
<span class="cp">#define REDIS_CLUSTER_FAIL_UNDO_TIME_ADD 10 </span><span class="cm">/* Some additional time. */</span><span class="cp"></span>
<span class="c1">// 在检查从节点数据是否有效时使用的乘法因子</span>
<span class="cp">#define REDIS_CLUSTER_SLAVE_VALIDITY_MULT 10 </span><span class="cm">/* Slave data validity. */</span><span class="cp"></span>
<span class="c1">// 发送投票请求的间隔时间的乘法因子</span>
<span class="cp">#define REDIS_CLUSTER_FAILOVER_AUTH_RETRY_MULT 4 </span><span class="cm">/* Auth request retry time. */</span><span class="cp"></span>
<span class="c1">// 在执行故障转移之前需要等待的秒数</span>
<span class="cp">#define REDIS_CLUSTER_FAILOVER_DELAY 5 </span><span class="cm">/* Seconds */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">clusterNode</span><span class="p">;</span>


<span class="cm">/* clusterLink encapsulates everything needed to talk with a remote node. */</span>
<span class="c1">// clusterLink 包含了与其他节点进行通讯所需的全部信息</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">clusterLink</span> <span class="p">{</span>

    <span class="c1">// 连接的创建时间</span>
    <span class="kt">mstime_t</span> <span class="n">ctime</span><span class="p">;</span>             <span class="cm">/* Link creation time */</span>

    <span class="c1">// TCP 套接字描述符</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>                     <span class="cm">/* TCP socket file descriptor */</span>

    <span class="c1">// 输出缓冲区</span>
    <span class="n">sds</span> <span class="n">sndbuf</span><span class="p">;</span>                 <span class="cm">/* Packet send buffer */</span>

    <span class="c1">// 输入缓冲区</span>
    <span class="n">sds</span> <span class="n">rcvbuf</span><span class="p">;</span>                 <span class="cm">/* Packet reception buffer */</span>

    <span class="c1">// 与这个连接相关联的节点，如果没有的话就为 NULL</span>
    <span class="k">struct</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>   <span class="cm">/* Node related to this link if any, or NULL */</span>

<span class="p">}</span> <span class="n">clusterLink</span><span class="p">;</span>


<span class="cm">/* Node flags 节点标识*/</span>
<span class="c1">// 该节点为主节点</span>
<span class="cp">#define REDIS_NODE_MASTER 1     </span><span class="cm">/* The node is a master */</span><span class="cp"></span>
<span class="c1">// 该节点为从节点</span>
<span class="cp">#define REDIS_NODE_SLAVE 2      </span><span class="cm">/* The node is a slave */</span><span class="cp"></span>
<span class="c1">// 该节点疑似下线，需要对它的状态进行确认</span>
<span class="cp">#define REDIS_NODE_PFAIL 4      </span><span class="cm">/* Failure? Need acknowledge */</span><span class="cp"></span>
<span class="c1">// 该节点已下线</span>
<span class="cp">#define REDIS_NODE_FAIL 8       </span><span class="cm">/* The node is believed to be malfunctioning */</span><span class="cp"></span>
<span class="c1">// 该节点是当前节点自身</span>
<span class="cp">#define REDIS_NODE_MYSELF 16    </span><span class="cm">/* This node is myself */</span><span class="cp"></span>
<span class="c1">// 该节点还未与当前节点完成第一次 PING - PONG 通讯</span>
<span class="cp">#define REDIS_NODE_HANDSHAKE 32 </span><span class="cm">/* We have still to exchange the first ping */</span><span class="cp"></span>
<span class="c1">// 该节点没有地址</span>
<span class="cp">#define REDIS_NODE_NOADDR   64  </span><span class="cm">/* We don&#39;t know the address of this node */</span><span class="cp"></span>
<span class="c1">// 当前节点还未与该节点进行过接触</span>
<span class="c1">// 带有这个标识会让当前节点发送 MEET 命令而不是 PING 命令</span>
<span class="cp">#define REDIS_NODE_MEET 128     </span><span class="cm">/* Send a MEET message to this node */</span><span class="cp"></span>
<span class="c1">// 该节点被选中为新的主节点</span>
<span class="cp">#define REDIS_NODE_PROMOTED 256 </span><span class="cm">/* Master was a slave propoted by failover */</span><span class="cp"></span>
<span class="c1">// 空名字（在节点为主节点时，用作消息中的 slaveof 属性的值）</span>
<span class="cp">#define REDIS_NODE_NULL_NAME &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>


<span class="cm">/* This structure represent elements of node-&gt;fail_reports. */</span>
<span class="c1">// 每个 clusterNodeFailReport 结构保存了一条其他节点对目标节点的失效报告</span>
<span class="c1">// （认为目标节点已经下线）</span>
<span class="k">struct</span> <span class="n">clusterNodeFailReport</span> <span class="p">{</span>

    <span class="c1">// 报告目标节点已经失效的节点</span>
    <span class="k">struct</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>  <span class="cm">/* Node reporting the failure condition. */</span>

    <span class="c1">// 最后一次从 node 节点收到失效报告的时间</span>
    <span class="kt">mstime_t</span> <span class="n">time</span><span class="p">;</span>             <span class="cm">/* Time of the last report from this node. */</span>

<span class="p">}</span> <span class="k">typedef</span> <span class="n">clusterNodeFailReport</span><span class="p">;</span>


<span class="c1">// 节点状态</span>
<span class="k">struct</span> <span class="n">clusterNode</span> <span class="p">{</span>

    <span class="c1">// 创建节点的时间</span>
    <span class="kt">mstime_t</span> <span class="n">ctime</span><span class="p">;</span> <span class="cm">/* Node object creation time. */</span>

    <span class="c1">// 节点的名字</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">];</span> <span class="cm">/* Node name, hex string, sha1-size */</span>

    <span class="c1">// 节点标识</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>      <span class="cm">/* REDIS_NODE_... */</span>

    <span class="c1">// 节点当前的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">configEpoch</span><span class="p">;</span> <span class="cm">/* Last configEpoch observed for this node */</span>

    <span class="c1">// 由这个节点负责处理的槽</span>
    <span class="c1">// 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长</span>
    <span class="c1">// 每个字节的每个位记录了一个槽的保存状态</span>
    <span class="c1">// 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理</span>
    <span class="c1">// 比如 slots[0] 的第一个位保存了槽 0 的保存情况</span>
    <span class="c1">// slots[0] 的第二个位保存了槽 1 的保存情况，以此类推</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slots</span><span class="p">[</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* slots handled by this node */</span>

    <span class="c1">// 该节点负责处理的槽数量</span>
    <span class="kt">int</span> <span class="n">numslots</span><span class="p">;</span>   <span class="cm">/* Number of slots handled by this node */</span>

    <span class="c1">// 如果本节点是主节点，那么用这个属性记录从节点的数量</span>
    <span class="kt">int</span> <span class="n">numslaves</span><span class="p">;</span>  <span class="cm">/* Number of slave nodes, if this is a master */</span>

    <span class="c1">// 指针数组，指向各个从节点</span>
    <span class="k">struct</span> <span class="n">clusterNode</span> <span class="o">**</span><span class="n">slaves</span><span class="p">;</span> <span class="cm">/* pointers to slave nodes */</span>

    <span class="c1">// 如果这是一个从节点，那么指向主节点</span>
    <span class="k">struct</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slaveof</span><span class="p">;</span> <span class="cm">/* pointer to the master node */</span>

    <span class="c1">// 最后一次发送 PING 命令的时间</span>
    <span class="kt">mstime_t</span> <span class="n">ping_sent</span><span class="p">;</span>       <span class="cm">/* Unix time we sent latest ping */</span>

    <span class="c1">// 最后一次接收 PONG 回复的时间戳</span>
    <span class="kt">mstime_t</span> <span class="n">pong_received</span><span class="p">;</span>   <span class="cm">/* Unix time we received the pong */</span>

    <span class="c1">// 最后一次被设置为 FAIL 状态的时间</span>
    <span class="kt">mstime_t</span> <span class="n">fail_time</span><span class="p">;</span>       <span class="cm">/* Unix time when FAIL flag was set */</span>

    <span class="c1">// 最后一次给某个从节点投票的时间</span>
    <span class="kt">mstime_t</span> <span class="n">voted_time</span><span class="p">;</span>      <span class="cm">/* Last time we voted for a slave of this master */</span>

    <span class="c1">// ip 地址</span>
    <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="n">REDIS_IP_STR_LEN</span><span class="p">];</span>  <span class="cm">/* Latest known IP address of this node */</span>

    <span class="c1">// 端口号</span>
    <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>                   <span class="cm">/* Latest known port of this node */</span>

    <span class="c1">// 连接</span>
    <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>          <span class="cm">/* TCP/IP link with this node */</span>

    <span class="c1">// 一个列表，记录了所有节点对该节点的失效报告</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">fail_reports</span><span class="p">;</span>         <span class="cm">/* List of nodes signaling this as failing */</span>

<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">clusterNode</span> <span class="n">clusterNode</span><span class="p">;</span>


<span class="c1">// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子</span>
<span class="c1">// 注意，结构中有一部分属性其实和节点有关的，不知道为什么被放在了这里</span>
<span class="c1">// 比如 slots_to_keys 、failover_auth_count 等属性就是和本节点有关的</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">clusterState</span> <span class="p">{</span>

    <span class="c1">// 指向当前节点的指针</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">myself</span><span class="p">;</span>  <span class="cm">/* This node */</span>

    <span class="c1">// 集群当前的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">currentEpoch</span><span class="p">;</span>

    <span class="c1">// 集群状态</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>            <span class="cm">/* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */</span>

    <span class="c1">// 判断一个节点为 FAIL 所需的投票数量（quorum）</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>             <span class="cm">/* Num of master nodes with at least one slot */</span>

    <span class="c1">// 集群节点名单（不包括 myself 节点）</span>
    <span class="c1">// 字典的键为节点的名字，字典的值为 clusterNode 结构</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>          <span class="cm">/* Hash table of name -&gt; clusterNode structures */</span>

    <span class="c1">// 节点黑名单，用于 CLUSTER FORGET 命令</span>
    <span class="c1">// 防止被 FORGET 的命令重新被添加到集群里面</span>
    <span class="c1">// （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">nodes_black_list</span><span class="p">;</span> <span class="cm">/* Nodes we don&#39;t re-add for a few seconds. */</span>

    <span class="c1">// 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点</span>
    <span class="c1">// migrating_slots_to[i] = NULL 表示槽 i 未被迁移</span>
    <span class="c1">// migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">];</span>

    <span class="c1">// 记录要从目标节点迁移到本节点的槽，以及进行迁移的目标节点</span>
    <span class="c1">// importing_slots_from[i] = NULL 表示槽 i 未进行导入</span>
    <span class="c1">// importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">];</span>

    <span class="c1">// 负责处理各个槽的节点</span>
    <span class="c1">// 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slots</span><span class="p">[</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">];</span>

    <span class="c1">// 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序</span>
    <span class="c1">// 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便</span>
    <span class="c1">// 具体操作定义在 db.c 里面</span>
    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">slots_to_keys</span><span class="p">;</span>

    <span class="cm">/* The following fields are used to take the slave state on elections. */</span>
    <span class="c1">// 以下这些域被用于进行故障转移选举</span>

    <span class="c1">// 上次执行选举或者下次执行选举的时间</span>
    <span class="kt">mstime_t</span> <span class="n">failover_auth_time</span><span class="p">;</span> <span class="cm">/* Time of previous or next election. */</span>

    <span class="c1">// 节点获得的投票数量</span>
    <span class="kt">int</span> <span class="n">failover_auth_count</span><span class="p">;</span>    <span class="cm">/* Number of votes received so far. */</span>

    <span class="c1">// 如果值为 1 ，表示本节点已经向其他节点发送了投票请求</span>
    <span class="kt">int</span> <span class="n">failover_auth_sent</span><span class="p">;</span>     <span class="cm">/* True if we already asked for votes. */</span>

    <span class="c1">// 集群当前进行选举的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">failover_auth_epoch</span><span class="p">;</span> <span class="cm">/* Epoch of the current election. */</span>

    <span class="cm">/* The followign fields are uesd by masters to take state on elections. */</span>
    <span class="c1">// 以下一个域是主节点在进行故障迁移投票时使用的域</span>

    <span class="c1">// 节点最后投票的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">last_vote_epoch</span><span class="p">;</span>   <span class="cm">/* Epoch of the last vote granted. */</span>

    <span class="c1">// 在进入下个事件循环之前要做的事情，以各个 flag 来记录</span>
    <span class="kt">int</span> <span class="n">todo_before_sleep</span><span class="p">;</span> <span class="cm">/* Things to do in clusterBeforeSleep(). */</span>

    <span class="c1">// 通过 cluster 连接发送的消息数量</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">stats_bus_messages_sent</span><span class="p">;</span>  <span class="cm">/* Num of msg sent via cluster bus. */</span>

    <span class="c1">// 通过 cluster 接收到的消息数量</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">stats_bus_messages_received</span><span class="p">;</span> <span class="cm">/* Num of msg rcvd via cluster bus.*/</span>

<span class="p">}</span> <span class="n">clusterState</span><span class="p">;</span>

<span class="cm">/* clusterState todo_before_sleep flags. */</span>
<span class="c1">// 以下每个 flag 代表了一个服务器在开始下一个事件循环之前</span>
<span class="c1">// 要做的事情</span>
<span class="cp">#define CLUSTER_TODO_HANDLE_FAILOVER (1&lt;&lt;0)</span>
<span class="cp">#define CLUSTER_TODO_UPDATE_STATE (1&lt;&lt;1)</span>
<span class="cp">#define CLUSTER_TODO_SAVE_CONFIG (1&lt;&lt;2)</span>
<span class="cp">#define CLUSTER_TODO_FSYNC_CONFIG (1&lt;&lt;3)</span>

<span class="cm">/* Redis cluster messages header */</span>

<span class="cm">/* Note that the PING, PONG and MEET messages are actually the same exact</span>
<span class="cm"> * kind of packet. PONG is the reply to ping, in the exact format as a PING,</span>
<span class="cm"> * while MEET is a special PING that forces the receiver to add the sender</span>
<span class="cm"> * as a node (if it is not already in the list). */</span>
<span class="c1">// 注意，PING 、 PONG 和 MEET 实际上是同一种消息。</span>
<span class="c1">// PONG 是对 PING 的回复，它的实际格式也为 PING 消息，</span>
<span class="c1">// 而 MEET 则是一种特殊的 PING 消息，用于强制消息的接收者将消息的发送者添加到集群中</span>
<span class="c1">// （如果节点尚未在节点列表中的话）</span>
<span class="c1">// PING</span>
<span class="cp">#define CLUSTERMSG_TYPE_PING 0          </span><span class="cm">/* Ping */</span><span class="cp"></span>
<span class="c1">// PONG （回复 PING）</span>
<span class="cp">#define CLUSTERMSG_TYPE_PONG 1          </span><span class="cm">/* Pong (reply to Ping) */</span><span class="cp"></span>
<span class="c1">// 请求将某个节点添加到集群中</span>
<span class="cp">#define CLUSTERMSG_TYPE_MEET 2          </span><span class="cm">/* Meet &quot;let&#39;s join&quot; message */</span><span class="cp"></span>
<span class="c1">// 将某个节点标记为 FAIL</span>
<span class="cp">#define CLUSTERMSG_TYPE_FAIL 3          </span><span class="cm">/* Mark node xxx as failing */</span><span class="cp"></span>
<span class="c1">// 通过发布与订阅功能广播消息</span>
<span class="cp">#define CLUSTERMSG_TYPE_PUBLISH 4       </span><span class="cm">/* Pub/Sub Publish propagation */</span><span class="cp"></span>
<span class="c1">// 请求进行故障转移操作，要求消息的接收者通过投票来支持消息的发送者</span>
<span class="cp">#define CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 </span><span class="cm">/* May I failover? */</span><span class="cp"></span>
<span class="c1">// 消息的接收者同意向消息的发送者投票</span>
<span class="cp">#define CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     </span><span class="cm">/* Yes, you have my vote */</span><span class="cp"></span>
<span class="c1">// 槽布局已经发生变化，消息发送者要求消息接收者进行相应的更新</span>
<span class="cp">#define CLUSTERMSG_TYPE_UPDATE 7        </span><span class="cm">/* Another node slots configuration */</span><span class="cp"></span>

<span class="cm">/* Initially we don&#39;t know our &quot;name&quot;, but we&#39;ll find it once we connect</span>
<span class="cm"> * to the first node, using the getsockname() function. Then we&#39;ll use this</span>
<span class="cm"> * address for all the next messages. */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>

    <span class="c1">// 节点的名字</span>
    <span class="c1">// 在刚开始的时候，节点的名字会是随机的</span>
    <span class="c1">// 当 MEET 信息发送并得到回复之后，集群就会为节点设置正式的名字</span>
    <span class="kt">char</span> <span class="n">nodename</span><span class="p">[</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">];</span>

    <span class="c1">// 最后一次向该节点发送 PING 命令的时间戳</span>
    <span class="kt">uint32_t</span> <span class="n">ping_sent</span><span class="p">;</span>

    <span class="c1">// 最后一次从该节点接收到 PING 命令回复的时间戳</span>
    <span class="kt">uint32_t</span> <span class="n">pong_received</span><span class="p">;</span>

    <span class="c1">// 节点的 IP</span>
    <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>    <span class="cm">/* IP address last time it was seen */</span>

    <span class="c1">// 节点的端口</span>
    <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>  <span class="cm">/* port last time it was seen */</span>

    <span class="c1">// 节点的标识值</span>
    <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">notused</span><span class="p">;</span> <span class="cm">/* for 64 bit alignment */</span>

<span class="p">}</span> <span class="n">clusterMsgDataGossip</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>

    <span class="c1">// 失效节点的名字</span>
    <span class="kt">char</span> <span class="n">nodename</span><span class="p">[</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">];</span>

<span class="p">}</span> <span class="n">clusterMsgDataFail</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>

    <span class="c1">// 频道名长度</span>
    <span class="kt">uint32_t</span> <span class="n">channel_len</span><span class="p">;</span>

    <span class="c1">// 消息长度</span>
    <span class="kt">uint32_t</span> <span class="n">message_len</span><span class="p">;</span>

    <span class="c1">// 消息内容，格式为 频道名+消息</span>
    <span class="c1">// bulk_data[0:channel_len] 为频道名</span>
    <span class="c1">// bulk_data[channel_len:] 为消息</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bulk_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* defined as 8 just for alignment concerns. */</span>

<span class="p">}</span> <span class="n">clusterMsgDataPublish</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>

    <span class="c1">// 节点的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">configEpoch</span><span class="p">;</span> <span class="cm">/* Config epoch of the specified instance. */</span>

    <span class="c1">// 节点的名字</span>
    <span class="kt">char</span> <span class="n">nodename</span><span class="p">[</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">];</span> <span class="cm">/* Name of the slots owner. */</span>

    <span class="c1">// 节点的槽布局</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slots</span><span class="p">[</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* Slots bitmap. */</span>

<span class="p">}</span> <span class="n">clusterMsgDataUpdate</span><span class="p">;</span>

<span class="k">union</span> <span class="n">clusterMsgData</span> <span class="p">{</span>
    <span class="cm">/* PING, MEET and PONG */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="cm">/* Array of N clusterMsgDataGossip structures */</span>
        <span class="n">clusterMsgDataGossip</span> <span class="n">gossip</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">ping</span><span class="p">;</span>

    <span class="cm">/* FAIL */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="n">clusterMsgDataFail</span> <span class="n">about</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">fail</span><span class="p">;</span>

    <span class="cm">/* PUBLISH */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="n">clusterMsgDataPublish</span> <span class="n">msg</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">publish</span><span class="p">;</span>

    <span class="cm">/* UPDATE */</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="n">clusterMsgDataUpdate</span> <span class="n">nodecfg</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">update</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 用来表示集群信息的结构</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>

    <span class="c1">// 信息的长度</span>
    <span class="kt">uint32_t</span> <span class="n">totlen</span><span class="p">;</span>    <span class="cm">/* Total length of this message */</span>

    <span class="c1">// 信息的类型</span>
    <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">;</span>      <span class="cm">/* Message type */</span>

    <span class="c1">// 只被一部分信息使用</span>
    <span class="kt">uint16_t</span> <span class="n">count</span><span class="p">;</span>     <span class="cm">/* Only used for some kind of messages. */</span>

    <span class="c1">// 发送此信息的节点的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">currentEpoch</span><span class="p">;</span>  <span class="cm">/* The epoch accordingly to the sending node. */</span>

    <span class="c1">// 如果发送信息的节点是一个主节点，那么这里记录它的配置纪元</span>
    <span class="c1">// 如果发送信息的节点是一个从节点，那么这里记录的是它的主节点的配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">configEpoch</span><span class="p">;</span>   <span class="cm">/* The config epoch if it&#39;s a master, or the last epoch</span>
<span class="cm">                               advertised by its master if it is a slave. */</span>

    <span class="c1">// 发送信息的节点的名字</span>
    <span class="kt">char</span> <span class="n">sender</span><span class="p">[</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">];</span> <span class="cm">/* Name of the sender node */</span>

    <span class="c1">// 槽布局</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">myslots</span><span class="p">[</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span>

    <span class="c1">// 当前节点正在复制的主节点</span>
    <span class="c1">// 如果当前节点为主节点，那么它为 REDIS_NODE_NULL_NAME</span>
    <span class="kt">char</span> <span class="n">slaveof</span><span class="p">[</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">];</span>

    <span class="kt">char</span> <span class="n">notused1</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>  <span class="cm">/* 32 bytes reserved for future usage. */</span>

    <span class="c1">// 端口</span>
    <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>      <span class="cm">/* Sender TCP base port */</span>

    <span class="c1">// 节点标识</span>
    <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">;</span>     <span class="cm">/* Sender node flags */</span>

    <span class="c1">// 发送信息节点所处的集群状态</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">state</span><span class="p">;</span> <span class="cm">/* Cluster state from the POV of the sender */</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">notused2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* Reserved for future use. For alignment. */</span>

    <span class="c1">// 信息的内容</span>
    <span class="k">union</span> <span class="n">clusterMsgData</span> <span class="n">data</span><span class="p">;</span>

<span class="p">}</span> <span class="n">clusterMsg</span><span class="p">;</span>

<span class="cp">#define CLUSTERMSG_MIN_LEN (sizeof(clusterMsg)-sizeof(union clusterMsgData))</span>

<span class="cm">/* ----------------------- API exported outside cluster.c ------------------------- */</span>
<span class="n">clusterNode</span> <span class="o">*</span><span class="nf">getNodeByQuery</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hashslot</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ask</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __REDIS_CLUSTER_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="cluster-c">
<h2>cluster.c<a class="headerlink" href="#cluster-c" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* Redis Cluster implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright notice,</span>
<span class="cm"> *     this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *     documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *   * Neither the name of Redis nor the names of its contributors may be used</span>
<span class="cm"> *     to endorse or promote products derived from this software without</span>
<span class="cm"> *     specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;redis.h&quot;</span>
<span class="cp">#include &quot;cluster.h&quot;</span>
<span class="cp">#include &quot;endianconv.h&quot;</span>

<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/socket.h&gt;</span>
<span class="cp">#include &lt;arpa/inet.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;sys/socket.h&gt;</span>

<span class="n">clusterNode</span> <span class="o">*</span><span class="nf">createClusterNode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">nodename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterAddNode</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterAcceptHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterReadHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterSendPing</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterSendFail</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">nodename</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterSendFailoverAuthIfNeeded</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">request</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterUpdateState</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">);</span>
<span class="n">sds</span> <span class="nf">clusterGenNodesDescription</span><span class="p">(</span><span class="kt">int</span> <span class="n">filter</span><span class="p">);</span>
<span class="n">clusterNode</span> <span class="o">*</span><span class="nf">clusterLookupNode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterNodeAddSlave</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slave</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterAddSlot</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterDelSlot</span><span class="p">(</span><span class="kt">int</span> <span class="n">slot</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterDelNodeSlots</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">clusterNodeSetSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterSetMaster</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterHandleSlaveFailover</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">bitmapTestBit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterDoBeforeSleep</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clusterSendUpdate</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * Initialization</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* This function is called at startup in order to set the currentEpoch</span>
<span class="cm"> * (which is not saved on permanent storage) to the greatest configEpoch found</span>
<span class="cm"> * in the loaded nodes (configEpoch is stored on permanent storage as soon as</span>
<span class="cm"> * it changes for some node). */</span>
<span class="c1">// 设置配置纪元</span>
<span class="kt">void</span> <span class="nf">clusterSetStartupEpoch</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="c1">// 选出节点中的最大纪元</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">)</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 载入集群配置</span>
<span class="kt">int</span> <span class="nf">clusterLoadConfig</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">maxline</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
   
    <span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="cm">/* Parse the file. Note that single liens of the cluster config file can</span>
<span class="cm">     * be really long as they include all the hash slots of the node.</span>
<span class="cm">     * 集群配置文件中的行可能会非常长，</span>
<span class="cm">     * 因为它会在行里面记录所有哈希槽的节点。</span>
<span class="cm">     *</span>
<span class="cm">     * This means in the worst possible case, half of the Redis slots will be</span>
<span class="cm">     * present in a single line, possibly in importing or migrating state, so</span>
<span class="cm">     * together with the node ID of the sender/receiver.</span>
<span class="cm">     *</span>
<span class="cm">     * 在最坏情况下，一个行可能保存了半数的哈希槽数据，</span>
<span class="cm">     * 并且可能带有导入或导出状态，以及发送者和接受者的 ID 。</span>
<span class="cm">     *</span>
<span class="cm">     * To simplify we allocate 1024+REDIS_CLUSTER_SLOTS*128 bytes per line. </span>
<span class="cm">     *</span>
<span class="cm">     * 为了简单起见，我们为每行分配 1024+REDIS_CLUSTER_SLOTS*128 字节的空间</span>
<span class="cm">     */</span>
    <span class="n">maxline</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">+</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="o">*</span><span class="mi">128</span><span class="p">;</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">maxline</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="n">maxline</span><span class="p">,</span><span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
        <span class="n">sds</span> <span class="o">*</span><span class="n">argv</span> <span class="o">=</span> <span class="n">sdssplitargs</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">goto</span> <span class="n">fmterr</span><span class="p">;</span>

        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

        <span class="cm">/* Create this node if it does not exist */</span>
        <span class="c1">// 检查节点是否已经存在</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 未存在则创建这个节点</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">createClusterNode</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>
            <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* Address and port */</span>
        <span class="c1">// 设置节点的 ip 和 port</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="sc">&#39;:&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">goto</span> <span class="n">fmterr</span><span class="p">;</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

        <span class="cm">/* Parse flags */</span>
        <span class="c1">// 分析节点的 flag</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">s</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="sc">&#39;,&#39;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
            <span class="c1">// 这是节点本身</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;myself&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">redisAssert</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_MYSELF</span><span class="p">;</span>
            <span class="c1">// 这是一个主节点</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;master&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">;</span>
            <span class="c1">// 这是一个从节点</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;slave&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">;</span>
            <span class="c1">// 这是一个疑似失效节点</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;fail?&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">;</span>
            <span class="c1">// 这是一个已失效节点</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;fail&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">;</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">fail_time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
            <span class="c1">// 等待向节点发送 PING</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;handshake&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">;</span>
            <span class="c1">// 尚未获得这个节点的地址</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;noaddr&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_NOADDR</span><span class="p">;</span>
            <span class="c1">// 无 flag</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="s">&quot;noflags&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/* nothing to do */</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">redisPanic</span><span class="p">(</span><span class="s">&quot;Unknown flag in redis cluster config file&quot;</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Get master if any. Set the master and populate master&#39;s</span>
<span class="cm">         * slave list. */</span>
        <span class="c1">// 如果有主节点的话，那么设置主节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">master</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
            <span class="c1">// 如果主节点不存在，那么添加它</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">master</span> <span class="o">=</span> <span class="n">createClusterNode</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// 设置主节点</span>
            <span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
            <span class="c1">// 将节点 n 加入到主节点 master 的从节点名单中</span>
            <span class="n">clusterNodeAddSlave</span><span class="p">(</span><span class="n">master</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Set ping sent / pong received timestamps */</span>
        <span class="c1">// 设置最近一次发送 PING 命令以及接收 PING 命令回复的时间戳</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pong_received</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

        <span class="cm">/* Set configEpoch for this node. */</span>
        <span class="c1">// 设置配置纪元</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">=</span> <span class="n">strtoull</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

        <span class="cm">/* Populate hash slots served by this instance. */</span>
        <span class="c1">// 取出节点服务的槽</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">;</span>

            <span class="c1">// 正在导入或导出槽</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Here we handle migrating / importing slots */</span>
                <span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
                <span class="kt">char</span> <span class="n">direction</span><span class="p">;</span>
                <span class="n">clusterNode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>

                <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>
                <span class="n">redisAssert</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
                <span class="c1">// 导入 or 导出？</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* Either &#39;&gt;&#39; or &#39;&lt;&#39; */</span>
                <span class="c1">// 槽</span>
                <span class="n">slot</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="c1">// 目标节点</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="c1">// 如果目标不存在，那么创建</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">cn</span> <span class="o">=</span> <span class="n">createClusterNode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
                    <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">cn</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">// 根据方向，设定本节点要导入或者导出的槽的目标</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">cn</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// 没有导入或导出，这是一个区间范围的槽</span>
            <span class="c1">// 比如 0 - 10086</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="sc">&#39;-&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

            <span class="c1">// 没有导入或导出，这是单一个槽</span>
            <span class="c1">// 比如 10086</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="c1">// 将槽载入节点</span>
            <span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">stop</span><span class="p">)</span> <span class="n">clusterAddSlot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="o">++</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sdsfreesplitres</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span><span class="n">argc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

    <span class="cm">/* Config sanity check */</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Node configuration loaded, I&#39;m %.40s&quot;</span><span class="p">,</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="c1">// 设置配置纪元</span>
    <span class="n">clusterSetStartupEpoch</span><span class="p">();</span>
    <span class="c1">// 更新节点状态</span>
    <span class="n">clusterUpdateState</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>

<span class="nl">fmterr</span><span class="p">:</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Unrecoverable error: corrupted cluster config file.&quot;</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cluster node configuration is exactly the same as CLUSTER NODES output.</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes the node config and returns 0, on error -1</span>
<span class="cm"> * is returned. */</span>
<span class="c1">// 写入 nodes.conf 文件</span>
<span class="kt">int</span> <span class="nf">clusterSaveConfig</span><span class="p">(</span><span class="kt">int</span> <span class="n">do_fsync</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">clusterGenNodesDescription</span><span class="p">(</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_configfile</span><span class="p">,</span><span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">,</span><span class="mo">0644</span><span class="p">))</span>
        <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">ci</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">sdslen</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">do_fsync</span><span class="p">)</span> <span class="n">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err</span><span class="p">:</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 尝试写入 nodes.conf 文件，失败则退出</span>
<span class="kt">void</span> <span class="nf">clusterSaveConfigOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">do_fsync</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clusterSaveConfig</span><span class="p">(</span><span class="n">do_fsync</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Fatal: can&#39;t update cluster config file.&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 初始化集群</span>
<span class="kt">void</span> <span class="nf">clusterInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">saveconf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 初始化配置</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterState</span><span class="p">));</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">REDIS_CLUSTER_FAIL</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">dictCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clusterNodesDictType</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes_black_list</span> <span class="o">=</span>
        <span class="n">dictCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clusterNodesBlackListDictType</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_epoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">last_vote_epoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">stats_bus_messages_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">stats_bus_messages_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">));</span>

    <span class="c1">// 载入 nodes.conf 配置文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clusterLoadConfig</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_configfile</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* No configuration found. We will just use the random name provided</span>
<span class="cm">         * by the createClusterNode() function. */</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">=</span>
            <span class="n">createClusterNode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">REDIS_NODE_MYSELF</span><span class="o">|</span><span class="n">REDIS_NODE_MASTER</span><span class="p">);</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;No cluster configuration found, I&#39;m %.40s&quot;</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">);</span>
        <span class="n">saveconf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 保存 nodes.conf 文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">saveconf</span><span class="p">)</span> <span class="n">clusterSaveConfigOrDie</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* We need a listening TCP port for our cluster messaging needs. */</span>
    <span class="c1">// 监听 TCP 端口</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cfd_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listenToPort</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="o">+</span><span class="n">REDIS_CLUSTER_PORT_INCR</span><span class="p">,</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cfd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">cfd_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cfd_count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 关联监听事件处理器</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">cfd</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">AE_READABLE</span><span class="p">,</span>
                <span class="n">clusterAcceptHandler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span>
                    <span class="n">redisPanic</span><span class="p">(</span><span class="s">&quot;Unrecoverable error creating Redis Cluster &quot;</span>
                                <span class="s">&quot;file event.&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* The slots -&gt; keys map is a sorted set. Init it. */</span>
    <span class="c1">// slots -&gt; keys 映射是一个有序集合</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots_to_keys</span> <span class="o">=</span> <span class="n">zslCreate</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER communication link</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="c1">// 创建节点连接</span>
<span class="n">clusterLink</span> <span class="o">*</span><span class="nf">createClusterLink</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">));</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">link</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free a cluster link, but does not free the associated node of course.</span>
<span class="cm"> * This function will just make sure that the original node associated</span>
<span class="cm"> * with this link will have the &#39;link&#39; field set to NULL. */</span>
<span class="c1">// 将给定的连接清空</span>
<span class="c1">// 并将包含这个连接的节点的 link 属性设为 NULL</span>
<span class="kt">void</span> <span class="nf">freeClusterLink</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 删除事件处理器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_WRITABLE</span><span class="p">);</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_READABLE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 释放输入缓冲区和输出缓冲区</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">);</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">);</span>

    <span class="c1">// 将节点的 link 属性设为 NULL</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
        <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// 关闭连接</span>
    <span class="n">close</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>

    <span class="c1">// 释放连接结构</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 监听事件处理器</span>
<span class="kt">void</span> <span class="nf">clusterAcceptHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cport</span><span class="p">,</span> <span class="n">cfd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">cip</span><span class="p">[</span><span class="n">REDIS_IP_STR_LEN</span><span class="p">];</span>
    <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">privdata</span><span class="p">);</span>

    <span class="c1">// accept 连接</span>
    <span class="n">cfd</span> <span class="o">=</span> <span class="n">anetTcpAccept</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">cip</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cip</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cport</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cfd</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span><span class="s">&quot;Accepting cluster node: %s&quot;</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">anetNonBlock</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">cfd</span><span class="p">);</span>
    <span class="n">anetEnableTcpNoDelay</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">cfd</span><span class="p">);</span>

    <span class="cm">/* Use non-blocking I/O for cluster messages. */</span>
    <span class="cm">/* IPV6: might want to wrap a v6 address in [] */</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span><span class="s">&quot;Accepted cluster node %s:%d&quot;</span><span class="p">,</span> <span class="n">cip</span><span class="p">,</span> <span class="n">cport</span><span class="p">);</span>
    <span class="cm">/* We need to create a temporary node in order to read the incoming</span>
<span class="cm">     * packet in a valid contest. This node will be released once we</span>
<span class="cm">     * read the packet and reply. */</span>
    <span class="c1">// 创建一个临时节点，并将其用于测试连接是否正常</span>
    <span class="c1">// 一旦连接测试完成，这个临时节点就会被释放</span>
    <span class="n">link</span> <span class="o">=</span> <span class="n">createClusterLink</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">cfd</span><span class="p">;</span>
    <span class="c1">// 关联读事件</span>
    <span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">cfd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">,</span><span class="n">clusterReadHandler</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * Key space handling</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* We have 16384 hash slots. The hash slot of a given key is obtained</span>
<span class="cm"> * as the least significant 14 bits of the crc16 of the key. */</span>
<span class="c1">// 计算给定键应该被分配到那个槽</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">keyHashSlot</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">crc16</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">keylen</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3FFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER node API</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* Create a new cluster node, with the specified flags.</span>
<span class="cm"> *</span>
<span class="cm"> * 创建一个带有指定 flag 的集群节点。</span>
<span class="cm"> *</span>
<span class="cm"> * If &quot;nodename&quot; is NULL this is considered a first handshake and a random</span>
<span class="cm"> * node name is assigned to this node (it will be fixed later when we&#39;ll</span>
<span class="cm"> * receive the first pong).</span>
<span class="cm"> *</span>
<span class="cm"> * 如果 nodename 参数为 NULL ，那么表示我们尚未向节点发送 PING ，</span>
<span class="cm"> * 集群会为节点设置一个随机的命令，</span>
<span class="cm"> * 这个命令在之后接收到节点的 PONG 回复之后就会被更新。</span>
<span class="cm"> *</span>
<span class="cm"> * The node is created and returned to the user, but it is not automatically</span>
<span class="cm"> * added to the nodes hash table. </span>
<span class="cm"> *</span>
<span class="cm"> * 函数会返回被创建的节点，但不会自动将它添加到当前节点的节点哈希表中</span>
<span class="cm"> * （nodes hash table）。</span>
<span class="cm"> */</span>
<span class="n">clusterNode</span> <span class="o">*</span><span class="nf">createClusterNode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">nodename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">));</span>

    <span class="c1">// 设置名字</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nodename</span><span class="p">)</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nodename</span><span class="p">,</span> <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">getRandomHexChars</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>

    <span class="c1">// 初始化属性</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">));</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslaves</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">pong_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">));</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_reports</span> <span class="o">=</span> <span class="n">listCreate</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">voted_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">listSetFreeMethod</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_reports</span><span class="p">,</span><span class="n">zfree</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function is called every time we get a failure report from a node.</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数会在当前节点接到某个节点的失效报告时调用。</span>
<span class="cm"> *</span>
<span class="cm"> * The side effect is to populate the fail_reports list (or to update</span>
<span class="cm"> * the timestamp of an existing report).</span>
<span class="cm"> *</span>
<span class="cm"> * 函数的作用就是将失效节点的失效报告添加到 fail_reports 列表，</span>
<span class="cm"> * 如果这个失效节点的失效报告已经存在，</span>
<span class="cm"> * 那么更新该报告的时间戳。</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;failing&#39; is the node that is in failure state according to the</span>
<span class="cm"> * &#39;sender&#39; node.</span>
<span class="cm"> *</span>
<span class="cm"> * failing 参数指向失效节点，而 sender 参数则指向报告 failing 已失效的节点。</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns 0 if it just updates a timestamp of an existing</span>
<span class="cm"> * failure report from the same sender. 1 is returned if a new failure</span>
<span class="cm"> * report is created. </span>
<span class="cm"> *</span>
<span class="cm"> * 函数返回 0 表示对已存在的报告进行了更新，</span>
<span class="cm"> * 返回 1 则表示创建了一条新的失效报告。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterNodeAddFailureReport</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">failing</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 指向保存失效报告的链表</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">failing</span><span class="o">-&gt;</span><span class="n">fail_reports</span><span class="p">;</span>

    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">clusterNodeFailReport</span> <span class="o">*</span><span class="n">fr</span><span class="p">;</span>

    <span class="cm">/* If a failure report from the same sender already exists, just update</span>
<span class="cm">     * the timestamp. */</span>
    <span class="c1">// 查找 sender 节点的失效报告是否已经存在</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="c1">// 如果存在的话，那么只更新该报告的时间戳</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fr</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">sender</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fr</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Otherwise create a new report. */</span>
    <span class="c1">// 否则的话，就创建一个新的报告</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fr</span><span class="p">));</span>
    <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">sender</span><span class="p">;</span>
    <span class="n">fr</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

    <span class="c1">// 将报告添加到列表</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">fr</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove failure reports that are too old, where too old means reasonably</span>
<span class="cm"> * older than the global node timeout. Note that anyway for a node to be</span>
<span class="cm"> * flagged as FAIL we need to have a local PFAIL state that is at least</span>
<span class="cm"> * older than the global node timeout, so we don&#39;t just trust the number</span>
<span class="cm"> * of failure reports from other nodes. </span>
<span class="cm"> *</span>
<span class="cm"> * 移除对 node 节点的过期的失效报告，</span>
<span class="cm"> * 多长时间为过期是根据 node timeout 选项的值来决定的。</span>
<span class="cm"> *</span>
<span class="cm"> * 注意，</span>
<span class="cm"> * 要将一个节点标记为 FAIL 状态，</span>
<span class="cm"> * 当前节点将 node 标记为 PFAIL 状态的时间至少应该超过 node timeout ，</span>
<span class="cm"> * 所以报告 node 已失效的节点数量并不是当前节点将 node 标记为 FAIL 的唯一条件。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterNodeCleanupFailureReports</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 指向该节点的所有失效报告</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_reports</span><span class="p">;</span>

    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">clusterNodeFailReport</span> <span class="o">*</span><span class="n">fr</span><span class="p">;</span>

    <span class="c1">// 失效报告的最大保质期（超过这个时间的报告会被删除）</span>
    <span class="kt">mstime_t</span> <span class="n">maxtime</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span> <span class="o">*</span>
                     <span class="n">REDIS_CLUSTER_FAIL_REPORT_VALIDITY_MULT</span><span class="p">;</span>
    <span class="kt">mstime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

    <span class="c1">// 遍历所有失效报告</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="c1">// 删除过期报告</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">maxtime</span><span class="p">)</span> <span class="n">listDelNode</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">ln</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Remove the failing report for &#39;node&#39; if it was previously considered</span>
<span class="cm"> * failing by &#39;sender&#39;. This function is called when a node informs us via</span>
<span class="cm"> * gossip that a node is OK from its point of view (no FAIL or PFAIL flags).</span>
<span class="cm"> *</span>
<span class="cm"> * 从 node 节点的失效报告中移除 sender 对 node 的失效报告。</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数在以下情况使用：当前节点认为 node 已下线（FAIL 或者 PFAIL），</span>
<span class="cm"> * 但 sender 却向当前节点发来报告，说它认为 node 节点没有下线，</span>
<span class="cm"> * 那么当前节点就要移除 sender 对 node 的失效报告 </span>
<span class="cm"> * —— 如果 sender 曾经报告过 node 失效的话。</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function is called relatively often as it gets called even</span>
<span class="cm"> * when there are no nodes failing, and is O(N), however when the cluster is</span>
<span class="cm"> * fine the failure reports list is empty so the function runs in constant</span>
<span class="cm"> * time.</span>
<span class="cm"> *</span>
<span class="cm"> * 即使在节点没有失效的情况下，这个函数也会被调用，并且调用的次数还比较频繁。</span>
<span class="cm"> * 在一般情况下，这个函数的复杂度为 O(N) ，</span>
<span class="cm"> * 不过在不存在失效报告的情况下，这个函数的复杂度仅为常数时间。</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns 1 if the failure report was found and removed.</span>
<span class="cm"> * Otherwise 0 is returned. </span>
<span class="cm"> *</span>
<span class="cm"> * 函数返回 1 表示失效报告已经被成功移除，</span>
<span class="cm"> * 0 表示 sender 没有发送过 node 的失效报告，删除失败。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterNodeDelFailureReport</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_reports</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">clusterNodeFailReport</span> <span class="o">*</span><span class="n">fr</span><span class="p">;</span>

    <span class="cm">/* Search for a failure report from this sender. */</span>
    <span class="c1">// 查找 sender 对 node 的失效报告</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fr</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">sender</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// sender 没有报告过 node 失效，直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ln</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* No failure report from this sender. */</span>

    <span class="cm">/* Remove the failure report. */</span>
    <span class="c1">// 删除 sender 对 node 的失效报告</span>
    <span class="n">listDelNode</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">ln</span><span class="p">);</span>
    <span class="c1">// 删除对 node 的失效报告中，过期的报告</span>
    <span class="n">clusterNodeCleanupFailureReports</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the number of external nodes that believe &#39;node&#39; is failing,</span>
<span class="cm"> * not including this node, that may have a PFAIL or FAIL state for this</span>
<span class="cm"> * node as well. </span>
<span class="cm"> *</span>
<span class="cm"> * 计算不包括本节点在内的，</span>
<span class="cm"> * 将 node 标记为 PFAIL 或者 FAIL 的节点的数量。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterNodeFailureReportsCount</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 移除过期的失效报告</span>
    <span class="n">clusterNodeCleanupFailureReports</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="c1">// 统计失效报告的数量</span>
    <span class="k">return</span> <span class="n">listLength</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_reports</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 移除主节点 master 的从节点 slave</span>
<span class="kt">int</span> <span class="nf">clusterNodeRemoveSlave</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="c1">// 在 slaves 数组中找到从节点 slave 所属的主节点，</span>
    <span class="c1">// 将主节点中的 slave 信息移除</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memmove</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="o">+</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">j</span><span class="p">);</span>
            <span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="o">--</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 将 slave 加入到 master 的从节点名单中</span>
<span class="kt">int</span> <span class="nf">clusterNodeAddSlave</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="cm">/* If it&#39;s already a slave, don&#39;t add it again. */</span>
    <span class="c1">// 如果 slave 已经存在，那么不做操作</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="c1">// 将 slave 添加到 slaves 数组里面</span>
    <span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span> <span class="o">=</span> <span class="n">zrealloc</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterNode</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">master</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="p">]</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
    <span class="n">master</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 重置给定节点的从节点名单</span>
<span class="kt">void</span> <span class="nf">clusterNodeResetSlaves</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">);</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">numslaves</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">slaves</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 释放节点</span>
<span class="kt">void</span> <span class="nf">freeClusterNode</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">nodename</span><span class="p">;</span>

    <span class="n">nodename</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>

    <span class="c1">// 从 nodes 表中删除节点</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span><span class="n">nodename</span><span class="p">)</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">);</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">nodename</span><span class="p">);</span>

    <span class="c1">// 移除从节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">)</span> <span class="n">clusterNodeRemoveSlave</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="c1">// 释放连接</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="n">freeClusterLink</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
    
    <span class="c1">// 释放失败报告</span>
    <span class="n">listRelease</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">fail_reports</span><span class="p">);</span>

    <span class="c1">// 释放节点结构</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add a node to the nodes hash table */</span>
<span class="c1">// 将给定 node 添加到节点表里面</span>
<span class="kt">int</span> <span class="nf">clusterAddNode</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
    
    <span class="c1">// 将 node 添加到当前节点的 nodes 表中</span>
    <span class="c1">// 这样接下来当前节点就会创建连向 node 的节点</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">dictAdd</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">),</span> <span class="n">node</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">)</span> <span class="o">?</span> <span class="nl">REDIS_OK</span> <span class="p">:</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove a node from the cluster:</span>
<span class="cm"> *</span>
<span class="cm"> * 从集群中移除一个节点：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Mark all the nodes handled by it as unassigned.</span>
<span class="cm"> *    将所有由该节点负责的槽全部设置为未分配</span>
<span class="cm"> * 2) Remove all the failure reports sent by this node.</span>
<span class="cm"> *    移除所有由这个节点发送的失效报告（failure report）</span>
<span class="cm"> * 3) Free the node, that will in turn remove it from the hash table</span>
<span class="cm"> *    and from the list of slaves of its master, if it is a slave node.</span>
<span class="cm"> *    释放这个节点，</span>
<span class="cm"> *    清除它在各个节点的 nodes 表中的数据，</span>
<span class="cm"> *    如果它是一个从节点的话，</span>
<span class="cm"> *    还要在它的主节点的 slaves 表中清除关于这个节点的数据。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterDelNode</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">delnode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="cm">/* 1) Mark slots as unassigned. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取消向该节点接收槽的计划</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">delnode</span><span class="p">)</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 取消向该节点移交槽的计划</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">delnode</span><span class="p">)</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 将所有由该节点负责的槽设置为未分配</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">delnode</span><span class="p">)</span>
            <span class="n">clusterDelSlot</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 2) Remove failure reports. */</span>
    <span class="c1">// 移除所有由该节点发送的失效报告</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">delnode</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">clusterNodeDelFailureReport</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">delnode</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

    <span class="cm">/* 3) Free the node, unlinking it from the cluster. */</span>
    <span class="c1">// 释放节点</span>
    <span class="n">freeClusterNode</span><span class="p">(</span><span class="n">delnode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Node lookup by name */</span>
<span class="c1">// 根据名字，查找给定的节点</span>
<span class="n">clusterNode</span> <span class="o">*</span><span class="nf">clusterLookupNode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="n">de</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">de</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is only used after the handshake. When we connect a given IP/PORT</span>
<span class="cm"> * as a result of CLUSTER MEET we don&#39;t have the node name yet, so we</span>
<span class="cm"> * pick a random one, and will fix it when we receive the PONG request using</span>
<span class="cm"> * this function. */</span>
<span class="c1">// 在第一次向节点发送 CLUSTER MEET 命令的时候</span>
<span class="c1">// 因为发送命令的节点还不知道目标节点的名字</span>
<span class="c1">// 所以它会给目标节点分配一个随机的名字</span>
<span class="c1">// 当目标节点向发送节点返回 PONG 回复时</span>
<span class="c1">// 发送节点就知道了目标节点的 IP 和 port</span>
<span class="c1">// 这时发送节点就可以通过调用这个函数</span>
<span class="c1">// 为目标节点改名</span>
<span class="kt">void</span> <span class="nf">clusterRenameNode</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newname</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
   
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;Renaming node %.40s into %.40s&quot;</span><span class="p">,</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newname</span><span class="p">);</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">newname</span><span class="p">,</span> <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
    <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER nodes blacklist</span>
<span class="cm"> *</span>
<span class="cm"> * 集群节点黑名单</span>
<span class="cm"> *</span>
<span class="cm"> * The nodes blacklist is just a way to ensure that a given node with a given</span>
<span class="cm"> * Node ID is not readded before some time elapsed (this time is specified</span>
<span class="cm"> * in seconds in REDIS_CLUSTER_BLACKLIST_TTL).</span>
<span class="cm"> *</span>
<span class="cm"> * 黑名单用于禁止一个给定的节点在 REDIS_CLUSTER_BLACKLIST_TTL 指定的时间内，</span>
<span class="cm"> * 被重新添加到集群中。</span>
<span class="cm"> *</span>
<span class="cm"> * This is useful when we want to remove a node from the cluster completely:</span>
<span class="cm"> * when CLUSTER FORGET is called, it also puts the node into the blacklist so</span>
<span class="cm"> * that even if we receive gossip messages from other nodes that still remember</span>
<span class="cm"> * about the node we want to remove, we don&#39;t re-add it before some time.</span>
<span class="cm"> *</span>
<span class="cm"> * 当我们需要从集群中彻底移除一个节点时，就需要用到黑名单：</span>
<span class="cm"> * 在执行 CLUSTER FORGET 命令时，节点会被添加进黑名单里面，</span>
<span class="cm"> * 这样即使我们从仍然记得被移除节点的其他节点那里收到关于被移除节点的消息，</span>
<span class="cm"> * 我们也不会重新将被移除节点添加至集群。</span>
<span class="cm"> *</span>
<span class="cm"> * Currently the REDIS_CLUSTER_BLACKLIST_TTL is set to 1 minute, this means</span>
<span class="cm"> * that redis-trib has 60 seconds to send CLUSTER FORGET messages to nodes</span>
<span class="cm"> * in the cluster without dealing with the problem if other nodes re-adding</span>
<span class="cm"> * back the node to nodes we already sent the FORGET command to.</span>
<span class="cm"> *</span>
<span class="cm"> * REDIS_CLUSTER_BLACKLIST_TTL 当前的值为 1 分钟，</span>
<span class="cm"> * 这意味着 redis-trib 有 60 秒的时间，可以向集群中的所有节点发送 CLUSTER FORGET</span>
<span class="cm"> * 命令，而不必担心有其他节点会将被 CLUSTER FORGET 移除的节点重新添加到集群里面。</span>
<span class="cm"> *</span>
<span class="cm"> * The data structure used is a hash table with an sds string representing</span>
<span class="cm"> * the node ID as key, and the time when it is ok to re-add the node as</span>
<span class="cm"> * value.</span>
<span class="cm"> *</span>
<span class="cm"> * 黑名单的底层实现是一个字典，</span>
<span class="cm"> * 字典的键为 SDS 表示的节点 id ，字典的值为可以重新添加节点的时间戳。</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cp">#define REDIS_CLUSTER_BLACKLIST_TTL 60      </span><span class="cm">/* 1 minute. */</span><span class="cp"></span>


<span class="cm">/* Before of the addNode() or Exists() operations we always remove expired</span>
<span class="cm"> * entries from the black list. This is an O(N) operation but it is not a</span>
<span class="cm"> * problem since add / exists operations are called very infrequently and</span>
<span class="cm"> * the hash table is supposed to contain very little elements at max.</span>
<span class="cm"> *</span>
<span class="cm"> * 在执行 addNode() 操作或者 Exists() 操作之前，</span>
<span class="cm"> * 我们总是会先执行这个函数，移除黑名单中的过期节点。</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数的复杂度为 O(N) ，不过它不会对效率产生影响，</span>
<span class="cm"> * 因为这个函数执行的次数并不频繁，并且字典的链表里面包含的节点数量也非常少。</span>
<span class="cm"> *</span>
<span class="cm"> * However without the cleanup during long uptimes and with some automated</span>
<span class="cm"> * node add/removal procedures, entries could accumulate. </span>
<span class="cm"> *</span>
<span class="cm"> * 定期清理过期节点是为了防止字典中的节点堆积过多。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterBlacklistCleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="c1">// 遍历黑名单中的所有节点</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes_black_list</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int64_t</span> <span class="n">expire</span> <span class="o">=</span> <span class="n">dictGetUnsignedIntegerVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 删除过期节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">expire</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">)</span>
            <span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes_black_list</span><span class="p">,</span><span class="n">dictGetKey</span><span class="p">(</span><span class="n">de</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cleanup the blacklist and add a new node ID to the black list. */</span>
<span class="c1">// 清除黑名单中的过期节点，然后将新的节点添加到黑名单中</span>
<span class="kt">void</span> <span class="nf">clusterBlacklistAddNode</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">id</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>

    <span class="c1">// 先清理过期名单</span>
    <span class="n">clusterBlacklistCleanup</span><span class="p">();</span>

    <span class="c1">// 添加节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictAdd</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes_black_list</span><span class="p">,</span><span class="n">id</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">DICT_ERR</span><span class="p">)</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="cm">/* Key was already there. */</span>
    <span class="c1">// 设置过期时间</span>
    <span class="n">de</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes_black_list</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="n">dictSetUnsignedIntegerVal</span><span class="p">(</span><span class="n">de</span><span class="p">,</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Return non-zero if the specified node ID exists in the blacklist.</span>
<span class="cm"> * You don&#39;t need to pass an sds string here, any pointer to 40 bytes</span>
<span class="cm"> * will work. */</span>
<span class="c1">// 检查给定 id 所指定的节点是否存在于黑名单中。</span>
<span class="c1">// nodeid 参数不必是一个 SDS 值，只要一个 40 字节长的字符串即可</span>
<span class="kt">int</span> <span class="nf">clusterBlacklistExists</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">nodeid</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 构建 SDS 表示的节点名</span>
    <span class="n">sds</span> <span class="n">id</span> <span class="o">=</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">nodeid</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="c1">// 检查节点是否存在</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes_black_list</span><span class="p">,</span><span class="n">id</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER messages exchange - PING/PONG and gossip</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* This function checks if a given node should be marked as FAIL.</span>
<span class="cm"> * It happens if the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * 此函数用于判断是否需要将 node 标记为 FAIL 。</span>
<span class="cm"> *</span>
<span class="cm"> * 将 node 标记为 FAIL 需要满足以下两个条件：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) We received enough failure reports from other master nodes via gossip.</span>
<span class="cm"> *    Enough means that the majority of the masters signaled the node is</span>
<span class="cm"> *    down recently.</span>
<span class="cm"> *    有半数以上的主节点将 node 标记为 PFAIL 状态。</span>
<span class="cm"> * 2) We believe this node is in PFAIL state.</span>
<span class="cm"> *    当前节点也将 node 标记为 PFAIL 状态。</span>
<span class="cm"> *</span>
<span class="cm"> * If a failure is detected we also inform the whole cluster about this</span>
<span class="cm"> * event trying to force every other node to set the FAIL flag for the node.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果确认 node 已经进入了 FAIL 状态，</span>
<span class="cm"> * 那么节点还会向其他节点发送 FAIL 消息，让其他节点也将 node 标记为 FAIL 。</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the form of agreement used here is weak, as we collect the majority</span>
<span class="cm"> * of masters state during some time, and even if we force agreement by</span>
<span class="cm"> * propagating the FAIL message, because of partitions we may not reach every</span>
<span class="cm"> * node. However:</span>
<span class="cm"> *</span>
<span class="cm"> * 注意，集群判断一个 node 进入 FAIL 所需的条件是弱（weak）的，</span>
<span class="cm"> * 因为节点们对 node 的状态报告并不是实时的，而是有一段时间间隔</span>
<span class="cm"> * （这段时间内 node 的状态可能已经发生了改变），</span>
<span class="cm"> * 并且尽管当前节点会向其他节点发送 FAIL 消息，</span>
<span class="cm"> * 但因为网络分裂（network partition）的问题，</span>
<span class="cm"> * 有一部分节点可能还是会不知道将 node 标记为 FAIL 。</span>
<span class="cm"> *</span>
<span class="cm"> * 不过：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Either we reach the majority and eventually the FAIL state will propagate</span>
<span class="cm"> *    to all the cluster.</span>
<span class="cm"> *    只要我们成功将 node 标记为 FAIL ，</span>
<span class="cm"> *    那么这个 FAIL 状态最终（eventually）总会传播至整个集群的所有节点。</span>
<span class="cm"> * 2) Or there is no majority so no slave promotion will be authorized and the</span>
<span class="cm"> *    FAIL flag will be cleared after some time.</span>
<span class="cm"> *    又或者，因为没有半数的节点支持，当前节点不能将 node 标记为 FAIL ，</span>
<span class="cm"> *    所以对 FAIL 节点的故障转移将无法进行， FAIL 标识可能会在之后被移除。</span>
<span class="cm"> *    </span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">markNodeAsFailingIfNeeded</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">failures</span><span class="p">;</span>

    <span class="c1">// 标记为 FAIL 所需的节点数量，需要超过集群节点数量的一半</span>
    <span class="kt">int</span> <span class="n">needed_quorum</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 不能对未进入 PFAIL 状态的节点标记 FAIL 状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span> <span class="cm">/* We can reach it. */</span>

    <span class="c1">// 节点已经是 FAIL 状态的了</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="cm">/* Already FAILing. */</span>

    <span class="c1">// 统计将 node 标记为 PFAIL 或者 FAIL 的节点数量（不包括当前节点）</span>
    <span class="n">failures</span> <span class="o">=</span> <span class="n">clusterNodeFailureReportsCount</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="cm">/* Also count myself as a voter if I&#39;m a master. */</span>
    <span class="c1">// 如果当前节点是主节点，那么将当前节点也算在 failures 之内</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span>
        <span class="n">failures</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 报告失效节点的数量不足节点总数的一半，不能将节点判断为 FAIL ，返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">failures</span> <span class="o">&lt;</span> <span class="n">needed_quorum</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="cm">/* No weak agreement from masters. */</span>

    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
        <span class="s">&quot;Marking node %.40s as failing (quorum reached).&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

    <span class="cm">/* Mark the node as failing. */</span>
    <span class="c1">// 将 node 标记为 FAIL</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_PFAIL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

    <span class="cm">/* Broadcast the failing node name to everybody, forcing all the other</span>
<span class="cm">     * reachable nodes to flag the node as FAIL. */</span>
    <span class="c1">// 如果当前节点是主节点的话，那么向其他节点发送报告 node 的 FAIL 信息</span>
    <span class="c1">// 让其他节点也将 node 标记为 FAIL</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span>
        <span class="n">clusterSendFail</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

    <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This function is called only if a node is marked as FAIL, but we are able</span>
<span class="cm"> * to reach it again. It checks if there are the conditions to undo the FAIL</span>
<span class="cm"> * state. </span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数在当前节点接收到一个被标记为 FAIL 的节点那里收到消息时使用，</span>
<span class="cm"> * 它可以检查是否应该将节点的 FAIL 状态移除。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clearNodeFailureIfNeeded</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">mstime_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

    <span class="n">redisAssert</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">);</span>

    <span class="cm">/* For slaves we always clear the FAIL flag if we can contact the</span>
<span class="cm">     * node again. */</span>
    <span class="c1">// 如果 FAIL 的是从节点，那么当前节点会直接移除该节点的 FAIL</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
            <span class="s">&quot;Clear FAIL state for node %.40s: slave is reachable again.&quot;</span><span class="p">,</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

        <span class="c1">// 移除</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_FAIL</span><span class="p">;</span>

        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* If it is a master and...</span>
<span class="cm">     *</span>
<span class="cm">     * 如果 FAIL 的是一个主节点，并且：</span>
<span class="cm">     *</span>
<span class="cm">     * 1) The FAIL state is old enough.</span>
<span class="cm">     *    节点被标记为 FAIL 状态已经有一段时间了</span>
<span class="cm">     *</span>
<span class="cm">     * 2) It is yet serving slots from our point of view (not failed over).</span>
<span class="cm">     *    从当前节点的视角来看，这个节点还有负责处理的槽</span>
<span class="cm">     *</span>
<span class="cm">     * Apparently no one is going to fix these slots, clear the FAIL flag. </span>
<span class="cm">     *</span>
<span class="cm">     * 那么说明 FAIL 节点仍然有槽没有迁移完，那么当前节点移除该节点的 FAIL 标识。</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span> <span class="o">&amp;&amp;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">fail_time</span><span class="p">)</span> <span class="o">&gt;</span>
        <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span> <span class="o">*</span> <span class="n">REDIS_CLUSTER_FAIL_UNDO_TIME_MULT</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
            <span class="s">&quot;Clear FAIL state for node %.40s: is reachable again and nobody is serving its slots after some time.&quot;</span><span class="p">,</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

        <span class="c1">// 撤销 FAIL 状态</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_FAIL</span><span class="p">;</span>

        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Return true if we already have a node in HANDSHAKE state matching the</span>
<span class="cm"> * specified ip address and port number. This function is used in order to</span>
<span class="cm"> * avoid adding a new handshake node for the same address multiple times. </span>
<span class="cm"> *</span>
<span class="cm"> * 如果当前节点已经向 ip 和 port 所指定的节点进行了握手，</span>
<span class="cm"> * 那么返回 1 。</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数用于防止对同一个节点进行多次握手。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterHandshakeInProgress</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="c1">// 遍历所有已知节点</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 跳过非握手状态的节点，之后剩下的都是正在握手的节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 给定 ip 和 port 的节点正在进行握手</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">ip</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

    <span class="c1">// 检查节点是否正在握手</span>
    <span class="k">return</span> <span class="n">de</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Start an handshake with the specified address if there is not one</span>
<span class="cm"> * already in progress. Returns non-zero if the handshake was actually</span>
<span class="cm"> * started. On error zero is returned and errno is set to one of the</span>
<span class="cm"> * following values:</span>
<span class="cm"> *</span>
<span class="cm"> * 如果还没有与指定的地址进行过握手，那么进行握手。</span>
<span class="cm"> * 返回 1 表示握手已经开始，</span>
<span class="cm"> * 返回 0 并将 errno 设置为以下值来表示意外情况：</span>
<span class="cm"> *</span>
<span class="cm"> * EAGAIN - There is already an handshake in progress for this address.</span>
<span class="cm"> *          已经有握手在进行中了。</span>
<span class="cm"> * EINVAL - IP or port are not valid. </span>
<span class="cm"> *          ip 或者 port 参数不合法。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterStartHandshake</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">norm_ip</span><span class="p">[</span><span class="n">REDIS_IP_STR_LEN</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">sa</span><span class="p">;</span>

    <span class="cm">/* IP sanity check */</span>
    <span class="c1">// ip 合法性检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">ss_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">ss_family</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Port sanity check */</span>
    <span class="c1">// port 合法性检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">port</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">65535</span><span class="o">-</span><span class="n">REDIS_CLUSTER_PORT_INCR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Set norm_ip as the normalized string representation of the node</span>
<span class="cm">     * IP address. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="p">.</span><span class="n">ss_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span>
        <span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">),</span>
            <span class="n">norm_ip</span><span class="p">,</span><span class="n">REDIS_CLUSTER_IPLEN</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(((</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">),</span>
            <span class="n">norm_ip</span><span class="p">,</span><span class="n">REDIS_CLUSTER_IPLEN</span><span class="p">);</span>

    <span class="c1">// 检查节点是否已经发送握手请求，如果是的话，那么直接返回，防止出现重复握手</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clusterHandshakeInProgress</span><span class="p">(</span><span class="n">norm_ip</span><span class="p">,</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EAGAIN</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Add the node with a random address (NULL as first argument to</span>
<span class="cm">     * createClusterNode()). Everything will be fixed during the</span>
<span class="cm">     * handskake. */</span>
    <span class="c1">// 给正在 HANDSHAKE 的新节点添加一个随机地址</span>
    <span class="c1">// 当 HANDSHAKE 完成，当前节点会取得 HANDSHAKE 节点的真正地址</span>
    <span class="c1">// 到时会用真地址替换随机地址</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">createClusterNode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="o">|</span><span class="n">REDIS_NODE_MEET</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">norm_ip</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">));</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

    <span class="c1">// 添加节点</span>
    <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Process the gossip section of PING or PONG packets.</span>
<span class="cm"> *</span>
<span class="cm"> * 解释 PING 或 PONG 消息中的信息。</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function assumes that the packet is already sanity-checked</span>
<span class="cm"> * by the caller, not in the content of the gossip section, but in the</span>
<span class="cm"> * length. </span>
<span class="cm"> *</span>
<span class="cm"> * 注意，这个函数假设调用者已经根据消息的长度，对消息进行过合法性检查。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterProcessGossipSection</span><span class="p">(</span><span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 记录这条消息中包含了多少个节点的信息</span>
    <span class="kt">uint16_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

    <span class="c1">// 指向第一个节点的信息</span>
    <span class="n">clusterMsgDataGossip</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsgDataGossip</span><span class="o">*</span><span class="p">)</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ping</span><span class="p">.</span><span class="n">gossip</span><span class="p">;</span>

    <span class="c1">// 取出发送者</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">sender</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">?</span> <span class="n">link</span><span class="o">-&gt;</span><span class="nl">node</span> <span class="p">:</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">);</span>

    <span class="c1">// 遍历所有节点的信息</span>
    <span class="k">while</span><span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sds</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>

        <span class="c1">// 分析节点的 flag</span>
        <span class="kt">uint16_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

        <span class="c1">// 信息节点</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

        <span class="c1">// 取出节点的 flag</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;noflags,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MYSELF</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;myself,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;master,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;slave,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;fail?,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;fail,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;handshake,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_NOADDR</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;noaddr,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="p">[</span><span class="n">sdslen</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="n">ci</span><span class="p">[</span><span class="n">sdslen</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;GOSSIP %.40s %s:%d %s&quot;</span><span class="p">,</span>
            <span class="n">g</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">,</span>
            <span class="n">g</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span>
            <span class="n">ntohs</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">),</span>
            <span class="n">ci</span><span class="p">);</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>

        <span class="cm">/* Update our state accordingly to the gossip sections */</span>
        <span class="c1">// 使用消息中的信息对节点进行更新</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">);</span>
        <span class="c1">// 节点已经存在于当前节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* We already know this node.</span>
<span class="cm">               Handle failure reports, only when the sender is a master. */</span>

            <span class="c1">// 如果 sender 是一个主节点，那么我们需要处理失效报告</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span> <span class="o">&amp;&amp;</span>
                <span class="n">node</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">)</span>
            <span class="p">{</span>

                <span class="c1">// 节点处于 FAIL 或者 PFAIL 状态</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_FAIL</span><span class="o">|</span><span class="n">REDIS_NODE_PFAIL</span><span class="p">))</span> <span class="p">{</span>

                    <span class="c1">// 添加 sender 对 node 的失效报告</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">clusterNodeAddFailureReport</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">sender</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span>
                            <span class="s">&quot;Node %.40s reported node %.40s as not reachable.&quot;</span><span class="p">,</span>
                            <span class="n">sender</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// 尝试将 node 标记为 FAIL</span>
                    <span class="n">markNodeAsFailingIfNeeded</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

                <span class="c1">// 节点处于正常状态</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

                    <span class="c1">// 如果 sender 曾经发送过对 node 的失效报告</span>
                    <span class="c1">// 那么清除该报告</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">clusterNodeDelFailureReport</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">sender</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span>
                            <span class="s">&quot;Node %.40s reported node %.40s is back online.&quot;</span><span class="p">,</span>
                            <span class="n">sender</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* If we already know this node, but it is not reachable, and</span>
<span class="cm">             * we see a different address in the gossip section, start an</span>
<span class="cm">             * handshake with the (possibly) new address: this will result</span>
<span class="cm">             * into a node address update if the handshake will be</span>
<span class="cm">             * successful. */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_FAIL</span><span class="o">|</span><span class="n">REDIS_NODE_PFAIL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)))</span>
            <span class="p">{</span>
                <span class="n">clusterStartHandshake</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">ntohs</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">));</span>
            <span class="p">}</span>

        <span class="c1">// 当前节点不认识 node</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* If it&#39;s not in NOADDR state and we don&#39;t have it, we</span>
<span class="cm">             * start a handshake process against this IP/PORT pairs.</span>
<span class="cm">             *</span>
<span class="cm">             * 如果 node 不在 NOADDR 状态，并且当前节点不认识 node </span>
<span class="cm">             * 那么向 node 发送 HANDSHAKE 消息。</span>
<span class="cm">             *</span>
<span class="cm">             * Note that we require that the sender of this gossip message</span>
<span class="cm">             * is a well known node in our cluster, otherwise we risk</span>
<span class="cm">             * joining another cluster. </span>
<span class="cm">             *</span>
<span class="cm">             * 注意，当前节点必须保证 sender 是本集群的节点，</span>
<span class="cm">             * 否则我们将有加入了另一个集群的风险。</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_NOADDR</span><span class="p">))</span>
                <span class="n">clusterStartHandshake</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">ntohs</span><span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/* Next node */</span>
        <span class="c1">// 处理下个节点的信息</span>
        <span class="n">g</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* IP -&gt; string conversion. &#39;buf&#39; is supposed to at least be 46 bytes. */</span>
<span class="c1">// 将 ip 转换为字符串</span>
<span class="kt">void</span> <span class="nf">nodeIp2String</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">sa</span><span class="p">;</span>
    <span class="kt">socklen_t</span> <span class="n">salen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">getpeername</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">salen</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">redisPanic</span><span class="p">(</span><span class="s">&quot;getpeername() failed.&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="p">.</span><span class="n">ss_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">;</span>
        <span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">),</span><span class="n">buf</span><span class="p">,</span><span class="n">REDIS_CLUSTER_IPLEN</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">;</span>
        <span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">),</span><span class="n">buf</span><span class="p">,</span><span class="n">REDIS_CLUSTER_IPLEN</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Update the node address to the IP address that can be extracted</span>
<span class="cm"> * from link-&gt;fd, and at the specified port.</span>
<span class="cm"> *</span>
<span class="cm"> * 更新节点的地址， IP 和端口可以从 link-&gt;fd 获得。</span>
<span class="cm"> *</span>
<span class="cm"> * Also disconnect the node link so that we&#39;ll connect again to the new</span>
<span class="cm"> * address.</span>
<span class="cm"> *</span>
<span class="cm"> * 并且断开当前的节点连接，并根据新地址创建新连接。</span>
<span class="cm"> *</span>
<span class="cm"> * If the ip/port pair are already correct no operation is performed at</span>
<span class="cm"> * all.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果 ip 和端口和现在的连接相同，那么不执行任何动作。</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns 0 if the node address is still the same,</span>
<span class="cm"> * otherwise 1 is returned. </span>
<span class="cm"> *</span>
<span class="cm"> * 函数返回 0 表示地址不变，地址已被更新则返回 1 。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nodeUpdateAddressIfNeeded</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="n">REDIS_IP_STR_LEN</span><span class="p">];</span>

    <span class="cm">/* We don&#39;t proceed if the link is the same as the sender link, as this</span>
<span class="cm">     * function is designed to see if the node link is consistent with the</span>
<span class="cm">     * symmetric link that is used to receive PINGs from the node.</span>
<span class="cm">     *</span>
<span class="cm">     * As a side effect this function never frees the passed &#39;link&#39;, so</span>
<span class="cm">     * it is safe to call during packet processing. */</span>
    <span class="c1">// 连接不变，直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 获取字符串格式的 ip 地址</span>
    <span class="n">nodeIp2String</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>
    <span class="c1">// 获取端口号</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">port</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* IP / port is different, update it. */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ip</span><span class="p">));</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

    <span class="c1">// 释放旧连接（新连接会在之后自动创建）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="n">freeClusterLink</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Address updated for node %.40s, now %s:%d&quot;</span><span class="p">,</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

    <span class="cm">/* Check if this is our master and we have to change the</span>
<span class="cm">     * replication target as well. */</span>
    <span class="c1">// 如果连接来自当前节点（从节点）的主节点，那么根据新地址设置复制对象</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span> <span class="o">&amp;&amp;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">replicationSetMaster</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reconfigure the specified node &#39;n&#39; as a master. This function is called when</span>
<span class="cm"> * a node that we believed to be a slave is now acting as master in order to</span>
<span class="cm"> * update the state of the node. </span>
<span class="cm"> *</span>
<span class="cm"> * 将节点 n 设置为主节点。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterSetNodeAsMaster</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 已经是主节点了。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 移除 slaveof</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">)</span> <span class="n">clusterNodeRemoveSlave</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>

    <span class="c1">// 关闭 SLAVE 标识</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_SLAVE</span><span class="p">;</span>

    <span class="c1">// 打开 MASTER 标识</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">;</span>

    <span class="c1">// 清零 slaveof 属性</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Update config and state. */</span>
    <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                         <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This function is called when we receive a master configuration via a</span>
<span class="cm"> * PING, PONG or UPDATE packet. What we receive is a node, a configEpoch of the</span>
<span class="cm"> * node, and the set of slots claimed under this configEpoch.</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数在节点通过 PING 、 PONG 、 UPDATE 消息接收到一个 master 的配置时调用，</span>
<span class="cm"> * 函数以一个节点，节点的 configEpoch ，</span>
<span class="cm"> * 以及节点在 configEpoch 纪元下的槽配置作为参数。</span>
<span class="cm"> *</span>
<span class="cm"> * What we do is to rebind the slots with newer configuration compared to our</span>
<span class="cm"> * local configuration, and if needed, we turn ourself into a replica of the</span>
<span class="cm"> * node (see the function comments for more info).</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数要做的就是在 slots 参数的新配置和本节点的当前配置进行对比，</span>
<span class="cm"> * 并更新本节点对槽的布局，</span>
<span class="cm"> * 如果有需要的话，函数还会将本节点转换为 sender 的从节点，</span>
<span class="cm"> * 更多信息请参考函数中的注释。</span>
<span class="cm"> *</span>
<span class="cm"> * The &#39;sender&#39; is the node for which we received a configuration update.</span>
<span class="cm"> * Sometimes it is not actaully the &quot;Sender&quot; of the information, like in the case</span>
<span class="cm"> * we receive the info via an UPDATE packet. </span>
<span class="cm"> *</span>
<span class="cm"> * 根据情况， sender 参数可以是消息的发送者，也可以是消息发送者的主节点。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterUpdateSlotsConfigWith</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">sender</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">senderConfigEpoch</span><span class="p">,</span>
                                  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">slots</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">curmaster</span><span class="p">,</span> <span class="o">*</span><span class="n">newmaster</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Here we set curmaster to this node or the node this node</span>
<span class="cm">     * replicates to if it&#39;s a slave. In the for loop we are</span>
<span class="cm">     * interested to check if slots are taken away from curmaster. */</span>
    <span class="c1">// 1）如果当前节点是主节点，那么将 curmaster 设置为当前节点</span>
    <span class="c1">// 2）如果当前节点是从节点，那么将 curmaster 设置为当前节点正在复制的主节点</span>
    <span class="c1">// 稍后在 for 循环中我们将使用 curmaster 检查与当前节点有关的槽是否发生了变动</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span>
        <span class="n">curmaster</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">curmaster</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">;</span>

    <span class="c1">// 更新槽布局</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 如果 slots 中的槽 j 已经被指派，那么执行以下代码</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* We rebind the slot to the new node claiming it if:</span>
<span class="cm">             * 1) The slot was unassigned.</span>
<span class="cm">             * 2) The new node claims it with a greater configEpoch. */</span>

            <span class="c1">// 当前节点的槽 j 已经是 sender 处理的了，跳过</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sender</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// 如果当前节点的槽 j 未指派</span>
            <span class="c1">// 或者当前节点的槽的配置纪元比 sender 的配置纪元要低（槽的布局可能已经发生了变化）</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">&lt;</span>
                <span class="n">senderConfigEpoch</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 当前节点（或者当前节点的主节点）是否有槽被指派给了 sender ？</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">curmaster</span><span class="p">)</span>
                    <span class="n">newmaster</span> <span class="o">=</span> <span class="n">sender</span><span class="p">;</span>

                <span class="c1">// 将槽 j 设为未指派</span>
                <span class="n">clusterDelSlot</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>

                <span class="c1">// 将槽 j 指派给 sender</span>
                <span class="n">clusterAddSlot</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>

                <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                                     <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span>
                                     <span class="n">CLUSTER_TODO_FSYNC_CONFIG</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* If at least one slot was reassigned from a node to another node</span>
<span class="cm">     * with a greater configEpoch, it is possible that:</span>
<span class="cm">     *</span>
<span class="cm">     * 如果当前节点（或者当前节点的主节点）有至少一个槽被指派到了 sender</span>
<span class="cm">     * 并且 sender 的 configEpoch 比当前节点的纪元要大，</span>
<span class="cm">     * 那么可能发生了：</span>
<span class="cm">     *</span>
<span class="cm">     * 1) We are a master left without slots. This means that we were</span>
<span class="cm">     *    failed over and we should turn into a replica of the new</span>
<span class="cm">     *    master.</span>
<span class="cm">     *    当前节点是一个不再处理任何槽的主节点，</span>
<span class="cm">     *    这时应该将当前节点设置为新主节点的从节点。</span>
<span class="cm">     * 2) We are a slave and our master is left without slots. We need</span>
<span class="cm">     *    to replicate to the new slots owner. </span>
<span class="cm">     *    当前节点是一个从节点，</span>
<span class="cm">     *    并且当前节点的主节点已经不再处理任何槽，</span>
<span class="cm">     *    这时应该将当前节点设置为新主节点的从节点。</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newmaster</span> <span class="o">&amp;&amp;</span> <span class="n">curmaster</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Configuration change detected. Reconfiguring myself as a replica of %.40s&quot;</span><span class="p">,</span> <span class="n">sender</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

        <span class="c1">// 将 sender 设置为当前节点的主节点</span>
        <span class="n">clusterSetMaster</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                             <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span>
                             <span class="n">CLUSTER_TODO_FSYNC_CONFIG</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* When this function is called, there is a packet to process starting</span>
<span class="cm"> * at node-&gt;rcvbuf. Releasing the buffer is up to the caller, so this</span>
<span class="cm"> * function should just handle the higher level stuff of processing the</span>
<span class="cm"> * packet, modifying the cluster state if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * 当这个函数被调用时，说明 node-&gt;rcvbuf 中有一条待处理的信息。</span>
<span class="cm"> * 信息处理完毕之后的释放工作由调用者处理，所以这个函数只需负责处理信息就可以了。</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns 1 if the link is still valid after the packet</span>
<span class="cm"> * was processed, otherwise 0 if the link was freed since the packet</span>
<span class="cm"> * processing lead to some inconsistency error (for instance a PONG</span>
<span class="cm"> * received from the wrong sender ID). </span>
<span class="cm"> *</span>
<span class="cm"> * 如果函数返回 1 ，那么说明处理信息时没有遇到问题，连接依然可用。</span>
<span class="cm"> * 如果函数返回 0 ，那么说明信息处理时遇到了不一致问题</span>
<span class="cm"> * （比如接收到的 PONG 是发送自不正确的发送者 ID 的），连接已经被释放。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterProcessPacket</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">totlen</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">);</span>
    <span class="kt">uint16_t</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
    <span class="kt">uint16_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">senderCurrentEpoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">senderConfigEpoch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">sender</span><span class="p">;</span>

    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">stats_bus_messages_received</span><span class="o">++</span><span class="p">;</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;--- Processing packet of type %d, %lu bytes&quot;</span><span class="p">,</span>
        <span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">totlen</span><span class="p">);</span>

    <span class="cm">/* Perform sanity checks */</span>
    <span class="c1">// 合法性检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">&gt;</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PING</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PONG</span> <span class="o">||</span>
        <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_MEET</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint16_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
        <span class="kt">uint32_t</span> <span class="n">explen</span><span class="p">;</span> <span class="cm">/* expected length of this packet */</span>

        <span class="n">explen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
        <span class="n">explen</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataGossip</span><span class="p">)</span><span class="o">*</span><span class="n">count</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">!=</span> <span class="n">explen</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">explen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>

        <span class="n">explen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataFail</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">!=</span> <span class="n">explen</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PUBLISH</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">explen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>

        <span class="n">explen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataPublish</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">channel_len</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">message_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">!=</span> <span class="n">explen</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</span> <span class="o">||</span>
               <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">explen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">!=</span> <span class="n">explen</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_UPDATE</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">explen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>

        <span class="n">explen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataUpdate</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">!=</span> <span class="n">explen</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check if the sender is a known node. */</span>
    <span class="c1">// 查找发送者节点</span>
    <span class="n">sender</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">);</span>

    <span class="c1">// 节点存在，并且为 handshake 节点</span>
    <span class="c1">// 那么个更新节点的配置纪元信息</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Update our curretEpoch if we see a newer epoch in the cluster. */</span>
        <span class="n">senderCurrentEpoch</span> <span class="o">=</span> <span class="n">ntohu64</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">);</span>
        <span class="n">senderConfigEpoch</span> <span class="o">=</span> <span class="n">ntohu64</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">senderCurrentEpoch</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">)</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span> <span class="o">=</span> <span class="n">senderCurrentEpoch</span><span class="p">;</span>
        <span class="cm">/* Update the sender configEpoch if it is publishing a newer one. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">senderConfigEpoch</span> <span class="o">&gt;</span> <span class="n">sender</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sender</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">=</span> <span class="n">senderConfigEpoch</span><span class="p">;</span>
            <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span><span class="n">CLUSTER_TODO_FSYNC_CONFIG</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Process packets by type. */</span>
    <span class="c1">// 根据消息的类型，处理节点</span>

    <span class="c1">// 这是一条 PING 消息或者 MEET 消息</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PING</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_MEET</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;Ping packet received: %p&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

        <span class="cm">/* Add this node if it is new for us and the msg type is MEET.</span>
<span class="cm">         *</span>
<span class="cm">         * 如果当前节点是第一次遇见这个节点，并且对方发来的是 MEET 信息，</span>
<span class="cm">         * 那么将这个节点添加到当前节点的遇见列表里面。</span>
<span class="cm">         *</span>
<span class="cm">         * In this stage we don&#39;t try to add the node with the right</span>
<span class="cm">         * flags, slaveof pointer, and so forth, as this details will be</span>
<span class="cm">         * resolved when we&#39;ll receive PONGs from the node. </span>
<span class="cm">         *</span>
<span class="cm">         * 节点目前的 flag 、 slaveof 等属性的值都是未设置的，</span>
<span class="cm">         * 等当前节点向对方发送 PING 命令之后，</span>
<span class="cm">         * 这些信息可以从对方回复的 PONG 信息中取得。</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_MEET</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

            <span class="c1">// 创建节点</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">createClusterNode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">);</span>

            <span class="c1">// 设置 IP 和端口</span>
            <span class="n">nodeIp2String</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

            <span class="c1">// 将该节点添加到集群</span>
            <span class="n">clusterAddNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Get info from the gossip section */</span>
        <span class="c1">// 分析消息内容，并取出相应的信息</span>
        <span class="n">clusterProcessGossipSection</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>

        <span class="cm">/* Anyway reply with a PONG */</span>
        <span class="c1">// 向目标节点返回一个 PONG</span>
        <span class="n">clusterSendPing</span><span class="p">(</span><span class="n">link</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_PONG</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* PING or PONG: process config information. */</span>
    <span class="c1">// 这是一条 PING 、 PONG 或者 MEET 消息</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PING</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PONG</span> <span class="o">||</span>
        <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_MEET</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;%s packet received: %p&quot;</span><span class="p">,</span>
            <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PING</span> <span class="o">?</span> <span class="s">&quot;ping&quot;</span> <span class="o">:</span> <span class="s">&quot;pong&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

        <span class="c1">// 连接的 clusterNode 结构存在</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 节点处于 HANDSHAKE 状态</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">)</span> <span class="p">{</span>

                <span class="cm">/* If we already have this node, try to change the</span>
<span class="cm">                 * IP/port of the node with the new one. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                        <span class="s">&quot;Handshake error: we already know node %.40s, updating the address if needed.&quot;</span><span class="p">,</span> <span class="n">sender</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                    <span class="c1">// 如果有需要的话，更新节点的地址</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">nodeUpdateAddressIfNeeded</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span><span class="n">link</span><span class="p">,</span><span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)))</span>
                    <span class="p">{</span>
                        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                                             <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="cm">/* Free this node as we alrady have it. This will</span>
<span class="cm">                     * cause the link to be freed as well. */</span>
                    <span class="c1">// 释放节点</span>
                    <span class="n">freeClusterNode</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
                    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="cm">/* First thing to do is replacing the random name with the</span>
<span class="cm">                 * right node name if this was a handshake stage. */</span>
                <span class="c1">// 用节点的真名替换在 HANDSHAKE 时创建的随机名字</span>
                <span class="n">clusterRenameNode</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">);</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;Handshake with node %.40s completed.&quot;</span><span class="p">,</span>
                    <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

                <span class="c1">// 关闭 HANDSHAKE 状态</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">;</span>

                <span class="c1">// 设置节点的角色</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="n">REDIS_NODE_MASTER</span><span class="o">|</span><span class="n">REDIS_NODE_SLAVE</span><span class="p">);</span>

                <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>

            <span class="c1">// 节点已存在，但它的 id 和当前节点保存的 id 不同</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">,</span>
                        <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="cm">/* If the reply has a non matching node ID we</span>
<span class="cm">                 * disconnect this node and set it as not having an associated</span>
<span class="cm">                 * address. */</span>
                <span class="c1">// 那么将这个节点设为 NOADDR </span>
                <span class="c1">// 并断开连接</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;PONG contains mismatching sender ID&quot;</span><span class="p">);</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_NOADDR</span><span class="p">;</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="c1">// 断开连接</span>
                <span class="n">freeClusterLink</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>

                <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Update the node address if it changed. */</span>
        <span class="c1">// 如果发送的消息为 PING </span>
        <span class="c1">// 并且发送者不在 HANDSHAKE 状态</span>
        <span class="c1">// 那么更新发送者的信息</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PING</span> <span class="o">&amp;&amp;</span>
            <span class="o">!</span><span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">nodeUpdateAddressIfNeeded</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span><span class="n">link</span><span class="p">,</span><span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Update our info about the node */</span>
        <span class="c1">// 如果这是一条 PONG 消息，那么更新我们关于 node 节点的认识</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PONG</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 最后一次接到该节点的 PONG 的时间</span>
            <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">pong_received</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

            <span class="c1">// 清零最近一次等待 PING 命令的时间</span>
            <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="cm">/* The PFAIL condition can be reversed without external</span>
<span class="cm">             * help if it is momentary (that is, if it does not</span>
<span class="cm">             * turn into a FAIL state).</span>
<span class="cm">             *</span>
<span class="cm">             * 接到节点的 PONG 回复，我们可以移除节点的 PFAIL 状态。</span>
<span class="cm">             *</span>
<span class="cm">             * The FAIL condition is also reversible under specific</span>
<span class="cm">             * conditions detected by clearNodeFailureIfNeeded(). </span>
<span class="cm">             *</span>
<span class="cm">             * 如果节点的状态为 FAIL ，</span>
<span class="cm">             * 那么是否撤销该状态要根据 clearNodeFailureIfNeeded() 函数来决定。</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">)</span> <span class="p">{</span>
                
                <span class="c1">// 撤销 PFAIL</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_PFAIL</span><span class="p">;</span>

                <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                                     <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 看是否可以撤销 FAIL</span>
                <span class="n">clearNodeFailureIfNeeded</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Check for role switch: slave -&gt; master or master -&gt; slave. */</span>
        <span class="c1">// 检测节点的身份消息</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 发送消息的节点的 slaveof 为 REDIS_NODE_NULL_NAME</span>
            <span class="c1">// 那么 sender 就是一个主节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span><span class="n">REDIS_NODE_NULL_NAME</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">)))</span>
            <span class="p">{</span>
                <span class="cm">/* Node is a master. */</span>
                <span class="c1">// 设置 sender 为主节点</span>
                <span class="n">clusterSetNodeAsMaster</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

            <span class="c1">// sender 的 slaveof 不为空，那么这是一个从节点</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

                <span class="cm">/* Node is a slave. */</span>
                <span class="c1">// 取出 sender 的主节点</span>
                <span class="n">clusterNode</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">);</span>

                <span class="c1">// sender 由主节点变成了从节点，重新配置 sender</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span> <span class="p">{</span>

                    <span class="cm">/* Master turned into a slave! Reconfigure the node. */</span>

                    <span class="c1">// 删除所有由该节点负责的槽</span>
                    <span class="n">clusterDelNodeSlots</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

                    <span class="c1">// 更新标识</span>
                    <span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_MASTER</span><span class="p">;</span>
                    <span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">;</span>

                    <span class="cm">/* Remove the list of slaves from the node. */</span>
                    <span class="c1">// 移除 sender 的从节点名单</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="p">)</span> <span class="n">clusterNodeResetSlaves</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

                    <span class="cm">/* Update config and state. */</span>
                    <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                                         <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="cm">/* Master node changed for this slave? */</span>
                <span class="c1">// 检查 sender 的主节点是否变更</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">!=</span> <span class="n">master</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">// 如果 sender 之前的主节点不是现在的主节点</span>
                    <span class="c1">// 那么在旧主节点的从节点列表中移除 sender</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">)</span>
                        <span class="n">clusterNodeRemoveSlave</span><span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span><span class="n">sender</span><span class="p">);</span>

                    <span class="c1">// 并在新主节点的从节点列表中添加 sender</span>
                    <span class="n">clusterNodeAddSlave</span><span class="p">(</span><span class="n">master</span><span class="p">,</span><span class="n">sender</span><span class="p">);</span>

                    <span class="c1">// 更新 sender 的主节点</span>
                    <span class="n">sender</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>

                    <span class="cm">/* Update config. */</span>
                    <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Update our info about served slots.</span>
<span class="cm">         *</span>
<span class="cm">         * 更新当前节点对 sender 所处理槽的认识。</span>
<span class="cm">         *</span>
<span class="cm">         * Note: this MUST happen after we update the master/slave state</span>
<span class="cm">         * so that REDIS_NODE_MASTER flag will be set. </span>
<span class="cm">         *</span>
<span class="cm">         * 这部分的更新 *必须* 在更新 sender 的主/从节点信息之后，</span>
<span class="cm">         * 因为这里需要用到 REDIS_NODE_MASTER 标识。</span>
<span class="cm">         */</span>

        <span class="cm">/* Many checks are only needed if the set of served slots this</span>
<span class="cm">         * instance claims is different compared to the set of slots we have for</span>
<span class="cm">         * it. Check this ASAP to avoid other computational expansive checks later. </span>
<span class="cm">         *</span>
<span class="cm">         * 大部分操作都只会在当前节点对 sender 的槽分配和 sender 实际的槽分配之间出现区别时，</span>
<span class="cm">         * 才会进行。</span>
<span class="cm">         */</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">sender_master</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Sender or its master if it is a slave. */</span>
        <span class="kt">int</span> <span class="n">dirty_slots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Sender claimed slots don&#39;t match my view? */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 如果 sender 是主节点，那么指向 sender</span>
            <span class="c1">// 否则指向 sender 正在复制的主节点</span>
            <span class="n">sender_master</span> <span class="o">=</span> <span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span> <span class="o">?</span> <span class="nl">sender</span> <span class="p">:</span>
                                                                  <span class="n">sender</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">;</span>

            <span class="c1">// 检查 sender_master 处理的槽是否出现了变动</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sender_master</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dirty_slots</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">sender_master</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span>
                        <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* 1) If the sender of the message is a master, and we detected that the</span>
<span class="cm">         *    set of slots it claims changed, scan the slots to see if we need</span>
<span class="cm">         *    to update our configuration. */</span>
        <span class="c1">// 如果 sender 是主节点，并且槽配置出现了变动</span>
        <span class="c1">// 检查 sender 槽的信息，看看当前节点的槽信息是否需要更新</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span> <span class="o">&amp;&amp;</span> <span class="n">dirty_slots</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">clusterUpdateSlotsConfigWith</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span><span class="n">senderConfigEpoch</span><span class="p">,</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* 2) We also check for the reverse condition, that is, the sender claims</span>
<span class="cm">         *    to serve slots we know are served by a master with a greater</span>
<span class="cm">         *    configEpoch. If this happens we inform the sender.</span>
<span class="cm">         *</span>
<span class="cm">         *    检测和条件 1 的相反条件，也即是，</span>
<span class="cm">         *    sender 处理的槽的配置纪元比当前节点已知的某个节点的配置纪元要低，</span>
<span class="cm">         *    如果是这样的话，通知 sender 。</span>
<span class="cm">         *</span>
<span class="cm">         * This is useful because sometimes after a partition heals, a reappearing</span>
<span class="cm">         * master may be the last one to claim a given set of hash slots, but with</span>
<span class="cm">         * a configuration that other instances know to be deprecated. Example:</span>
<span class="cm">         *</span>
<span class="cm">         * A and B are master and slave for slots 1,2,3.</span>
<span class="cm">         * A is partitioned away, B gets promoted.</span>
<span class="cm">         * B is partitioned away, and A returns available.</span>
<span class="cm">         *</span>
<span class="cm">         * Usually B would PING A publishing its set of served slots and its</span>
<span class="cm">         * configEpoch, but because of the partition B can&#39;t inform A of the new</span>
<span class="cm">         * configuration, so other nodes that have an updated table must do it.</span>
<span class="cm">         * In this way A will stop to act as a master (or can try to failover if</span>
<span class="cm">         * there are the conditions to win the election). */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span> <span class="o">&amp;&amp;</span> <span class="n">dirty_slots</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                <span class="c1">// 检测 slots 中的槽 j 是否已经被指派</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>

                    <span class="c1">// 当前节点认为槽 j 由 sender 负责处理，</span>
                    <span class="c1">// 或者当前节点认为该槽未指派，那么跳过该槽</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sender</span> <span class="o">||</span>
                        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                    <span class="c1">// 当前节点认为槽 j 的配置纪元比 sender 的配置纪元要大</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">&gt;</span>
                        <span class="n">senderConfigEpoch</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                            <span class="s">&quot;Node %.40s has old slots configuration, sending &quot;</span>
                            <span class="s">&quot;an UPDATE message about %.40s&quot;</span><span class="p">,</span>
                                <span class="n">sender</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

                        <span class="c1">// 向 sender 发送关于槽 j 的更新信息</span>
                        <span class="n">clusterSendUpdate</span><span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

                        <span class="cm">/* TODO: instead of exiting the loop send every other</span>
<span class="cm">                         * UPDATE packet for other nodes that are the new owner</span>
<span class="cm">                         * of sender&#39;s slots. */</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Get info from the gossip section */</span>
        <span class="c1">// 分析消息内容，并取出相应的信息</span>
        <span class="n">clusterProcessGossipSection</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>

    <span class="c1">// 这是一条 FAIL 消息： sender 告知当前节点，某个节点已经进入 FAIL 状态。</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">failing</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 获取下线节点的消息</span>
            <span class="n">failing</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fail</span><span class="p">.</span><span class="n">about</span><span class="p">.</span><span class="n">nodename</span><span class="p">);</span>

            <span class="c1">// 下线的节点既不是当前节点，也没有处于 FAIL 状态</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">failing</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">failing</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_FAIL</span><span class="o">|</span><span class="n">REDIS_NODE_MYSELF</span><span class="p">)))</span>
            <span class="p">{</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
                    <span class="s">&quot;FAIL message received from %.40s about %.40s&quot;</span><span class="p">,</span>
                    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fail</span><span class="p">.</span><span class="n">about</span><span class="p">.</span><span class="n">nodename</span><span class="p">);</span>

                <span class="c1">// 打开 FAIL 状态</span>
                <span class="n">failing</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">;</span>
                <span class="n">failing</span><span class="o">-&gt;</span><span class="n">fail_time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
                <span class="n">failing</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_PFAIL</span><span class="p">;</span>

                <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
                <span class="s">&quot;Ignoring FAIL message from unknonw node %.40s about %.40s&quot;</span><span class="p">,</span>
                <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fail</span><span class="p">.</span><span class="n">about</span><span class="p">.</span><span class="n">nodename</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="c1">// 这是一条 PUBLISH 消息</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PUBLISH</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">robj</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="o">*</span><span class="n">message</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">channel_len</span><span class="p">,</span> <span class="n">message_len</span><span class="p">;</span>

        <span class="cm">/* Don&#39;t bother creating useless objects if there are no</span>
<span class="cm">         * Pub/Sub subscribers. */</span>
        <span class="c1">// 只在有订阅者时创建消息对象</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">pubsub_channels</span><span class="p">)</span> <span class="o">||</span> <span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">pubsub_patterns</span><span class="p">))</span> <span class="p">{</span>

            <span class="c1">// 频道长度</span>
            <span class="n">channel_len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">channel_len</span><span class="p">);</span>

            <span class="c1">// 消息长度</span>
            <span class="n">message_len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">message_len</span><span class="p">);</span>

            <span class="c1">// 频道</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">createStringObject</span><span class="p">(</span>
                        <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">bulk_data</span><span class="p">,</span><span class="n">channel_len</span><span class="p">);</span>

            <span class="c1">// 消息</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">createStringObject</span><span class="p">(</span>
                        <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">bulk_data</span><span class="o">+</span><span class="n">channel_len</span><span class="p">,</span> <span class="n">message_len</span><span class="p">);</span>

            <span class="c1">// 发送消息</span>
            <span class="n">pubsubPublishMessage</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="n">message</span><span class="p">);</span>

            <span class="n">decrRefCount</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
            <span class="n">decrRefCount</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="c1">// 这是一条请求获得故障迁移授权的消息： sender 请求当前节点为它进行故障转移投票</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sender</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* We don&#39;t know that node. */</span>
        <span class="c1">// 如果条件允许的话，向 sender 投票，支持它进行故障转移</span>
        <span class="n">clusterSendFailoverAuthIfNeeded</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span><span class="n">hdr</span><span class="p">);</span>

    <span class="c1">// 这是一条故障迁移投票信息： sender 支持当前节点执行故障转移操作</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sender</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* We don&#39;t know that node. */</span>

        <span class="cm">/* We consider this vote only if the sender is a master serving</span>
<span class="cm">         * a non zero number of slots, and its currentEpoch is greater or</span>
<span class="cm">         * equal to epoch where this node started the election. */</span>
        <span class="c1">// 只有正在处理至少一个槽的主节点的投票会被视为是有效投票</span>
        <span class="c1">// 只有符合以下条件， sender 的投票才算有效：</span>
        <span class="c1">// 1） sender 是主节点</span>
        <span class="c1">// 2） sender 正在处理至少一个槽</span>
        <span class="c1">// 3） sender 的配置纪元大于等于当前节点的配置纪元</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span> <span class="o">&amp;&amp;</span>
            <span class="n">sender</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="n">senderCurrentEpoch</span> <span class="o">&gt;=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_epoch</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 增加支持票数</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_count</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* Maybe we reached a quorum here, set a flag to make sure</span>
<span class="cm">             * we check ASAP. */</span>
            <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_HANDLE_FAILOVER</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="c1">// 这是一条更新消息： sender 告知当前节点，需要更新自己的槽布局</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_UPDATE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="cm">/* The node the update is about. */</span>

        <span class="c1">// 消息中的配置纪元</span>
        <span class="kt">uint64_t</span> <span class="n">reportedConfigEpoch</span> <span class="o">=</span> <span class="n">ntohu64</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">update</span><span class="p">.</span><span class="n">nodecfg</span><span class="p">.</span><span class="n">configEpoch</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sender</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* We don&#39;t know the sender. */</span>

        <span class="c1">// 获取需要更新的节点</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">update</span><span class="p">.</span><span class="n">nodecfg</span><span class="p">.</span><span class="n">nodename</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* We don&#39;t know the reported node. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">&gt;=</span> <span class="n">reportedConfigEpoch</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Nothing new. */</span>

        <span class="cm">/* If in our current config the node is a slave, set it as a master. */</span>
        <span class="c1">// 如果节点 n 为从节点，那么将它设置为主节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="n">clusterSetNodeAsMaster</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="cm">/* Check the bitmap of served slots and udpate our config accordingly. */</span>
        <span class="c1">// 对节点 n 的槽布局和当前节点的槽布局进行对比，并在有需要时进行更新</span>
        <span class="n">clusterUpdateSlotsConfigWith</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">reportedConfigEpoch</span><span class="p">,</span>
            <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">update</span><span class="p">.</span><span class="n">nodecfg</span><span class="p">.</span><span class="n">slots</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Received unknown packet type: %d&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function is called when we detect the link with this node is lost.</span>

<span class="cm">   这个函数在发现节点的连接已经丢失时使用。</span>

<span class="cm">   We set the node as no longer connected. The Cluster Cron will detect</span>
<span class="cm">   this connection and will try to get it connected again.</span>

<span class="cm">   我们将节点的状态设置为断开状态，Cluster Cron 会根据该状态尝试重新连接节点。</span>
<span class="cm">   </span>
<span class="cm">   Instead if the node is a temporary node used to accept a query, we</span>
<span class="cm">   completely free the node on error. </span>

<span class="cm">   如果连接是一个临时连接的话，那么它就会被永久释放，不再进行重连。</span>

<span class="cm">   */</span>
<span class="kt">void</span> <span class="nf">handleLinkIOError</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">freeClusterLink</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send data. This is handled using a trivial send buffer that gets</span>
<span class="cm"> * consumed by write(). We don&#39;t try to optimize this for speed too much</span>
<span class="cm"> * as this is a very low traffic channel. </span>
<span class="cm"> *</span>
<span class="cm"> * 写事件处理器，用于向集群节点发送信息。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterWriteHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterLink</span><span class="o">*</span><span class="p">)</span> <span class="n">privdata</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">nwritten</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

    <span class="c1">// 写入信息</span>
    <span class="n">nwritten</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">,</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">));</span>

    <span class="c1">// 写入错误</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;I/O error writing to node link: %s&quot;</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">handleLinkIOError</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 删除已写入的部分</span>
    <span class="n">sdsrange</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">,</span><span class="n">nwritten</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 如果所有当前节点输出缓冲区里面的所有内容都已经写入完毕</span>
    <span class="c1">// （缓冲区为空）</span>
    <span class="c1">// 那么删除写事件处理器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_WRITABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read data. Try to read the first field of the header first to check the</span>
<span class="cm"> * full length of the packet. When a whole packet is in memory this function</span>
<span class="cm"> * will call the function to process the packet. And so forth. */</span>
<span class="c1">// 读事件处理器</span>
<span class="c1">// 首先读入内容的头，以判断读入内容的长度</span>
<span class="c1">// 如果内容是一个 whole packet ，那么调用函数来处理这个 packet 。</span>
<span class="kt">void</span> <span class="nf">clusterReadHandler</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)];</span>
    <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">;</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
    <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterLink</span><span class="o">*</span><span class="p">)</span> <span class="n">privdata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">readlen</span><span class="p">,</span> <span class="n">rcvbuflen</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

    <span class="c1">// 尽可能地多读数据</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Read as long as there is data to read. */</span>

        <span class="c1">// 检查输入缓冲区的长度</span>
        <span class="n">rcvbuflen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">);</span>

        <span class="c1">// 头信息（4字节）未读入完</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rcvbuflen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* First, obtain the first four bytes to get the full message</span>
<span class="cm">             * length. */</span>
            <span class="n">readlen</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">rcvbuflen</span><span class="p">;</span>

        <span class="c1">// 已读入完整的头信息</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Finally read the full message. */</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rcvbuflen</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Perform some sanity check on the message length. */</span>
                <span class="c1">// 检查信息长度是否在合理范围</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CLUSTERMSG_MIN_LEN</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                        <span class="s">&quot;Bad message length received from Cluster bus.&quot;</span><span class="p">);</span>
                    <span class="n">handleLinkIOError</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 记录已读入内容长度</span>
            <span class="n">readlen</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">)</span> <span class="o">-</span> <span class="n">rcvbuflen</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">readlen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="n">readlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 读入内容</span>
        <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">readlen</span><span class="p">);</span>

        <span class="c1">// 没有内容可读</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="cm">/* No more data ready. */</span>

        <span class="c1">// 处理读入错误</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* I/O error... */</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;I/O error reading from node link: %s&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;connection closed&quot;</span> <span class="o">:</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">handleLinkIOError</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Read data and recast the pointer to the new buffer. */</span>
            <span class="c1">// 将读入的内容追加进输入缓冲区里面</span>
            <span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">nread</span><span class="p">);</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">;</span>
            <span class="n">rcvbuflen</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Total length obtained? Process this packet. */</span>
        <span class="c1">// 检查已读入内容的长度，看是否整条信息已经被读入了</span>
        <span class="c1">// 如果是的话，执行处理信息的函数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rcvbuflen</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">rcvbuflen</span> <span class="o">==</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">clusterProcessPacket</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">sdsfree</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span><span class="p">);</span>
                <span class="n">link</span><span class="o">-&gt;</span><span class="n">rcvbuf</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span> <span class="cm">/* Link no longer valid. */</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Put stuff into the send buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * 发送信息</span>
<span class="cm"> *</span>
<span class="cm"> * It is guaranteed that this function will never have as a side effect</span>
<span class="cm"> * the link to be invalidated, so it is safe to call this function</span>
<span class="cm"> * from event handlers that will do stuff with the same link later. </span>
<span class="cm"> *</span>
<span class="cm"> * 因为发送不会对连接本身造成不良的副作用，</span>
<span class="cm"> * 所以可以在发送信息的处理器上做一些针对连接本身的动作。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterSendMessage</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msglen</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 安装写事件处理器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">msglen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">,</span>
                    <span class="n">clusterWriteHandler</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>

    <span class="c1">// 将信息追加到输出缓冲区</span>
    <span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sndbuf</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">msglen</span><span class="p">);</span>

    <span class="c1">// 增一发送信息计数</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">stats_bus_messages_sent</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send a message to all the nodes that are part of the cluster having</span>
<span class="cm"> * a connected link.</span>
<span class="cm"> *</span>
<span class="cm"> * 向节点连接的所有其他节点发送信息。</span>
<span class="cm"> * </span>
<span class="cm"> * It is guaranteed that this function will never have as a side effect</span>
<span class="cm"> * some node-&gt;link to be invalidated, so it is safe to call this function</span>
<span class="cm"> * from event handlers that will do stuff with node links later. */</span>
<span class="kt">void</span> <span class="nf">clusterBroadcastMessage</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="c1">// 遍历所有已知节点</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 不向未连接节点发送信息</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 不向节点自身或者 HANDSHAKE 状态的节点发送信息</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_MYSELF</span><span class="o">|</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 发送信息</span>
        <span class="n">clusterSendMessage</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Build the message header */</span>
<span class="c1">// 构建信息</span>
<span class="kt">void</span> <span class="nf">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>

    <span class="cm">/* If this node is a master, we send its slots bitmap and configEpoch.</span>
<span class="cm">     *</span>
<span class="cm">     * 如果这是一个主节点，那么发送该节点的槽 bitmap 和配置纪元。</span>
<span class="cm">     *</span>
<span class="cm">     * If this node is a slave we send the master&#39;s information instead (the</span>
<span class="cm">     * node is flagged as slave so the receiver knows that it is NOT really</span>
<span class="cm">     * in charge for this slots. </span>
<span class="cm">     *</span>
<span class="cm">     * 如果这是一个从节点，</span>
<span class="cm">     * 那么发送这个节点的主节点的槽 bitmap 和配置纪元。</span>
<span class="cm">     *</span>
<span class="cm">     * 因为接收信息的节点通过标识可以知道这个节点是一个从节点，</span>
<span class="cm">     * 所以接收信息的节点不会将从节点错认作是主节点。</span>
<span class="cm">     */</span>
    <span class="n">master</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span> <span class="o">&amp;&amp;</span>
              <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">)</span> <span class="o">?</span>
              <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="nl">slaveof</span> <span class="p">:</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">;</span>

    <span class="c1">// 清零信息头</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>

    <span class="c1">// 设置信息类型</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

    <span class="c1">// 设置信息发送者</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">sender</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>

    <span class="c1">// 设置槽</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">,</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">));</span>

    <span class="c1">// 清零 slaveof 域</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
    <span class="c1">// 如果节点是从节点的话，那么设置 slaveof 域</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 设置端口号</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>

    <span class="c1">// 设置标识</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

    <span class="c1">// 设置状态</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

    <span class="cm">/* Set the currentEpoch and configEpochs. */</span>
    <span class="c1">// 设置集群当前配置纪元</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">currentEpoch</span> <span class="o">=</span> <span class="n">htonu64</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">);</span>
    <span class="c1">// 设置主节点当前配置纪元</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">=</span> <span class="n">htonu64</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">);</span>

    <span class="c1">// 计算信息的长度</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_FAIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">totlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataFail</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_UPDATE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">totlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataUpdate</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 设置信息的长度</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">totlen</span><span class="p">);</span>
    <span class="cm">/* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */</span>
<span class="p">}</span>

<span class="cm">/* Send a PING or PONG packet to the specified node, making sure to add enough</span>
<span class="cm"> * gossip informations. */</span>
<span class="c1">// 向指定节点发送一个 PING 或者 PONG 信息</span>
<span class="kt">void</span> <span class="nf">clusterSendPing</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)];</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">gossipcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totlen</span><span class="p">;</span>
    <span class="cm">/* freshnodes is the number of nodes we can still use to populate the</span>
<span class="cm">     * gossip section of the ping packet. Basically we start with the nodes</span>
<span class="cm">     * we have in memory minus two (ourself and the node we are sending the</span>
<span class="cm">     * message to). Every time we add a node we decrement the counter, so when</span>
<span class="cm">     * it will drop to &lt;= zero we know there is no more gossip info we can</span>
<span class="cm">     * send. */</span>
    <span class="c1">// freshnodes 是用于发送 gossip 信息的计数器</span>
    <span class="c1">// 每次发送一条信息时，程序将 freshnodes 的值减一</span>
    <span class="c1">// 当 freshnodes 的数值小于等于 0 时，程序停止发送 gossip 信息</span>
    <span class="c1">// freshnodes 的数量是节点目前的 nodes 表中的节点数量减去 2 </span>
    <span class="c1">// 这里的 2 指两个节点，一个是 myself 节点（也即是发送信息的这个节点）</span>
    <span class="c1">// 另一个是接受 gossip 信息的节点</span>
    <span class="kt">int</span> <span class="n">freshnodes</span> <span class="o">=</span> <span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>

    <span class="c1">// 如果发送的信息是 PING ，那么更新最后一次发送 PING 命令的时间戳</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">CLUSTERMSG_TYPE_PING</span><span class="p">)</span>
        <span class="n">link</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>

    <span class="c1">// 设置信息</span>
    <span class="n">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">type</span><span class="p">);</span>
        
    <span class="cm">/* Populate the gossip fields */</span>
    <span class="c1">// 每个节点有 freshnodes 次发送 gossip 信息的机会</span>
    <span class="c1">// 每次向目标节点发送 2 个被选中节点的 gossip 信息（gossipcount 计数）</span>
    <span class="k">while</span><span class="p">(</span><span class="n">freshnodes</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">gossipcount</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 从 nodes 字典中随机选出一个节点（被选中节点）</span>
        <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictGetRandomKey</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="n">clusterMsgDataGossip</span> <span class="o">*</span><span class="n">gossip</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

        <span class="cm">/* In the gossip section don&#39;t include:</span>
<span class="cm">         * 以下节点不能作为被选中节点：</span>
<span class="cm">         * 1) Myself.</span>
<span class="cm">         *    节点本身。</span>
<span class="cm">         * 2) Nodes in HANDSHAKE state.</span>
<span class="cm">         *    处于 HANDSHAKE 状态的节点。</span>
<span class="cm">         * 3) Nodes with the NOADDR flag set.</span>
<span class="cm">         *    带有 NOADDR 标识的节点</span>
<span class="cm">         * 4) Disconnected nodes if they don&#39;t have configured slots.</span>
<span class="cm">         *    因为不处理任何槽而被断开连接的节点 </span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">this</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">||</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="o">|</span><span class="n">REDIS_NODE_NOADDR</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">{</span>
                <span class="n">freshnodes</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* otherwise we may loop forever. */</span>
                <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Check if we already added this node */</span>
        <span class="c1">// 检查被选中节点是否已经在 hdr-&gt;data.ping.gossip 数组里面</span>
        <span class="c1">// 如果是的话说明这个节点之前已经被选中了</span>
        <span class="c1">// 不要再选中它（否则就会出现重复）</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">gossipcount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ping</span><span class="p">.</span><span class="n">gossip</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">nodename</span><span class="p">,</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">gossipcount</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* Add it */</span>

        <span class="c1">// 这个被选中节点有效，计数器减一</span>
        <span class="n">freshnodes</span><span class="o">--</span><span class="p">;</span>

        <span class="c1">// 指向 gossip 信息结构</span>
        <span class="n">gossip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ping</span><span class="p">.</span><span class="n">gossip</span><span class="p">[</span><span class="n">gossipcount</span><span class="p">]);</span>

        <span class="c1">// 将被选中节点的名字记录到 gossip 信息</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">gossip</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">,</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>
        <span class="c1">// 将被选中节点的 PING 命令发送时间戳记录到 gossip 信息</span>
        <span class="n">gossip</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ping_sent</span><span class="p">);</span>
        <span class="c1">// 将被选中节点的 PING 命令回复的时间戳记录到 gossip 信息</span>
        <span class="n">gossip</span><span class="o">-&gt;</span><span class="n">pong_received</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pong_received</span><span class="p">);</span>
        <span class="c1">// 将被选中节点的 IP 记录到 gossip 信息</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">gossip</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">));</span>
        <span class="c1">// 将被选中节点的端口号记录到 gossip 信息</span>
        <span class="n">gossip</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
        <span class="c1">// 将被选中节点的标识值记录到 gossip 信息</span>
        <span class="n">gossip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

        <span class="c1">// 这个被选中节点有效，计数器增一</span>
        <span class="n">gossipcount</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 计算信息长度</span>
    <span class="n">totlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
    <span class="n">totlen</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataGossip</span><span class="p">)</span><span class="o">*</span><span class="n">gossipcount</span><span class="p">);</span>
    <span class="c1">// 将被选中节点的数量（gossip 信息中包含了多少个节点的信息）</span>
    <span class="c1">// 记录在 count 属性里面</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">gossipcount</span><span class="p">);</span>
    <span class="c1">// 将信息的长度记录到信息里面</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">totlen</span><span class="p">);</span>

    <span class="c1">// 发送信息</span>
    <span class="n">clusterSendMessage</span><span class="p">(</span><span class="n">link</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">totlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a PONG packet to every connected node that&#39;s not in handshake state</span>
<span class="cm"> * and for which we have a valid link.</span>
<span class="cm"> *</span>
<span class="cm"> * 向所有未在 HANDSHAKE 状态，并且连接正常的节点发送 PONG 回复。</span>
<span class="cm"> *</span>
<span class="cm"> * In Redis Cluster pongs are not used just for failure detection, but also</span>
<span class="cm"> * to carry important configuration information. So broadcasting a pong is</span>
<span class="cm"> * useful when something changes in the configuration and we want to make</span>
<span class="cm"> * the cluster aware ASAP (for instance after a slave promotion). *</span>
<span class="cm"> * 在集群中， PONG 不仅可以用来检测节点状态，</span>
<span class="cm"> * 还可以携带一些重要的信息。</span>
<span class="cm"> *</span>
<span class="cm"> * 因此广播 PONG 回复在配置发生变化（比如从节点转变为主节点），</span>
<span class="cm"> * 并且当前节点想让其他节点尽快知悉这一变化的时候，</span>
<span class="cm"> * 就会广播 PONG 回复。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterBroadcastPong</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="c1">// 遍历所有节点</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 不向未建立连接的节点发送</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="c1">// 不向 HANDSHAKE 以及自己发送</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_MYSELF</span><span class="o">|</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 发送 PONG 信息</span>
        <span class="n">clusterSendPing</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_PONG</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a PUBLISH message.</span>
<span class="cm"> *</span>
<span class="cm"> * 发送一条 PUBLISH 消息。</span>
<span class="cm"> *</span>
<span class="cm"> * If link is NULL, then the message is broadcasted to the whole cluster. </span>
<span class="cm"> *</span>
<span class="cm"> * 如果 link 参数为 NULL ，那么将消息广播给整个集群。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterSendPublish</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)],</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">totlen</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">channel_len</span><span class="p">,</span> <span class="n">message_len</span><span class="p">;</span>

    <span class="c1">// 频道</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">getDecodedObject</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>

    <span class="c1">// 消息</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">getDecodedObject</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>

    <span class="c1">// 频道和消息的长度</span>
    <span class="n">channel_len</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">message_len</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>

    <span class="c1">// 构建消息</span>
    <span class="n">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_PUBLISH</span><span class="p">);</span>
    <span class="n">totlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
    <span class="n">totlen</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsgDataPublish</span><span class="p">)</span> <span class="o">+</span> <span class="n">channel_len</span> <span class="o">+</span> <span class="n">message_len</span><span class="p">;</span>

    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">channel_len</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">channel_len</span><span class="p">);</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">message_len</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">message_len</span><span class="p">);</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">totlen</span><span class="p">);</span>

    <span class="cm">/* Try to use the local buffer if possible */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">payload</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">payload</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">totlen</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span><span class="n">hdr</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">));</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">payload</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 保存频道和消息到消息结构中</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">bulk_data</span><span class="p">,</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">publish</span><span class="p">.</span><span class="n">msg</span><span class="p">.</span><span class="n">bulk_data</span><span class="o">+</span><span class="n">sdslen</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">),</span>
        <span class="n">message</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>

    <span class="c1">// 选择发送到节点还是广播至整个集群</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span>
        <span class="n">clusterSendMessage</span><span class="p">(</span><span class="n">link</span><span class="p">,</span><span class="n">payload</span><span class="p">,</span><span class="n">totlen</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">clusterBroadcastMessage</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span><span class="n">totlen</span><span class="p">);</span>

    <span class="n">decrRefCount</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
    <span class="n">decrRefCount</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">payload</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">)</span> <span class="n">zfree</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a FAIL message to all the nodes we are able to contact.</span>
<span class="cm"> *</span>
<span class="cm"> * 向当前节点已知的所有节点发送 FAIL 信息。</span>
<span class="cm"> *</span>
<span class="cm"> * The FAIL message is sent when we detect that a node is failing</span>
<span class="cm"> * (REDIS_NODE_PFAIL) and we also receive a gossip confirmation of this:</span>
<span class="cm"> * we switch the node state to REDIS_NODE_FAIL and ask all the other</span>
<span class="cm"> * nodes to do the same ASAP. </span>
<span class="cm"> *</span>
<span class="cm"> * 如果当前节点将 node 标记为 PFAIL 状态，</span>
<span class="cm"> * 并且通过 gossip 协议，</span>
<span class="cm"> * 从足够数量的节点那些得到了 node 已经下线的支持， </span>
<span class="cm"> * 那么当前节点会将 node 标记为 FAIL ，</span>
<span class="cm"> * 并执行这个函数，向其他 node 发送 FAIL 消息，</span>
<span class="cm"> * 要求它们也将 node 标记为 FAIL 。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterSendFail</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">nodename</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)];</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>

    <span class="c1">// 创建失效消息</span>
    <span class="n">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_FAIL</span><span class="p">);</span>

    <span class="c1">// 记录命令</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fail</span><span class="p">.</span><span class="n">about</span><span class="p">.</span><span class="n">nodename</span><span class="p">,</span><span class="n">nodename</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>

    <span class="c1">// 广播消息</span>
    <span class="n">clusterBroadcastMessage</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Send an UPDATE message to the specified link carrying the specified &#39;node&#39;</span>
<span class="cm"> * slots configuration. The node name, slots bitmap, and configEpoch info</span>
<span class="cm"> * are included. </span>
<span class="cm"> *</span>
<span class="cm"> * 向连接 link 发送包含给定 node 槽配置的 UPDATE 消息，</span>
<span class="cm"> * 包括节点名称，槽位图，以及配置纪元。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterSendUpdate</span><span class="p">(</span><span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)];</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 创建消息</span>
    <span class="n">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_UPDATE</span><span class="p">);</span>

    <span class="c1">// 设置节点名</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">update</span><span class="p">.</span><span class="n">nodecfg</span><span class="p">.</span><span class="n">nodename</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">REDIS_CLUSTER_NAMELEN</span><span class="p">);</span>

    <span class="c1">// 设置配置纪元</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">update</span><span class="p">.</span><span class="n">nodecfg</span><span class="p">.</span><span class="n">configEpoch</span> <span class="o">=</span> <span class="n">htonu64</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">);</span>

    <span class="c1">// 更新节点的槽位图</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">update</span><span class="p">.</span><span class="n">nodecfg</span><span class="p">.</span><span class="n">slots</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">));</span>

    <span class="c1">// 发送信息</span>
    <span class="n">clusterSendMessage</span><span class="p">(</span><span class="n">link</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">ntohl</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER Pub/Sub support</span>
<span class="cm"> *</span>
<span class="cm"> * For now we do very little, just propagating PUBLISH messages across the whole</span>
<span class="cm"> * cluster. In the future we&#39;ll try to get smarter and avoiding propagating those</span>
<span class="cm"> * messages to hosts without receives for a given channel.</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>
<span class="c1">// 向整个集群的 channel 频道中广播消息 messages</span>
<span class="kt">void</span> <span class="nf">clusterPropagatePublish</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clusterSendPublish</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * SLAVE node specific functions</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* This function sends a FAILOVE_AUTH_REQUEST message to every node in order to</span>
<span class="cm"> * see if there is the quorum for this slave instance to failover its failing</span>
<span class="cm"> * master.</span>
<span class="cm"> *</span>
<span class="cm"> * 向其他所有节点发送 FAILOVE_AUTH_REQUEST 信息，</span>
<span class="cm"> * 看它们是否同意由这个从节点来对下线的主节点进行故障转移。</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we send the failover request to everybody, master and slave nodes,</span>
<span class="cm"> * but only the masters are supposed to reply to our query. </span>
<span class="cm"> *</span>
<span class="cm"> * 信息会被发送给所有节点，包括主节点和从节点，但只有主节点会回复这条信息。 </span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterRequestFailoverAuth</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)];</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">totlen</span><span class="p">;</span>

    <span class="c1">// 设置信息头（包含当前节点的信息）</span>
    <span class="n">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</span><span class="p">);</span>
    <span class="n">totlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">totlen</span><span class="p">);</span>

    <span class="c1">// 发送信息</span>
    <span class="n">clusterBroadcastMessage</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">totlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a FAILOVER_AUTH_ACK message to the specified node. */</span>
<span class="c1">// 向节点 node 投票，支持它进行故障迁移</span>
<span class="kt">void</span> <span class="nf">clusterSendFailoverAuth</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)];</span>
    <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">clusterMsg</span><span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">totlen</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">clusterBuildMessageHdr</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</span><span class="p">);</span>
    <span class="n">totlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clusterMsg</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">clusterMsgData</span><span class="p">);</span>
    <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">totlen</span><span class="p">);</span>
    <span class="n">clusterSendMessage</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">totlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Vote for the node asking for our vote if there are the conditions. */</span>
<span class="c1">// 在条件满足的情况下，为请求进行故障转移的节点 node 进行投票，支持它进行故障转移</span>
<span class="kt">void</span> <span class="nf">clusterSendFailoverAuthIfNeeded</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">clusterMsg</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 请求节点的主节点</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">;</span>

    <span class="c1">// 请求节点的当前配置纪元</span>
    <span class="kt">uint64_t</span> <span class="n">requestCurrentEpoch</span> <span class="o">=</span> <span class="n">ntohu64</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">);</span>

    <span class="c1">// 请求节点想要获得投票的纪元</span>
    <span class="kt">uint64_t</span> <span class="n">requestConfigEpoch</span> <span class="o">=</span> <span class="n">ntohu64</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">);</span>

    <span class="c1">// 请求节点的槽布局</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">claimed_slots</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">myslots</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="cm">/* IF we are not a master serving at least 1 slot, we don&#39;t have the</span>
<span class="cm">     * right to vote, as the cluster size in Redis Cluster is the number</span>
<span class="cm">     * of masters serving at least one slot, and quorum is the cluster</span>
<span class="cm">     * size + 1 */</span>
    <span class="c1">// 非主节点无权投票</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 没有处理任何槽的节点无权投票</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Request epoch must be &gt;= our currentEpoch. */</span>
    <span class="c1">// 请求的配置纪元必须大于等于当前节点的配置纪元</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">requestCurrentEpoch</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* I already voted for this epoch? Return ASAP. */</span>
    <span class="c1">// 已经投过票了</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">last_vote_epoch</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Node must be a slave and its master down. */</span>
    <span class="c1">// 请求节点必须是从服务器，并且它的主节点必须已经 FAIL</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">master</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
        <span class="o">!</span><span class="p">(</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* We did not voted for a slave about this master for two</span>
<span class="cm">     * times the node timeout. This is not strictly needed for correctness</span>
<span class="cm">     * of the algorithm but makes the base case more linear. */</span>
    <span class="c1">// 如果之前一段时间已经对请求节点进行过投票，那么不进行投票</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mstime</span><span class="p">()</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">voted_time</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* The slave requesting the vote must have a configEpoch for the claimed</span>
<span class="cm">     * slots that is &gt;= the one of the masters currently serving the same</span>
<span class="cm">     * slots in the current configuration. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 跳过未指派节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">claimed_slots</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 查找是否有某个槽的配置纪元大于节点请求的纪元</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">&lt;=</span> <span class="n">requestConfigEpoch</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 如果有的话，说明节点请求的纪元已经过期，没有必要进行投票</span>
        <span class="cm">/* If we reached this point we found a slot that in our current slots</span>
<span class="cm">         * is served by a master with a greater configEpoch than the one claimed</span>
<span class="cm">         * by the slave requesting our vote. Refuse to vote for this slave. */</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* We can vote for this slave. */</span>
    <span class="c1">// 为节点投票</span>
    <span class="n">clusterSendFailoverAuth</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

    <span class="c1">// 更新时间值</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">last_vote_epoch</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">voted_time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* This function is called if we are a slave node and our master serving</span>
<span class="cm"> * a non-zero amount of hash slots is in FAIL state.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果当前节点是一个从节点，并且它正在复制的一个负责非零个槽的主节点处于 FAIL 状态，</span>
<span class="cm"> * 那么执行这个函数。</span>
<span class="cm"> *</span>
<span class="cm"> * The gaol of this function is:</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数有三个目标：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) To check if we are able to perform a failover, is our data updated?</span>
<span class="cm"> *    检查是否可以对主节点执行一次故障转移，节点的关于主节点的信息是否准确和最新（updated）？</span>
<span class="cm"> * 2) Try to get elected by masters.</span>
<span class="cm"> *    选举一个新的主节点</span>
<span class="cm"> * 3) Perform the failover informing all the other nodes.</span>
<span class="cm"> *    执行故障转移，并通知其他节点</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterHandleSlaveFailover</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">mstime_t</span> <span class="n">data_age</span><span class="p">;</span>
    <span class="kt">mstime_t</span> <span class="n">auth_age</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">()</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_time</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">needed_quorum</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="cm">/* Set data_age to the number of seconds we are disconnected from</span>
<span class="cm">     * the master. */</span>
    <span class="c1">// 将 data_age 设置为从节点与主节点的断开秒数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data_age</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">lastinteraction</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">data_age</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_down_since</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Pre conditions to run the function:</span>
<span class="cm">     * 执行函数的条件：</span>
<span class="cm">     * 1) We are a slave.</span>
<span class="cm">     *    当前节点是从节点</span>
<span class="cm">     * 2) Our master is flagged as FAIL.</span>
<span class="cm">     *    这个从节点的主节点状态为 FAIL</span>
<span class="cm">     * 3) It is serving slots. </span>
<span class="cm">     *    FAIL 的主节点正在处理某个（或某些）槽</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
        <span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Remove the node timeout from the data age as it is fine that we are</span>
<span class="cm">     * disconnected from our master at least for the time it was down to be</span>
<span class="cm">     * flagged as FAIL, that&#39;s the baseline. */</span>
    <span class="c1">// node timeout 的时间不计入断线时间之内</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data_age</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="p">)</span>
        <span class="n">data_age</span> <span class="o">-=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="p">;</span>

    <span class="cm">/* Check if our data is recent enough. For now we just use a fixed</span>
<span class="cm">     * constant of ten times the node timeout since the cluster should</span>
<span class="cm">     * react much faster to a master down. */</span>
    <span class="c1">// 检查这个从节点的数据是否较新：</span>
    <span class="c1">// 目前的检测办法是断线时间不能超过 node timeout 的十倍</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data_age</span> <span class="o">&gt;</span>
        <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_ping_slave_period</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span>
        <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span> <span class="o">*</span> <span class="n">REDIS_CLUSTER_SLAVE_VALIDITY_MULT</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Compute the time at which we can start an election. */</span>
    <span class="c1">// 在开始故障转移之前，先等待一段时间</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">auth_age</span> <span class="o">&gt;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span> <span class="o">*</span> <span class="n">REDIS_CLUSTER_FAILOVER_AUTH_RETRY_MULT</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">()</span> <span class="o">+</span>
            <span class="mi">500</span> <span class="o">+</span> <span class="cm">/* Fixed delay of 500 milliseconds, let FAIL msg propagate. */</span>
            <span class="n">data_age</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">+</span> <span class="cm">/* Add 100 milliseconds for every second of age. */</span>
            <span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">500</span><span class="p">;</span> <span class="cm">/* Random delay between 0 and 500 milliseconds. */</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
            <span class="s">&quot;Start of election delayed for %lld milliseconds.&quot;</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_time</span> <span class="o">-</span> <span class="n">mstime</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Return ASAP if we can&#39;t still start the election. */</span>
    <span class="c1">// 如果执行故障转移的时间未到，先返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mstime</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_time</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Return ASAP if the election is too old to be valid. */</span>
    <span class="c1">// 如果距离应该执行故障转移的时间已经过了很久</span>
    <span class="c1">// 那么不应该再执行故障转移了（因为可能已经没有需要了）</span>
    <span class="c1">// 直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">auth_age</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Ask for votes if needed. */</span>
    <span class="c1">// 向其他节点发送故障转移请求</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 增加配置纪元</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="o">++</span><span class="p">;</span>

        <span class="c1">// 记录发起故障转移的配置纪元</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_epoch</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">;</span>

        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Starting a failover election for epoch %llu.&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">);</span>

        <span class="c1">// 向其他所有节点发送信息，看它们是否支持由本节点来对失效主节点进行故障转移</span>
        <span class="n">clusterRequestFailoverAuth</span><span class="p">();</span>

        <span class="c1">// 打开标识，表示已发送信息</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_sent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// TODO:</span>
        <span class="c1">// 在进入下个事件循环之前，执行：</span>
        <span class="c1">// 1）保存配置文件</span>
        <span class="c1">// 2）更新节点状态</span>
        <span class="c1">// 3）同步配置</span>
        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="o">|</span>
                             <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span>
                             <span class="n">CLUSTER_TODO_FSYNC_CONFIG</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span> <span class="cm">/* Wait for replies. */</span>
    <span class="p">}</span>

    <span class="cm">/* Check if we reached the quorum. */</span>
    <span class="c1">// 如果当前节点获得了足够多的投票，那么对失效主节点进行故障转移</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_count</span> <span class="o">&gt;=</span> <span class="n">needed_quorum</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 旧主节点</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">oldmaster</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">;</span>

        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
            <span class="s">&quot;Failover election won: I&#39;m the new master.&quot;</span><span class="p">);</span>

        <span class="cm">/* We have the quorum, perform all the steps to correctly promote</span>
<span class="cm">         * this slave to a master.</span>
<span class="cm">         *</span>
<span class="cm">         * 1) Turn this node into a master. </span>
<span class="cm">         *    将当前节点的身份由从节点改为主节点</span>
<span class="cm">         */</span>
        <span class="c1">// 在 slaves 字典中移除当前节点</span>
        <span class="n">clusterNodeRemoveSlave</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">,</span>
                               <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">);</span>
        <span class="c1">// 关闭从节点标记</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_SLAVE</span><span class="p">;</span>
        <span class="c1">// 打开主节点标记</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">;</span>
        <span class="c1">// 清空 slaveof 对象</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 让从节点取消复制，成为新的主节点</span>
        <span class="n">replicationUnsetMaster</span><span class="p">();</span>

        <span class="cm">/* 2) Claim all the slots assigned to our master. */</span>
        <span class="c1">// 接收所有主节点负责处理的槽</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">oldmaster</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 将槽设置为未分配的</span>
                <span class="n">clusterDelSlot</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                <span class="c1">// 将槽的负责人设置为当前节点</span>
                <span class="n">clusterAddSlot</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* 3) Update my configEpoch to the epoch of the election. */</span>
        <span class="c1">// 更新集群配置纪元</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">configEpoch</span> <span class="o">=</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">failover_auth_epoch</span><span class="p">;</span>

        <span class="cm">/* 4) Update state and save config. */</span>
        <span class="c1">// 更新节点状态</span>
        <span class="n">clusterUpdateState</span><span class="p">();</span>
        <span class="c1">// 并保存配置文件</span>
        <span class="n">clusterSaveConfigOrDie</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="cm">/* 5) Pong all the other nodes so that they can update the state</span>
<span class="cm">         *    accordingly and detect that we switched to master role. */</span>
        <span class="c1">// 向所有节点发送 PONG 信息</span>
        <span class="c1">// 让它们可以知道当前节点已经升级为主节点了</span>
        <span class="n">clusterBroadcastPong</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER cron job</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* This is executed 10 times every second */</span>
<span class="c1">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span>
<span class="kt">void</span> <span class="nf">clusterCron</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">update_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">mstime_t</span> <span class="n">min_pong</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">now</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">min_pong_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// 迭代计数器，一个静态变量</span>
    <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">mstime_t</span> <span class="n">handshake_timeout</span><span class="p">;</span>

    <span class="c1">// 记录一次迭代</span>
    <span class="n">iteration</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Number of times this function was called so far. */</span>

    <span class="cm">/* The handshake timeout is the time after which a handshake node that was</span>
<span class="cm">     * not turned into a normal node is removed from the nodes. Usually it is</span>
<span class="cm">     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use</span>
<span class="cm">     * the value of 1 second. */</span>
    <span class="c1">// 如果一个 handshake 节点没有在 handshake timeout 内</span>
    <span class="c1">// 转换成普通节点（normal node），</span>
    <span class="c1">// 那么节点会从 nodes 表中移除这个 handshake 节点</span>
    <span class="c1">// 一般来说 handshake timeout 的值总是等于 NODE_TIMEOUT</span>
    <span class="c1">// 不过如果 NODE_TIMEOUT 太少的话，程序会将值设为 1 秒钟</span>
    <span class="n">handshake_timeout</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">handshake_timeout</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="n">handshake_timeout</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

    <span class="cm">/* Check if we have disconnected nodes and re-establish the connection. */</span>
    <span class="c1">// 与断线（或者未创建连接）的节点发送信息</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 跳过自身以及没有地址的节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_MYSELF</span><span class="o">|</span><span class="n">REDIS_NODE_NOADDR</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* A Node in HANDSHAKE state has a limited lifespan equal to the</span>
<span class="cm">         * configured node timeout. */</span>
        <span class="c1">// 如果 handshake 节点已超时，释放它</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span> <span class="o">&amp;&amp;</span>
            <span class="n">now</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">&gt;</span> <span class="n">handshake_timeout</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">freeClusterNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 为未创建连接的节点创建连接</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
            <span class="kt">mstime_t</span> <span class="n">old_ping_sent</span><span class="p">;</span>
            <span class="n">clusterLink</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

            <span class="c1">// 创建连接</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">anetTcpNonBlockConnect</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">+</span><span class="n">REDIS_CLUSTER_PORT_INCR</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">link</span> <span class="o">=</span> <span class="n">createClusterLink</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">link</span><span class="p">;</span>
            <span class="c1">// 关联读事件处理器</span>
            <span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">,</span><span class="n">clusterReadHandler</span><span class="p">,</span><span class="n">link</span><span class="p">);</span>
            <span class="cm">/* Queue a PING in the new connection ASAP: this is crucial</span>
<span class="cm">             * to avoid false positives in failure detection.</span>
<span class="cm">             *</span>
<span class="cm">             * If the node is flagged as MEET, we send a MEET message instead</span>
<span class="cm">             * of a PING one, to force the receiver to add us in its node</span>
<span class="cm">             * table. */</span>
            <span class="c1">// 向新连接的节点发送 PING 命令，防止节点被识进入失效</span>
            <span class="c1">// 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令</span>
            <span class="n">old_ping_sent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span><span class="p">;</span>
            <span class="n">clusterSendPing</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MEET</span> <span class="o">?</span>
                    <span class="nl">CLUSTERMSG_TYPE_MEET</span> <span class="p">:</span> <span class="n">CLUSTERMSG_TYPE_PING</span><span class="p">);</span>

            <span class="c1">// 这不是第一次发送 PING 信息，所以可以还原这个时间</span>
            <span class="c1">// 等 clusterSendPing() 函数来更新它</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_ping_sent</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* If there was an active ping before the link was</span>
<span class="cm">                 * disconnected, we want to restore the ping time, otherwise</span>
<span class="cm">                 * replaced by the clusterSendPing() call. */</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">=</span> <span class="n">old_ping_sent</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* We can clear the flag after the first packet is sent.</span>
<span class="cm">             *</span>
<span class="cm">             * 在发送 MEET 信息之后，清除节点的 MEET 标识。</span>
<span class="cm">             *</span>
<span class="cm">             * If we&#39;ll never receive a PONG, we&#39;ll never send new packets</span>
<span class="cm">             * to this node. Instead after the PONG is received and we</span>
<span class="cm">             * are no longer in meet/handshake status, we want to send</span>
<span class="cm">             * normal PING packets. </span>
<span class="cm">             *</span>
<span class="cm">             * 如果当前节点（发送者）没能收到 MEET 信息的回复，</span>
<span class="cm">             * 那么它将不再向目标节点发送命令。</span>
<span class="cm">             *</span>
<span class="cm">             * 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，</span>
<span class="cm">             * 并继续向目标节点发送普通 PING 命令。</span>
<span class="cm">             */</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_MEET</span><span class="p">;</span>

            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;Connecting with Node %.40s at %s:%d&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">+</span><span class="n">REDIS_CLUSTER_PORT_INCR</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

    <span class="cm">/* Ping some random node 1 time every 10 iterations, so that we usually ping</span>
<span class="cm">     * one random node every second. */</span>
    <span class="c1">// clusterCron() 每执行 10 次（至少间隔一秒钟），就向一个随机节点发送 gossip 信息</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Check a few random nodes and ping the one with the oldest</span>
<span class="cm">         * pong_received time. */</span>
        <span class="c1">// 随机 5 个节点，选出其中一个</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 随机在集群中挑选节点</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">dictGetRandomKey</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
            <span class="n">clusterNode</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

            <span class="cm">/* Don&#39;t ping nodes disconnected or with a ping currently active. */</span>
            <span class="c1">// 不要 PING 连接断开的节点，也不要 PING 最近已经 PING 过的节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_MYSELF</span><span class="o">|</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// 选出 5 个随机节点中最近一次接收 PONG 回复距离现在最旧的节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">min_pong_node</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">min_pong</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pong_received</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">min_pong_node</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
                <span class="n">min_pong</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pong_received</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 向最久没有收到 PONG 回复的节点发送 PING 命令</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_pong_node</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;Pinging node %.40s&quot;</span><span class="p">,</span> <span class="n">min_pong_node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
            <span class="n">clusterSendPing</span><span class="p">(</span><span class="n">min_pong_node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">CLUSTERMSG_TYPE_PING</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Iterate nodes to check if we need to flag something as failing */</span>
    <span class="c1">// 遍历所有节点，检查是否需要将某个节点标记为下线</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span> <span class="cm">/* Use an updated time at every iteration. */</span>
        <span class="kt">mstime_t</span> <span class="n">delay</span><span class="p">;</span>

        <span class="c1">// 跳过节点本身、无地址节点、HANDSHAKE 状态的节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">REDIS_NODE_MYSELF</span><span class="o">|</span><span class="n">REDIS_NODE_NOADDR</span><span class="o">|</span><span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">))</span>
                <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* If we are waiting for the PONG more than half the cluster</span>
<span class="cm">         * timeout, reconnect the link: maybe there is a connection</span>
<span class="cm">         * issue even if the node is alive. */</span>
        <span class="c1">// 如果等到 PONG 到达的时间超过了 node timeout 一半的连接</span>
        <span class="c1">// 因为尽管节点依然正常，但连接可能已经出问题了</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">&amp;&amp;</span> <span class="cm">/* is connected */</span>
            <span class="n">now</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">&gt;</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span> <span class="o">&amp;&amp;</span> <span class="cm">/* was not already reconnected */</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">&amp;&amp;</span> <span class="cm">/* we already sent a ping */</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">pong_received</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">&amp;&amp;</span> <span class="cm">/* still waiting pong */</span>
            <span class="cm">/* and we are waiting for the pong more than timeout/2 */</span>
            <span class="n">now</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Disconnect the link, it will be reconnected automatically. */</span>
            <span class="c1">// 释放连接，下次 clusterCron() 会自动重连</span>
            <span class="n">freeClusterLink</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* If we have currently no active ping in this instance, and the</span>
<span class="cm">         * received PONG is older than half the cluster timeout, send</span>
<span class="cm">         * a new ping now, to ensure all the nodes are pinged without</span>
<span class="cm">         * a too big delay. */</span>
        <span class="c1">// 如果目前没有在 PING 节点</span>
        <span class="c1">// 并且已经有 node timeout 一半的时间没有从节点那里收到 PONG 回复</span>
        <span class="c1">// 那么向节点发送一个 PING ，确保节点的信息不会太旧</span>
        <span class="c1">// （因为一部分节点可能一直没有被随机中）</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">&amp;&amp;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">pong_received</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">clusterSendPing</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">CLUSTERMSG_TYPE_PING</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Check only if we have an active ping for this instance. */</span>
        <span class="c1">// 以下代码只在节点发送了 PING 命令的情况下执行</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* Compute the delay of the PONG. Note that if we already received</span>
<span class="cm">         * the PONG, then node-&gt;ping_sent is zero, so can&#39;t reach this</span>
<span class="cm">         * code at all. */</span>
        <span class="c1">// 计算等待 PONG 回复的时长</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span><span class="p">;</span>

        <span class="c1">// 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线）</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Timeout reached. Set the node as possibly failing if it is</span>
<span class="cm">             * not already in this state. */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_PFAIL</span><span class="o">|</span><span class="n">REDIS_NODE_FAIL</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span><span class="s">&quot;*** NODE %.40s possibly failing&quot;</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="c1">// 打开疑似下线标记</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">;</span>
                <span class="n">update_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

    <span class="cm">/* If we are a slave node but the replication is still turned off,</span>
<span class="cm">     * enable it if we know the address of our master and it appears to</span>
<span class="cm">     * be up. */</span>
    <span class="c1">// 如果从节点没有在复制主节点，那么对从节点进行设置</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span> <span class="o">&amp;&amp;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_NOADDR</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">replicationSetMaster</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span>
                             <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果条件满足的话，执行故障转移</span>
    <span class="n">clusterHandleSlaveFailover</span><span class="p">();</span>

    <span class="c1">// 更新节点状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">update_state</span><span class="p">)</span> <span class="n">clusterUpdateState</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* This function is called before the event handler returns to sleep for</span>
<span class="cm"> * events. It is useful to perform operations that must be done ASAP in</span>
<span class="cm"> * reaction to events fired but that are not safe to perform inside event</span>
<span class="cm"> * handlers, or to perform potentially expansive tasks that we need to do</span>
<span class="cm"> * a single time before replying to clients. </span>
<span class="cm"> *</span>
<span class="cm"> * 在进入下个事件循环时调用。</span>
<span class="cm"> * 这个函数做的事都是需要尽快执行，但是不能在执行文件事件期间做的事情。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clusterBeforeSleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* Handle failover, this is needed when it is likely that there is already</span>
<span class="cm">     * the quorum from masters in order to react fast. */</span>
    <span class="c1">// 执行故障迁移</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">&amp;</span> <span class="n">CLUSTER_TODO_HANDLE_FAILOVER</span><span class="p">)</span>
        <span class="n">clusterHandleSlaveFailover</span><span class="p">();</span>

    <span class="cm">/* Update the cluster state. */</span>
    <span class="c1">// 更新节点的状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">&amp;</span> <span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="p">)</span>
        <span class="n">clusterUpdateState</span><span class="p">();</span>

    <span class="cm">/* Save the config, possibly using fsync. */</span>
    <span class="c1">// 保存 nodes.conf 配置文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">&amp;</span> <span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fsync</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">&amp;</span> <span class="n">CLUSTER_TODO_FSYNC_CONFIG</span><span class="p">;</span>
        <span class="n">clusterSaveConfigOrDie</span><span class="p">(</span><span class="n">fsync</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Reset our flags. */</span>
    <span class="c1">// 重置 flag</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 打开 todo_before_sleep 的指定标识</span>
<span class="c1">// 每个标识代表了节点在结束一个事件循环时要做的工作</span>
<span class="kt">void</span> <span class="nf">clusterDoBeforeSleep</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">todo_before_sleep</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * Slots management</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* Test bit &#39;pos&#39; in a generic bitmap. Return 1 if the bit is set,</span>
<span class="cm"> * otherwise 0. */</span>
<span class="c1">// 检查位图 bitmap 的 pos 位置是否已经被设置</span>
<span class="c1">// 返回 1 表示已被设置，返回 0 表示未被设置。</span>
<span class="kt">int</span> <span class="nf">bitmapTestBit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">off_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">pos</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">byte</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bit</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set the bit at position &#39;pos&#39; in a bitmap. */</span>
<span class="c1">// 设置位图 bitmap 在 pos 位置的值</span>
<span class="kt">void</span> <span class="nf">bitmapSetBit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">off_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">pos</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">bitmap</span><span class="p">[</span><span class="n">byte</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clear the bit at position &#39;pos&#39; in a bitmap. */</span>
<span class="c1">// 清除位图 bitmap 在 pos 位置的值</span>
<span class="kt">void</span> <span class="nf">bitmapClearBit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">off_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">pos</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">bitmap</span><span class="p">[</span><span class="n">byte</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set the slot bit and return the old value. */</span>
<span class="c1">// 为槽二进制位设置新值，并返回旧值</span>
<span class="kt">int</span> <span class="nf">clusterNodeSetSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
    <span class="n">bitmapSetBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">)</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">numslots</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clear the slot bit and return the old value. */</span>
<span class="c1">// 清空槽二进制位，并返回旧值</span>
<span class="kt">int</span> <span class="nf">clusterNodeClearSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
    <span class="n">bitmapClearBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">numslots</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the slot bit from the cluster node structure. */</span>
<span class="c1">// 返回槽的二进制位的值</span>
<span class="kt">int</span> <span class="nf">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add the specified slot to the list of slots that node &#39;n&#39; will</span>
<span class="cm"> * serve. Return REDIS_OK if the operation ended with success.</span>
<span class="cm"> * If the slot is already assigned to another instance this is considered</span>
<span class="cm"> * an error and REDIS_ERR is returned. */</span>
<span class="c1">// 将槽 slot 添加到节点 n 需要处理的槽的列表中</span>
<span class="c1">// 添加成功返回 REDIS_OK ,如果槽已经由这个节点处理了</span>
<span class="c1">// 那么返回 REDIS_ERR 。</span>
<span class="kt">int</span> <span class="nf">clusterAddSlot</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 槽 slot 已经是节点 n 处理的了</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="c1">// 设置 bitmap</span>
    <span class="n">clusterNodeSetSlotBit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>

    <span class="c1">// 更新集群状态</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delete the specified slot marking it as unassigned.</span>
<span class="cm"> *</span>
<span class="cm"> * 将指定槽标记为未分配（unassigned）。</span>
<span class="cm"> *</span>
<span class="cm"> * Returns REDIS_OK if the slot was assigned, otherwise if the slot was</span>
<span class="cm"> * already unassigned REDIS_ERR is returned. </span>
<span class="cm"> *</span>
<span class="cm"> * 标记成功返回 REDIS_OK ，</span>
<span class="cm"> * 如果槽已经是未分配的，那么返回 REDIS_ERR 。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clusterDelSlot</span><span class="p">(</span><span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 获取当前处理槽 slot 的节点 n</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="c1">// 清除位图</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">clusterNodeClearSlotBit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">slot</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 清空负责处理槽的节点</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delete all the slots associated with the specified node.</span>
<span class="cm"> * The number of deleted slots is returned. */</span>
<span class="c1">// 删除所有由给定节点处理的槽，并返回被删除槽的数量</span>
<span class="kt">int</span> <span class="nf">clusterDelNodeSlots</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">deleted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果这个槽由该节点负责，那么删除它</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="n">clusterDelSlot</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
        <span class="n">deleted</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">deleted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * Cluster state evaluation function</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cp">#define REDIS_CLUSTER_MAX_REJOIN_DELAY 5000</span>

<span class="c1">// 更新节点状态</span>
<span class="kt">void</span> <span class="nf">clusterUpdateState</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">new_state</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">unreachable_masters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">mstime_t</span> <span class="n">among_minority_time</span><span class="p">;</span>

    <span class="cm">/* Start assuming the state is OK. We&#39;ll turn it into FAIL if there</span>
<span class="cm">     * are the right conditions. */</span>

    <span class="c1">// 先假设节点状态为 OK ，后面再检测节点是否真的下线</span>
    <span class="n">new_state</span> <span class="o">=</span> <span class="n">REDIS_CLUSTER_OK</span><span class="p">;</span>

    <span class="cm">/* Check if all the slots are covered. */</span>
    <span class="c1">// 检查是否所有槽都已经有某个节点在处理</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_FAIL</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="n">REDIS_CLUSTER_FAIL</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Compute the cluster size, that is the number of master nodes</span>
<span class="cm">     * serving at least a single slot.</span>
<span class="cm">     *</span>
<span class="cm">     * At the same time count the number of unreachable masters with</span>
<span class="cm">     * at least one node. */</span>
    <span class="c1">// 统计在线并且正在处理至少一个槽的 master 的数量，</span>
    <span class="c1">// 以及下线 master 的数量</span>
    <span class="p">{</span>
        <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
        <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
        <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslots</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">REDIS_NODE_FAIL</span><span class="o">|</span><span class="n">REDIS_NODE_PFAIL</span><span class="p">))</span>
                    <span class="n">unreachable_masters</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* If we can&#39;t reach at least half the masters, change the cluster state</span>
<span class="cm">     * to FAIL, as we are not even able to mark nodes as FAIL in this side</span>
<span class="cm">     * of the netsplit because of lack of majority.</span>
<span class="cm">     *</span>
<span class="cm">     * 如果不能连接到半数以上节点，那么将我们自己的状态设置为 FAIL</span>
<span class="cm">     * 因为在少于半数节点的情况下，节点是无法将一个节点判断为 FAIL 的。</span>
<span class="cm">     */</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">needed_quorum</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">unreachable_masters</span> <span class="o">&gt;=</span> <span class="n">needed_quorum</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="n">REDIS_CLUSTER_FAIL</span><span class="p">;</span>
            <span class="n">among_minority_time</span> <span class="o">=</span> <span class="n">mstime</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Log a state change */</span>
    <span class="c1">// 记录状态变更</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">mstime_t</span> <span class="n">rejoin_delay</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster_node_timeout</span><span class="p">;</span>

        <span class="cm">/* If the instance is a master and was partitioned away with the</span>
<span class="cm">         * minority, don&#39;t let it accept queries for some time after the</span>
<span class="cm">         * partition heals, to make sure there is enough time to receive</span>
<span class="cm">         * a configuration update. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rejoin_delay</span> <span class="o">&gt;</span> <span class="n">REDIS_CLUSTER_MAX_REJOIN_DELAY</span><span class="p">)</span>
            <span class="n">rejoin_delay</span> <span class="o">=</span> <span class="n">REDIS_CLUSTER_MAX_REJOIN_DELAY</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">==</span> <span class="n">REDIS_CLUSTER_OK</span> <span class="o">&amp;&amp;</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span> <span class="o">&amp;&amp;</span>
            <span class="n">mstime</span><span class="p">()</span> <span class="o">-</span> <span class="n">among_minority_time</span> <span class="o">&lt;</span> <span class="n">rejoin_delay</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Change the state and log the event. */</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Cluster state changed: %s&quot;</span><span class="p">,</span>
            <span class="n">new_state</span> <span class="o">==</span> <span class="n">REDIS_CLUSTER_OK</span> <span class="o">?</span> <span class="s">&quot;ok&quot;</span> <span class="o">:</span> <span class="s">&quot;fail&quot;</span><span class="p">);</span>

        <span class="c1">// 设置新状态</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This function is called after the node startup in order to verify that data</span>
<span class="cm"> * loaded from disk is in agreement with the cluster configuration:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) If we find keys about hash slots we have no responsibility for, the</span>
<span class="cm"> *    following happens:</span>
<span class="cm"> *    A) If no other node is in charge according to the current cluster</span>
<span class="cm"> *       configuration, we add these slots to our node.</span>
<span class="cm"> *    B) If according to our config other nodes are already in charge for</span>
<span class="cm"> *       this lots, we set the slots as IMPORTING from our point of view</span>
<span class="cm"> *       in order to justify we have those slots, and in order to make</span>
<span class="cm"> *       redis-trib aware of the issue, so that it can try to fix it.</span>
<span class="cm"> * 2) If we find data in a DB different than DB0 we return REDIS_ERR to</span>
<span class="cm"> *    signal the caller it should quit the server with an error message</span>
<span class="cm"> *    or take other actions.</span>
<span class="cm"> *</span>
<span class="cm"> * The function always returns REDIS_OK even if it will try to correct</span>
<span class="cm"> * the error described in &quot;1&quot;. However if data is found in DB different</span>
<span class="cm"> * from DB0, REDIS_ERR is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * The function also uses the logging facility in order to warn the user</span>
<span class="cm"> * about desynchronizations between the data we have in memory and the</span>
<span class="cm"> * cluster configuration. */</span>
<span class="c1">// 检查当前节点的节点配置是否正确，包含的数据是否正确</span>
<span class="c1">// 在启动集群时被调用（看 redis.c ）</span>
<span class="kt">int</span> <span class="nf">verifyClusterConfigWithData</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">update_config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* If this node is a slave, don&#39;t perform the check at all as we</span>
<span class="cm">     * completely depend on the replication stream. */</span>
    <span class="c1">// 不对从节点进行检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>

    <span class="cm">/* Make sure we only have keys in DB0. */</span>
    <span class="c1">// 确保只有 0 号数据库有数据</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dict</span><span class="p">))</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check that all the slots we see populated memory have a corresponding</span>
<span class="cm">     * entry in the cluster table. Otherwise fix the table. */</span>
    <span class="c1">// 检查槽表是否都有相应的节点，如果不是的话，进行修复</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">countKeysInSlot</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span> <span class="cm">/* No keys in this slot. */</span>
        <span class="cm">/* Check if we are assigned to this slot or if we are importing it.</span>
<span class="cm">         * In both cases check the next slot as the configuration makes</span>
<span class="cm">         * sense. */</span>
        <span class="c1">// 跳过正在导入的槽</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">||</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* If we are here data and cluster config don&#39;t agree, and we have</span>
<span class="cm">         * slot &#39;j&#39; populated even if we are not importing it, nor we are</span>
<span class="cm">         * assigned to this slot. Fix this condition. */</span>

        <span class="n">update_config</span><span class="o">++</span><span class="p">;</span>
        <span class="cm">/* Case A: slot is unassigned. Take responsability for it. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 处理未被接受的槽</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span> <span class="s">&quot;I&#39;ve keys about slot %d that is &quot;</span>
                                    <span class="s">&quot;unassigned. Taking responsability &quot;</span>
                                    <span class="s">&quot;for it.&quot;</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
            <span class="n">clusterAddSlot</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 如果一个槽已经被其他节点接管</span>
            <span class="c1">// 那么将槽中的资料发送给对方</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span> <span class="s">&quot;I&#39;ve keys about slot %d that is &quot;</span>
                                    <span class="s">&quot;already assigned to a different node. &quot;</span>
                                    <span class="s">&quot;Setting it in importing state.&quot;</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 保存 nodes.conf 文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">update_config</span><span class="p">)</span> <span class="n">clusterSaveConfigOrDie</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * SLAVE nodes handling</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* Set the specified node &#39;n&#39; as master. Setup the node as a slave if</span>
<span class="cm"> * needed. */</span>
<span class="c1">// 将节点 n 设置为当前节点的主节点</span>
<span class="kt">void</span> <span class="nf">clusterSetMaster</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 指向当前节点</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">myself</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">;</span>

    <span class="n">redisAssert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">myself</span><span class="p">);</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// 设置当前节点的标识值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_NODE_MASTER</span><span class="p">;</span>
        <span class="n">myself</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 将 slaveof 属性指向主节点</span>
    <span class="n">myself</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// 设置主节点的 IP 和地址，开始对它进行复制</span>
    <span class="n">replicationSetMaster</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * CLUSTER command</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* Generate a csv-alike representation of the nodes we are aware of,</span>
<span class="cm"> * including the &quot;myself&quot; node, and return an SDS string containing the</span>
<span class="cm"> * representation (it is up to the caller to free it).</span>
<span class="cm"> *</span>
<span class="cm"> * 以 csv 格式记录当前节点已知所有节点的信息（包括当前节点自身），</span>
<span class="cm"> * 这些信息被保存到一个 sds 里面，并作为函数值返回。</span>
<span class="cm"> *</span>
<span class="cm"> * All the nodes matching at least one of the node flags specified in</span>
<span class="cm"> * &quot;filter&quot; are excluded from the output, so using zero as a filter will</span>
<span class="cm"> * include all the known nodes in the representation, including nodes in</span>
<span class="cm"> * the HANDSHAKE state.</span>
<span class="cm"> *</span>
<span class="cm"> * filter 参数可以用来指定节点的 flag 标识，</span>
<span class="cm"> * 带有被指定标识的节点不会被记录在输出结构中，</span>
<span class="cm"> * filter 为 0 表示记录所有节点的信息，包括 HANDSHAKE 状态的节点。</span>
<span class="cm"> *</span>
<span class="cm"> * The representation obtained using this function is used for the output</span>
<span class="cm"> * of the CLUSTER NODES function, and as format for the cluster</span>
<span class="cm"> * configuration file (nodes.conf) for a given node. </span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数生成的结果会被用于 CLUSTER NODES 命令，</span>
<span class="cm"> * 以及用于生成 nodes.conf 配置文件。</span>
<span class="cm"> */</span>
<span class="n">sds</span> <span class="nf">clusterGenNodesDescription</span><span class="p">(</span><span class="kt">int</span> <span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

    <span class="c1">// 遍历集群中的所有节点</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 不打印包含指定 flag 的节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">filter</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* Node coordinates */</span>
        <span class="c1">// 节点的名字、IP 和端口号</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;%.40s %s:%d &quot;</span><span class="p">,</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

        <span class="cm">/* Flags */</span>
        <span class="c1">// 打印节点的 flag</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;noflags,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MYSELF</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;myself,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MASTER</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;master,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_SLAVE</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;slave,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;fail?,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;fail,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_HANDSHAKE</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span><span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;handshake,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_NOADDR</span><span class="p">)</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;noaddr,&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="p">[</span><span class="n">sdslen</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="n">ci</span><span class="p">[</span><span class="n">sdslen</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

        <span class="cm">/* Slave of... or just &quot;-&quot; */</span>
        <span class="c1">// 是否从节点？如果是的话输出主节点的名字，否则输出 &quot;- &quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="p">)</span>
            <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;%.40s &quot;</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slaveof</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;- &quot;</span><span class="p">);</span>

        <span class="cm">/* Latency from the POV of this node, link status */</span>
        <span class="c1">// 当前节点和该节点的延迟值，以及连接状态</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;%lld %lld %llu %s&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ping_sent</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">pong_received</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">configEpoch</span><span class="p">,</span>
            <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MYSELF</span><span class="p">)</span> <span class="o">?</span>
                        <span class="s">&quot;connected&quot;</span> <span class="o">:</span> <span class="s">&quot;disconnected&quot;</span><span class="p">);</span>

        <span class="cm">/* Slots served by this instance */</span>
        <span class="c1">// 该节点负责处理的槽</span>
        <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">bit</span> <span class="o">=</span> <span class="n">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">bit</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot; %d&quot;</span><span class="p">,</span><span class="n">start</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot; %d-%d&quot;</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Just for MYSELF node we also dump info about slots that</span>
<span class="cm">         * we are migrating to other instances or importing from other</span>
<span class="cm">         * instances. */</span>
        <span class="c1">// 如果被输出的是当前节点的信息，那么将当前节点正在进行迁移或者导入的槽也输出</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_MYSELF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot; [%d-&gt;-%.40s]&quot;</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>
                        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot; [%d-&lt;-%.40s]&quot;</span><span class="p">,</span><span class="n">j</span><span class="p">,</span>
                        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ci</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 取出一个 slot 数值</span>
<span class="kt">int</span> <span class="nf">getSlotOrReply</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">slot</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">getLongLongFromObject</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="o">&amp;</span><span class="n">slot</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span> <span class="o">||</span>
        <span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&gt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid or out of range slot&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// CLUSTER 命令的实现</span>
<span class="kt">void</span> <span class="nf">clusterCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 不能在非集群模式下使用该命令</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;This instance has cluster support disabled&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;meet&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER MEET &lt;ip&gt; &lt;port&gt; */</span>
        <span class="c1">// 将给定地址的节点添加到集群里面</span>
        <span class="kt">long</span> <span class="n">port</span><span class="p">;</span>

        <span class="c1">// 检查 port 参数的合法性</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid TCP port specified&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">clusterStartHandshake</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="n">errno</span> <span class="o">==</span> <span class="n">EINVAL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid node address specified&quot;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;nodes&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER NODES */</span>
        <span class="c1">// 列出集群所有节点的信息</span>
        <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
        <span class="n">sds</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">clusterGenNodesDescription</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="n">o</span> <span class="o">=</span> <span class="n">createObject</span><span class="p">(</span><span class="n">REDIS_STRING</span><span class="p">,</span><span class="n">ci</span><span class="p">);</span>
        <span class="n">addReplyBulk</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">o</span><span class="p">);</span>
        <span class="n">decrRefCount</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;flushslots&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER FLUSHSLOTS */</span>
        <span class="c1">// 删除当前节点的所有槽，让它变为不处理任何槽</span>

        <span class="c1">// 删除槽必须在数据库为空的情况下进行</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dict</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;DB must be empty to perform CLUSTER FLUSHSLOTS.&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 删除所有由该节点处理的槽</span>
        <span class="n">clusterDelNodeSlots</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">);</span>
        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;addslots&quot;</span><span class="p">)</span> <span class="o">||</span>
               <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;delslots&quot;</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* CLUSTER ADDSLOTS &lt;slot&gt; [slot] ... */</span>
        <span class="c1">// 将一个或多个 slot 添加到当前节点</span>

        <span class="cm">/* CLUSTER DELSLOTS &lt;slot&gt; [slot] ... */</span>
        <span class="c1">// 从当前节点中删除一个或多个 slot</span>
    
        <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">slot</span><span class="p">;</span>

        <span class="c1">// 一个数组，记录所有要添加或者删除的槽</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">slots</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">);</span>

        <span class="c1">// 检查这是 delslots 还是 addslots</span>
        <span class="kt">int</span> <span class="n">del</span> <span class="o">=</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;delslots&quot;</span><span class="p">);</span>

        <span class="c1">// 将 slots 数组的所有值设置为 0</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">);</span>

        <span class="cm">/* Check that all the arguments are parsable and that all the</span>
<span class="cm">         * slots are not already busy. */</span>
        <span class="c1">// 处理所有输入 slot 参数</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 获取 slot 数字</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">slot</span> <span class="o">=</span> <span class="n">getSlotOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">zfree</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 如果这是 delslots 命令，并且指定槽为未指定，那么返回一个错误</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">del</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Slot %d is already unassigned&quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
                <span class="n">zfree</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="c1">// 如果这是 addslots 命令，并且槽已经有节点在负责，那么返回一个错误</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Slot %d is already busy&quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
                <span class="n">zfree</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 如果某个槽指定了一次以上，那么返回一个错误</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span><span class="o">++</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Slot %d specified multiple times&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">slot</span><span class="p">);</span>
                <span class="n">zfree</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 处理所有输入 slot</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

                <span class="cm">/* If this slot was set as importing we can clear this </span>
<span class="cm">                 * state as now we are the real owner of the slot. */</span>
                <span class="c1">// 如果指定 slot 之前的状态为载入状态，那么现在可以清除这一状态</span>
                <span class="c1">// 因为当前节点现在已经是 slot 的负责人了</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                <span class="c1">// 添加或者删除指定 slot</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="n">del</span> <span class="o">?</span> <span class="n">clusterDelSlot</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">:</span>
                               <span class="n">clusterAddSlot</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
                <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">retval</span> <span class="o">==</span> <span class="n">REDIS_OK</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;setslot&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* SETSLOT 10 MIGRATING &lt;node ID&gt; */</span>
        <span class="cm">/* SETSLOT 10 IMPORTING &lt;node ID&gt; */</span>
        <span class="cm">/* SETSLOT 10 STABLE */</span>
        <span class="cm">/* SETSLOT 10 NODE &lt;node ID&gt; */</span>
        <span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

        <span class="c1">// 取出 slot 值</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">slot</span> <span class="o">=</span> <span class="n">getSlotOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="c1">// CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;node id&gt;</span>
        <span class="c1">// 将本节点的槽 slot 迁移至 node id 所指定的节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;migrating&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 被迁移的槽必须属于本节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;I&#39;m not the owner of hash slot %u&quot;</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 迁移的目标节点必须是本节点已知的</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;I don&#39;t know about node %s&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 为槽设置迁移目标节点</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="c1">// CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;node id&gt;</span>
        <span class="c1">// 从节点 node id 中导入槽 slot 到本节点</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;importing&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 如果 slot 槽本身已经由本节点处理，那么无须进行导入</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span>
                    <span class="s">&quot;I&#39;m already the owner of hash slot %u&quot;</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// node id 指定的节点必须是本节点已知的，这样才能从目标节点导入槽</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;I don&#39;t know about node %s&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 为槽设置导入目标节点</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;stable&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* CLUSTER SETSLOT &lt;SLOT&gt; STABLE */</span>
            <span class="c1">// 取消对槽 slot 的迁移或者导入</span>

            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;node&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* CLUSTER SETSLOT &lt;SLOT&gt; NODE &lt;NODE ID&gt; */</span>
            <span class="c1">// 将未指派 slot 指派给 node id 指定的节点</span>

            <span class="c1">// 查找目标节点</span>
            <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>

            <span class="c1">// 目标节点必须已存在</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Unknown node %s&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* If this hash slot was served by &#39;myself&#39; before to switch</span>
<span class="cm">             * make sure there are no longer local keys for this hash slot. */</span>
            <span class="c1">// 如果这个槽由当前节点负责处理，那么必须保证槽里面没有键存在</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">&amp;&amp;</span>
                <span class="n">n</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">countKeysInSlot</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;Can&#39;t assign hashslot %d to a different node while I still hold keys for this hash slot.&quot;</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* If this node was the slot owner and the slot was marked as</span>
<span class="cm">             * migrating, assigning the slot to another node will clear</span>
<span class="cm">             * the migratig status. */</span>
            <span class="c1">// 撤销本节点对 slot 的迁移计划</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">&amp;&amp;</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="cm">/* If this node was importing this slot, assigning the slot to</span>
<span class="cm">             * itself also clears the importing status. */</span>
            <span class="c1">// 撤销本节点对 slot 的导入计划</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">&amp;&amp;</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span>
                <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="c1">// 将槽设置为未指派</span>
            <span class="n">clusterDelSlot</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>

            <span class="c1">// 将槽指派给目标节点</span>
            <span class="n">clusterAddSlot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid CLUSTER SETSLOT action or number of arguments&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;info&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER INFO */</span>
        <span class="c1">// 打印出集群的当前信息</span>

        <span class="kt">char</span> <span class="o">*</span><span class="n">statestr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;ok&quot;</span><span class="p">,</span><span class="s">&quot;fail&quot;</span><span class="p">,</span><span class="s">&quot;needhelp&quot;</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">slots_assigned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slots_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slots_pfail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slots_fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

        <span class="c1">// 统计集群中的已指派节点、已失效节点、疑似失效节点和正常节点的数量</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

            <span class="c1">// 跳过未指派节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// 统计已指派节点的数量</span>
            <span class="n">slots_assigned</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// 统计各个不同状态下的节点的数量</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_FAIL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 已失效节点</span>
                <span class="n">slots_fail</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_NODE_PFAIL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 疑似失效节点</span>
                <span class="n">slots_pfail</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 正常节点</span>
                <span class="n">slots_ok</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 打印信息</span>
        <span class="n">sds</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">sdsempty</span><span class="p">(),</span>
            <span class="s">&quot;cluster_state:%s</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_slots_assigned:%d</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_slots_ok:%d</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_slots_pfail:%d</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_slots_fail:%d</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_known_nodes:%lu</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_size:%d</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_current_epoch:%llu</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_stats_messages_sent:%lld</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="s">&quot;cluster_stats_messages_received:%lld</span><span class="se">\r\n</span><span class="s">&quot;</span>
            <span class="p">,</span> <span class="n">statestr</span><span class="p">[</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">],</span>
            <span class="n">slots_assigned</span><span class="p">,</span>
            <span class="n">slots_ok</span><span class="p">,</span>
            <span class="n">slots_pfail</span><span class="p">,</span>
            <span class="n">slots_fail</span><span class="p">,</span>
            <span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">),</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">currentEpoch</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">stats_bus_messages_sent</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">stats_bus_messages_received</span>
        <span class="p">);</span>
        <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sdscatprintf</span><span class="p">(</span><span class="n">sdsempty</span><span class="p">(),</span><span class="s">&quot;$%lu</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sdslen</span><span class="p">(</span><span class="n">info</span><span class="p">)));</span>
        <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">info</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">crlf</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;saveconfig&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// CLUSTER SAVECONFIG 命令</span>
        <span class="c1">// 将 nodes.conf 文件保存到磁盘里面</span>

        <span class="c1">// 保存</span>
        <span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">clusterSaveConfig</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// 检查错误</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;error saving the cluster node config: %s&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;keyslot&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER KEYSLOT &lt;key&gt; */</span>
        <span class="c1">// 返回 key 应该被 hash 到那个槽上</span>

        <span class="n">sds</span> <span class="n">key</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>

        <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">keyHashSlot</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">key</span><span class="p">)));</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;countkeysinslot&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER COUNTKEYSINSLOT &lt;slot&gt; */</span>
        <span class="c1">// 计算指定 slot 上的键数量</span>

        <span class="kt">long</span> <span class="kt">long</span> <span class="n">slot</span><span class="p">;</span>

        <span class="c1">// 取出 slot 参数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLongLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="o">&amp;</span><span class="n">slot</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">REDIS_CLUSTER_SLOTS</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid slot&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">countKeysInSlot</span><span class="p">(</span><span class="n">slot</span><span class="p">));</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;getkeysinslot&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; */</span>
        <span class="c1">// 打印 count 个属于 slot 槽的键</span>

        <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxkeys</span><span class="p">,</span> <span class="n">slot</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numkeys</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">robj</span> <span class="o">**</span><span class="n">keys</span><span class="p">;</span>

        <span class="c1">// 取出 slot 参数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLongLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="o">&amp;</span><span class="n">slot</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 取出 count 参数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLongLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="o">&amp;</span><span class="n">maxkeys</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 检查参数的合法性</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">REDIS_CLUSTER_SLOTS</span> <span class="o">||</span> <span class="n">maxkeys</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid slot or number of keys&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 分配一个保存键的数组</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">robj</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">maxkeys</span><span class="p">);</span>
        <span class="c1">// 将键记录到 keys 数组</span>
        <span class="n">numkeys</span> <span class="o">=</span> <span class="n">getKeysInSlot</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">maxkeys</span><span class="p">);</span>

        <span class="c1">// 打印获得的键</span>
        <span class="n">addReplyMultiBulkLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">numkeys</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numkeys</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">addReplyBulk</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;forget&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER FORGET &lt;NODE ID&gt; */</span>
        <span class="c1">// 从集群中删除 NODE_ID 指定的节点</span>

        <span class="c1">// 查找 NODE_ID 指定的节点</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>

        <span class="c1">// 该节点不存在于集群中</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Unknown node %s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 从集群中删除该节点</span>
        <span class="n">clusterDelNode</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;replicate&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER REPLICATE &lt;NODE ID&gt; */</span>
        <span class="c1">// 将当前节点设置为 NODE_ID 指定的节点的从节点（复制品）</span>

        <span class="c1">// 根据名字查找节点</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">clusterLookupNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>

        <span class="cm">/* Lookup the specified node in our table. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Unknown node %s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* I can&#39;t replicate myself. */</span>
        <span class="c1">// 指定节点是自己，不能进行复制</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Can&#39;t replicate myself&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Can&#39;t replicate a slave. */</span>
        <span class="c1">// 不能复制一个从节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slaveof</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;I can only replicate a master, not a slave.&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* We should have no assigned slots to accept to replicate some</span>
<span class="cm">         * other node. */</span>
        <span class="c1">// 如果我们将这个节点设置为从节点，那么这个节点负责处理的槽数量必须为 0</span>
        <span class="c1">// 并且数据库必须为空</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
            <span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dict</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;To set a master the node must be empty and without assigned slots.&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Set the master. */</span>
        <span class="c1">// 将节点 n 设为本节点的主节点</span>
        <span class="n">clusterSetMaster</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">clusterDoBeforeSleep</span><span class="p">(</span><span class="n">CLUSTER_TODO_UPDATE_STATE</span><span class="o">|</span><span class="n">CLUSTER_TODO_SAVE_CONFIG</span><span class="p">);</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Wrong CLUSTER subcommand or number of arguments&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * DUMP, RESTORE and MIGRATE commands</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* Generates a DUMP-format representation of the object &#39;o&#39;, adding it to the</span>
<span class="cm"> * io stream pointed by &#39;rio&#39;. This function can&#39;t fail. </span>
<span class="cm"> *</span>
<span class="cm"> * 创建对象 o 的一个 DUMP 格式表示，</span>
<span class="cm"> * 并将它添加到 rio 指针指向的 io 流当中。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">createDumpPayload</span><span class="p">(</span><span class="n">rio</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="n">crc</span><span class="p">;</span>

    <span class="cm">/* Serialize the object in a RDB-like format. It consist of an object type</span>
<span class="cm">     * byte followed by the serialized object. This is understood by RESTORE. */</span>
    <span class="n">rioInitWithBuffer</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span><span class="n">sdsempty</span><span class="p">());</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">rdbSaveObjectType</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span><span class="n">o</span><span class="p">));</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">rdbSaveObject</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span><span class="n">o</span><span class="p">));</span>

    <span class="cm">/* Write the footer, this is how it looks like:</span>
<span class="cm">     * ----------------+---------------------+---------------+</span>
<span class="cm">     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |</span>
<span class="cm">     * ----------------+---------------------+---------------+</span>
<span class="cm">     * RDB version and CRC are both in little endian.</span>
<span class="cm">     */</span>

    <span class="cm">/* RDB version */</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">REDIS_RDB_VERSION</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">REDIS_RDB_VERSION</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="n">payload</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

    <span class="cm">/* CRC64 */</span>
    <span class="n">crc</span> <span class="o">=</span> <span class="n">crc64</span><span class="p">(</span><span class="mi">0</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
                <span class="n">sdslen</span><span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">));</span>
    <span class="n">memrev64ifbe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crc</span><span class="p">);</span>
    <span class="n">payload</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">payload</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">crc</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Verify that the RDB version of the dump payload matches the one of this Redis</span>
<span class="cm"> * instance and that the checksum is ok.</span>
<span class="cm"> *</span>
<span class="cm"> * 检查输入的 DUMP 数据中， RDB 版本是否和当前 Redis 实例所使用的 RDB 版本相同，</span>
<span class="cm"> * 并检查校验和是否正确。</span>
<span class="cm"> *</span>
<span class="cm"> * If the DUMP payload looks valid REDIS_OK is returned, otherwise REDIS_ERR</span>
<span class="cm"> * is returned. </span>
<span class="cm"> *</span>
<span class="cm"> * 检查正常返回 REDIS_OK ，否则返回 REDIS_ERR 。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">verifyDumpPayload</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">footer</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">rdbver</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">crc</span><span class="p">;</span>

    <span class="cm">/* At least 2 bytes of RDB version and 8 of CRC64 should be present. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="n">footer</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>

    <span class="cm">/* Verify RDB version */</span>
    <span class="n">rdbver</span> <span class="o">=</span> <span class="p">(</span><span class="n">footer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">footer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rdbver</span> <span class="o">!=</span> <span class="n">REDIS_RDB_VERSION</span><span class="p">)</span> <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>

    <span class="cm">/* Verify CRC64 */</span>
    <span class="n">crc</span> <span class="o">=</span> <span class="n">crc64</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">len</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">memrev64ifbe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crc</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">crc</span><span class="p">,</span><span class="n">footer</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nl">REDIS_OK</span> <span class="p">:</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DUMP keyname</span>
<span class="cm"> * DUMP is actually not used by Redis Cluster but it is the obvious</span>
<span class="cm"> * complement of RESTORE and can be useful for different applications. */</span>
<span class="kt">void</span> <span class="nf">dumpCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">*</span><span class="n">dumpobj</span><span class="p">;</span>
    <span class="n">rio</span> <span class="n">payload</span><span class="p">;</span>

    <span class="cm">/* Check if the key is here. */</span>
    <span class="c1">// 取出给定键</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">o</span> <span class="o">=</span> <span class="n">lookupKeyRead</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">nullbulk</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Create the DUMP encoded representation. */</span>
    <span class="c1">// 创建给定键值对的一个编码表示</span>
    <span class="n">createDumpPayload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span><span class="n">o</span><span class="p">);</span>

    <span class="cm">/* Transfer to the client */</span>
    <span class="c1">// 将编码后的键值对数据返回给客户端</span>
    <span class="n">dumpobj</span> <span class="o">=</span> <span class="n">createObject</span><span class="p">(</span><span class="n">REDIS_STRING</span><span class="p">,</span><span class="n">payload</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">addReplyBulk</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">dumpobj</span><span class="p">);</span>
    <span class="n">decrRefCount</span><span class="p">(</span><span class="n">dumpobj</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RESTORE key ttl serialized-value [REPLACE] */</span>
<span class="c1">// 根据给定的 DUMP 数据，还原出一个键值对数据，并将它保存到数据库里面</span>
<span class="kt">void</span> <span class="nf">restoreCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">ttl</span><span class="p">;</span>
    <span class="n">rio</span> <span class="n">payload</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

    <span class="cm">/* Parse additional options */</span>
    <span class="c1">// 是否使用了 REPLACE 选项？</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;replace&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">replace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">syntaxerr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Make sure this key does not already exist here... */</span>
    <span class="c1">// 如果没有给定 REPLACE 选项，并且键已经存在，那么返回错误</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replace</span> <span class="o">&amp;&amp;</span> <span class="n">lookupKeyWrite</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Target key name is busy.&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check if the TTL value makes sense */</span>
    <span class="c1">// 取出 TTL 值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="o">&amp;</span><span class="n">ttl</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ttl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Invalid TTL value, must be &gt;= 0&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Verify RDB version and data checksum. */</span>
    <span class="c1">// 检查 RDB 版本和校验和</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">verifyDumpPayload</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">))</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;DUMP payload version or checksum are wrong&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 读取 DUMP 数据，并分析出键值对的类型和值</span>
    <span class="n">rioInitWithBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">type</span> <span class="o">=</span> <span class="n">rdbLoadObjectType</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">((</span><span class="n">obj</span> <span class="o">=</span> <span class="n">rdbLoadObject</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Bad data format&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Remove the old key if needed. */</span>
    <span class="c1">// 如果给定了 REPLACE 选项，那么先删除数据库中已存在的同名键</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">replace</span><span class="p">)</span> <span class="n">dbDelete</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="cm">/* Create the key and set the TTL if any */</span>
    <span class="c1">// 将键值对添加到数据库</span>
    <span class="n">dbAdd</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">obj</span><span class="p">);</span>
    <span class="c1">// 如果有 TTL 的话，设置 TTL</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ttl</span><span class="p">)</span> <span class="n">setExpire</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">mstime</span><span class="p">()</span><span class="o">+</span><span class="n">ttl</span><span class="p">);</span>

    <span class="n">signalModifiedKey</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">dirty</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* MIGRATE socket cache implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * MIGRATE 套接字缓存实现</span>
<span class="cm"> *</span>
<span class="cm"> * We take a map between host:ip and a TCP socket that we used to connect</span>
<span class="cm"> * to this instance in recent time.</span>
<span class="cm"> *</span>
<span class="cm"> * 保存一个字典，字典的键为 host:ip ，值为最近使用的连接向指定地址的 TCP 套接字。</span>
<span class="cm"> *</span>
<span class="cm"> * This sockets are closed when the max number we cache is reached, and also</span>
<span class="cm"> * in serverCron() when they are around for more than a few seconds. </span>
<span class="cm"> *</span>
<span class="cm"> * 这个字典在缓存数达到上限时被释放，</span>
<span class="cm"> * 并且 serverCron() 也会定期删除字典中的一些过期套接字。</span>
<span class="cm"> */</span>
<span class="c1">// 最大缓存数</span>
<span class="cp">#define MIGRATE_SOCKET_CACHE_ITEMS 64 </span><span class="cm">/* max num of items in the cache. */</span><span class="cp"></span>
<span class="c1">// 套接字保质期（超过这个时间的套接字会被删除）</span>
<span class="cp">#define MIGRATE_SOCKET_CACHE_TTL 10 </span><span class="cm">/* close cached socekts after 10 sec. */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">migrateCachedSocket</span> <span class="p">{</span>

    <span class="c1">// 套接字描述符</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="c1">// 最后一次使用的时间</span>
    <span class="kt">time_t</span> <span class="n">last_use_time</span><span class="p">;</span>

<span class="p">}</span> <span class="n">migrateCachedSocket</span><span class="p">;</span>

<span class="cm">/* Return a TCP scoket connected with the target instance, possibly returning</span>
<span class="cm"> * a cached one.</span>
<span class="cm"> *</span>
<span class="cm"> * 返回一个连接向指定地址的 TCP 套接字，这个套接字可能是一个缓存套接字。</span>
<span class="cm"> *</span>
<span class="cm"> * This function is responsible of sending errors to the client if a</span>
<span class="cm"> * connection can&#39;t be established. In this case -1 is returned.</span>
<span class="cm"> * Otherwise on success the socket is returned, and the caller should not</span>
<span class="cm"> * attempt to free it after usage.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果连接出错，那么函数返回 -1 。</span>
<span class="cm"> * 如果连接正常，那么函数返回 TCP 套接字描述符。</span>
<span class="cm"> *</span>
<span class="cm"> * If the caller detects an error while using the socket, migrateCloseSocket()</span>
<span class="cm"> * should be called so that the connection will be craeted from scratch</span>
<span class="cm"> * the next time. </span>
<span class="cm"> *</span>
<span class="cm"> * 如果调用者在使用这个函数返回的套接字时遇上错误，</span>
<span class="cm"> * 那么调用者会使用 migrateCloseSocket() 来关闭出错的套接字，</span>
<span class="cm"> * 这样下次要连接相同地址时，服务器就会创建新的套接字来进行连接。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">migrateGetSocket</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">name</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
    <span class="n">migrateCachedSocket</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

    <span class="cm">/* Check if we have an already cached socket for this ip:port pair. */</span>
    <span class="c1">// 根据 ip 和 port 创建地址名字</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&quot;:&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
    
    <span class="c1">// 在套接字缓存中查找套接字是否已经存在</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">dictFetchValue</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
    <span class="c1">// 缓存存在，更新最后一次使用时间，以免它被当作过期套接字而被释放</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="n">cs</span><span class="o">-&gt;</span><span class="n">last_use_time</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* No cached socket, create one. */</span>
    <span class="c1">// 没有缓存，创建一个新的缓存</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">)</span> <span class="o">==</span> <span class="n">MIGRATE_SOCKET_CACHE_ITEMS</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 如果缓存数已经达到上线，那么在创建套接字之前，先随机删除一个连接</span>

        <span class="cm">/* Too many items, drop one at random. */</span>
        <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictGetRandomKey</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">);</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
        <span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">,</span><span class="n">dictGetKey</span><span class="p">(</span><span class="n">de</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* Create the socket */</span>
    <span class="c1">// 创建连接</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">anetTcpNonBlockConnect</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span>
                <span class="n">atoi</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Can&#39;t connect to target node: %s&quot;</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">anetEnableTcpNoDelay</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">neterr</span><span class="p">,</span><span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Check if it connects within the specified timeout. */</span>
    <span class="c1">// 检查连接的超时设置</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">aeWait</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">,</span><span class="n">timeout</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sdsnew</span><span class="p">(</span><span class="s">&quot;-IOERR error or timeout connecting to the client</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Add to the cache and return it to the caller. */</span>
    <span class="c1">// 将连接添加到缓存</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cs</span><span class="p">));</span>
    <span class="n">cs</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">cs</span><span class="o">-&gt;</span><span class="n">last_use_time</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
    <span class="n">dictAdd</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">cs</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free a migrate cached connection. */</span>
<span class="c1">// 释放一个缓存连接</span>
<span class="kt">void</span> <span class="nf">migrateCloseSocket</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">name</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
    <span class="n">migrateCachedSocket</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>

    <span class="c1">// 根据 ip 和 port 创建连接的名字</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&quot;:&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
    <span class="c1">// 查找连接</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">dictFetchValue</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 关闭连接</span>
    <span class="n">close</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>

    <span class="c1">// 从缓存中删除该连接</span>
    <span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 移除过期的连接，由 redis.c/serverCron() 调用</span>
<span class="kt">void</span> <span class="nf">migrateCloseTimedoutSockets</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">);</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">migrateCachedSocket</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>

        <span class="c1">// 如果套接字最后一次使用的时间已经超过 MIGRATE_SOCKET_CACHE_TTL </span>
        <span class="c1">// 那么表示该套接字过期，释放它！</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span> <span class="o">-</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">last_use_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MIGRATE_SOCKET_CACHE_TTL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">close</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
            <span class="n">zfree</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>
            <span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">migrate_cached_sockets</span><span class="p">,</span><span class="n">dictGetKey</span><span class="p">(</span><span class="n">de</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* MIGRATE host port key dbid timeout [COPY | REPLACE] */</span>
<span class="kt">void</span> <span class="nf">migrateCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">dbid</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">ttl</span><span class="p">,</span> <span class="n">expireat</span><span class="p">;</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
    <span class="n">rio</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">payload</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retry_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">try_again</span><span class="p">:</span>
    <span class="cm">/* Initialization */</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">replace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ttl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Parse additional options */</span>
    <span class="c1">// 读入 COPY 或者 REPLACE 选项</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;copy&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;replace&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">replace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">syntaxerr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Sanity check */</span>
    <span class="c1">// 检查输入参数的正确性</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="o">&amp;</span><span class="n">dbid</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

    <span class="cm">/* Check if the key is here. If not we reply with success as there is</span>
<span class="cm">     * nothing to migrate (for instance the key expired in the meantime), but</span>
<span class="cm">     * we include such information in the reply string. */</span>
    <span class="c1">// 取出指定的键</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">o</span> <span class="o">=</span> <span class="n">lookupKeyRead</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sdsnew</span><span class="p">(</span><span class="s">&quot;+NOKEY</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="cm">/* Connect */</span>
    <span class="c1">// 获取套接字连接</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">migrateGetSocket</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">timeout</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="cm">/* error sent to the client by migrateGetSocket() */</span>

    <span class="cm">/* Create RESTORE payload and generate the protocol to call the command. */</span>
    <span class="c1">// 创建用于指定数据库的 SELECT 命令，以免键值对被还原到了错误的地方</span>
    <span class="n">rioInitWithBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="n">sdsempty</span><span class="p">());</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="sc">&#39;*&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="s">&quot;SELECT&quot;</span><span class="p">,</span><span class="mi">6</span><span class="p">));</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkLongLong</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="n">dbid</span><span class="p">));</span>

    <span class="c1">// 取出键的过期时间</span>
    <span class="n">expireat</span> <span class="o">=</span> <span class="n">getExpire</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">expireat</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ttl</span> <span class="o">=</span> <span class="n">expireat</span><span class="o">-</span><span class="n">mstime</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ttl</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ttl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="sc">&#39;*&#39;</span><span class="p">,</span><span class="n">replace</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">4</span><span class="p">));</span>

    <span class="c1">// 如果运行在集群模式下，那么发送的命令为 RESTORE-ASKING</span>
    <span class="c1">// 如果运行在非集群模式下，那么发送的命令为 RESTORE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span><span class="p">)</span>
        <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span>
            <span class="n">rioWriteBulkString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="s">&quot;RESTORE-ASKING&quot;</span><span class="p">,</span><span class="mi">14</span><span class="p">));</span>
    <span class="k">else</span>
        <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="s">&quot;RESTORE&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">));</span>

    <span class="c1">// 写入键名和过期时间</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">sdsEncodedObject</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)));</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkLongLong</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="n">ttl</span><span class="p">));</span>

    <span class="cm">/* Emit the payload argument, that is the serialized object using</span>
<span class="cm">     * the DUMP format. */</span>
    <span class="c1">// 写入值的类型，以及值本身</span>
    <span class="n">createDumpPayload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span><span class="n">o</span><span class="p">);</span>
    <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="n">payload</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span>
                                <span class="n">sdslen</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">)));</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>

    <span class="cm">/* Add the REPLACE option to the RESTORE command if it was specified</span>
<span class="cm">     * as a MIGRATE option. */</span>
    <span class="c1">// 是否设置了 REPLACE 命令？</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">replace</span><span class="p">)</span>
        <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rioWriteBulkString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span><span class="s">&quot;REPLACE&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">));</span>

    <span class="cm">/* Transfer the query to the other node in 64K chunks. */</span>
    <span class="c1">// 以 64 kb 每次的大小向对方发送数据</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">sds</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">towrite</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nwritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">((</span><span class="n">towrite</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">towrite</span> <span class="o">=</span> <span class="p">(</span><span class="n">towrite</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="o">:</span> <span class="n">towrite</span><span class="p">);</span>
            <span class="n">nwritten</span> <span class="o">=</span> <span class="n">syncWrite</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="o">+</span><span class="n">pos</span><span class="p">,</span><span class="n">towrite</span><span class="p">,</span><span class="n">timeout</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">towrite</span><span class="p">)</span> <span class="k">goto</span> <span class="n">socket_wr_err</span><span class="p">;</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Read back the reply. */</span>
    <span class="c1">// 读取命令的回复</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf1</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
        <span class="kt">char</span> <span class="n">buf2</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

        <span class="cm">/* Read the two replies */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syncReadLine</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf1</span><span class="p">),</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">socket_rd_err</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syncReadLine</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf2</span><span class="p">),</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">socket_rd_err</span><span class="p">;</span>

        <span class="c1">// 检查 RESTORE 命令执行是否成功</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="o">||</span> <span class="n">buf2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 执行出错。。。</span>

            <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Target instance replied with error: %s&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="n">buf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="n">buf1</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">buf2</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

            <span class="c1">// 执行成功。。。</span>

            <span class="n">robj</span> <span class="o">*</span><span class="n">aux</span><span class="p">;</span>

            <span class="c1">// 如果没有指定 COPY 选项，那么删除本机数据库中的键</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* No COPY option: remove the local key, signal the change. */</span>
                <span class="n">dbDelete</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
                <span class="n">signalModifiedKey</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
            <span class="n">server</span><span class="p">.</span><span class="n">dirty</span><span class="o">++</span><span class="p">;</span>

            <span class="cm">/* Translate MIGRATE as DEL for replication/AOF. */</span>
            <span class="c1">// 如果键被删除了的话，向 AOF 文件和从服务器/节点发送一个 DEL 命令</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">createStringObject</span><span class="p">(</span><span class="s">&quot;DEL&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
            <span class="n">rewriteClientCommandVector</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">aux</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
            <span class="n">decrRefCount</span><span class="p">(</span><span class="n">aux</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">sdsfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>

<span class="nl">socket_wr_err</span><span class="p">:</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">migrateCloseSocket</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">ETIMEDOUT</span> <span class="o">&amp;&amp;</span> <span class="n">retry_num</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
    <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span>
        <span class="n">sdsnew</span><span class="p">(</span><span class="s">&quot;-IOERR error or timeout writing to target instance</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>

<span class="nl">socket_rd_err</span><span class="p">:</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">migrateCloseSocket</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">ETIMEDOUT</span> <span class="o">&amp;&amp;</span> <span class="n">retry_num</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
    <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span>
        <span class="n">sdsnew</span><span class="p">(</span><span class="s">&quot;-IOERR error or timeout reading from target node</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The ASKING command is required after a -ASK redirection.</span>
<span class="cm"> *</span>
<span class="cm"> * 客户端在接到 -ASK 转向之后，需要发送 ASKING 命令。</span>
<span class="cm"> *</span>
<span class="cm"> * The client should issue ASKING before to actually send the command to</span>
<span class="cm"> * the target instance. See the Redis Cluster specification for more</span>
<span class="cm"> * information. </span>
<span class="cm"> *</span>
<span class="cm"> * 客户端应该在向目标节点发送命令之前，向节点发送 ASKING 命令。</span>
<span class="cm"> * 具体原因请参考 Redis 集群规范。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">askingCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;This instance has cluster support disabled&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 打开客户端的标识</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_ASKING</span><span class="p">;</span>

    <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* -----------------------------------------------------------------------------</span>
<span class="cm"> * Cluster functions related to serving / redirecting clients</span>
<span class="cm"> * -------------------------------------------------------------------------- */</span>

<span class="cm">/* Return the pointer to the cluster node that is able to serve the command.</span>
<span class="cm"> * For the function to succeed the command should only target a single</span>
<span class="cm"> * key (or the same key multiple times).</span>
<span class="cm"> *</span>
<span class="cm"> * 返回负责处理命令 cmd 的节点的 clusterNode ，集群目前只允许执行处理单个键的命令。</span>
<span class="cm"> *</span>
<span class="cm"> * If the returned node should be used only for this request, the *ask</span>
<span class="cm"> * integer is set to &#39;1&#39;, otherwise to &#39;0&#39;. This is used in order to</span>
<span class="cm"> * let the caller know if we should reply with -MOVED or with -ASK.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果返回的节点仅被用于当此转向，那么将 ask 设置为 1 ，否则设置为 0 。</span>
<span class="cm"> * 根据 ask 的值，节点会判断应该是发送 -ASK 转向（临时转向）还是 -MOVED 转向（永久转向）。</span>
<span class="cm"> *</span>
<span class="cm"> * If the command contains multiple keys, and as a consequence it is not</span>
<span class="cm"> * possible to handle the request in Redis Cluster, NULL is returned. </span>
<span class="cm"> *</span>
<span class="cm"> * 如果命令包含多个键，那么这个命令不能被集群处理，函数返回 NULL 。</span>
<span class="cm"> */</span>
<span class="n">clusterNode</span> <span class="o">*</span><span class="nf">getNodeByQuery</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hashslot</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ask</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 初始化为 NULL ，</span>
    <span class="c1">// 如果输入命令是无参数命令，那么 n 就会继续为 NULL</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">robj</span> <span class="o">*</span><span class="n">firstkey</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">multiState</span> <span class="o">*</span><span class="n">ms</span><span class="p">,</span> <span class="n">_ms</span><span class="p">;</span>
    <span class="n">multiCmd</span> <span class="n">mc</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* We handle all the cases as if they were EXEC commands, so we have</span>
<span class="cm">     * a common code path for everything */</span>
    <span class="c1">// 集群可以执行事务，</span>
    <span class="c1">// 但必须确保事务中的所有命令都是针对某个相同的键进行的</span>
    <span class="c1">// 这个 if 和接下来的 for 进行的就是这一合法性检测</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">==</span> <span class="n">execCommand</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If REDIS_MULTI flag is not set EXEC is just going to return an</span>
<span class="cm">         * error. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MULTI</span><span class="p">))</span> <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">;</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mstate</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* In order to have a single codepath create a fake Multi State</span>
<span class="cm">         * structure if the client is not in MULTI/EXEC state, this way</span>
<span class="cm">         * we have a single codepath below. */</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_ms</span><span class="p">;</span>
        <span class="n">_ms</span><span class="p">.</span><span class="n">commands</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">;</span>
        <span class="n">_ms</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">mc</span><span class="p">.</span><span class="n">argv</span> <span class="o">=</span> <span class="n">argv</span><span class="p">;</span>
        <span class="n">mc</span><span class="p">.</span><span class="n">argc</span> <span class="o">=</span> <span class="n">argc</span><span class="p">;</span>
        <span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check that all the keys are the same key, and get the slot and</span>
<span class="cm">     * node for this key. */</span>
    <span class="c1">// 遍历事务中的命令</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">mcmd</span><span class="p">;</span>
        <span class="n">robj</span> <span class="o">**</span><span class="n">margv</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">margc</span><span class="p">,</span> <span class="o">*</span><span class="n">keyindex</span><span class="p">,</span> <span class="n">numkeys</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

        <span class="n">mcmd</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd</span><span class="p">;</span>
        <span class="n">margc</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">argc</span><span class="p">;</span>
        <span class="n">margv</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">argv</span><span class="p">;</span>

        <span class="c1">// 定位命令的键位置</span>
        <span class="n">keyindex</span> <span class="o">=</span> <span class="n">getKeysFromCommand</span><span class="p">(</span><span class="n">mcmd</span><span class="p">,</span><span class="n">margv</span><span class="p">,</span><span class="n">margc</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numkeys</span><span class="p">,</span>
                                      <span class="n">REDIS_GETKEYS_ALL</span><span class="p">);</span>

        <span class="c1">// 遍历命令中的所有键</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numkeys</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">firstkey</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 这是事务中第一个被处理的键</span>
                <span class="c1">// 获取该键的槽和负责处理该槽的节点</span>
                <span class="cm">/* This is the first key we see. Check what is the slot</span>
<span class="cm">                 * and node. */</span>

                <span class="c1">// 键</span>
                <span class="n">firstkey</span> <span class="o">=</span> <span class="n">margv</span><span class="p">[</span><span class="n">keyindex</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span>

                <span class="c1">// 计算负责处理键 firstkey 的槽</span>
                <span class="n">slot</span> <span class="o">=</span> <span class="n">keyHashSlot</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">firstkey</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">firstkey</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>

                <span class="c1">// 指向负责处理槽 slot 的节点</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
                <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">firstkey</span><span class="p">,</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* If it is not the first key, make sure it is exactly</span>
<span class="cm">                 * the same key as the first we saw. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">equalStringObjects</span><span class="p">(</span><span class="n">firstkey</span><span class="p">,</span><span class="n">margv</span><span class="p">[</span><span class="n">keyindex</span><span class="p">[</span><span class="n">j</span><span class="p">]]))</span> <span class="p">{</span>
                    <span class="n">getKeysFreeResult</span><span class="p">(</span><span class="n">keyindex</span><span class="p">);</span>
                    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">getKeysFreeResult</span><span class="p">(</span><span class="n">keyindex</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ask</span><span class="p">)</span> <span class="o">*</span><span class="n">ask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* This is the default. Set to 1 if needed later. */</span>

    <span class="cm">/* No key at all in command? then we can serve the request</span>
<span class="cm">     * without redirections. */</span>
    <span class="c1">// 这是一个无参数命令，无须转向，直接由本节点处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">;</span>

    <span class="c1">// 记录负责处理键的槽</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hashslot</span><span class="p">)</span> <span class="o">*</span><span class="n">hashslot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>

    <span class="cm">/* This request is about a slot we are migrating into another instance?</span>
<span class="cm">     * Then we need to check if we have the key. If we have it we can reply.</span>
<span class="cm">     * If instead is a new key, we pass the request to the node that is</span>
<span class="cm">     * receiving the slot. */</span>
    <span class="c1">// 如果负责处理槽 slot 的是本节点</span>
    <span class="c1">// 并且这个槽 slot 正在迁移至另一个节点</span>
    <span class="c1">// 那么首先检查键 key 是否存在于本节点</span>
    <span class="c1">// 如果没有的话，那么键 key 可能已经转移至另一个节点了</span>
    <span class="c1">// 要求客户端进行 ASK 临时转向，到另一个节点去查找键 key</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span> <span class="o">&amp;&amp;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 在本节点中查找键 key</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lookupKeyRead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">firstkey</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 进行 ASK 临时转向</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ask</span><span class="p">)</span> <span class="o">*</span><span class="n">ask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="c1">// 返回转移槽 slot 的目标节点</span>
            <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">migrating_slots_to</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Handle the case in which we are receiving this hash slot from</span>
<span class="cm">     * another instance, so we&#39;ll accept the query even if in the table</span>
<span class="cm">     * it is assigned to a different node, but only if the client</span>
<span class="cm">     * issued an ASKING command before. */</span>
    <span class="c1">// 如果当前客户端正在从另一个节点中导入槽 slot</span>
    <span class="c1">// 并且客户端发送来了 ASK 命令，那么将槽 slot 的负责节点设为当前节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">importing_slots_from</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_ASKING</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_CMD_ASKING</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">myself</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* It&#39;s not a -ASK case. Base case: just return the right node. */</span>
    <span class="c1">// 返回负责处理槽 slot 的节点 n</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>



            <div class="section" id="discuss">

    <h2>
        留言
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'notehuangzme'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">集群（cluster）</a><ul>
<li><a class="reference internal" href="#cluster-h">cluster.h</a></li>
<li><a class="reference internal" href="#cluster-c">cluster.c</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="sentinel.html"
                        title="previous chapter">Sentinel</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../reuse-redis-module/index.html"
                        title="next chapter">重用 Redis 模块</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2014, huangz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>