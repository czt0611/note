<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>WATCH 和 UNWATCH &mdash; huangz/note</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'present',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="huangz/note" href="../../index.html" />
    <link rel="up" title="Redis 源码分析" href="index.html" />
    <link rel="next" title="键空间通知" href="keyspace-notification.html" />
    <link rel="prev" title="事务" href="transaction.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->





</head>
<body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="keyspace-notification.html" title="键空间通知"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="transaction.html" title="事务"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">huangz/note</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Redis 源码分析</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="watch-unwatch">
<h1>WATCH 和 UNWATCH<a class="headerlink" href="#watch-unwatch" title="Permalink to this headline">¶</a></h1>
<p>对 Redis 的 <code class="docutils literal"><span class="pre">WATCH</span></code> 命令和 <code class="docutils literal"><span class="pre">UNWATCH</span></code> 命令的源码进行分析，
了解 Redis 事务中的乐观锁实现机制。</p>
<p>和之前介绍的 <a class="reference external" href="http://huangz.me/redis-transaction-implement/">Redis 事务命令</a> 一样， <code class="docutils literal"><span class="pre">WATCH</span></code> 和 <code class="docutils literal"><span class="pre">UNWATCH</span></code> 命令的源码也放在 <code class="docutils literal"><span class="pre">multi.c</span></code> 文件中。</p>
<div class="section" id="watch">
<h2>WATCH 命令<a class="headerlink" href="#watch" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">WATCH</span></code> 的主要作用是在事务中构建乐观锁。</p>
<p>以下是使用 <code class="docutils literal"><span class="pre">WATCH</span></code> 时最常见的两种情形：</p>
<p>第一种可能是：
客户端对某个或某些 KEY 进行 <code class="docutils literal"><span class="pre">WATCH</span></code> ，
如果在调用 <code class="docutils literal"><span class="pre">EXEC</span></code> 命令之前，没有任何 <code class="docutils literal"><span class="pre">WATCH</span></code> 监视的 KEY 被改动，
那么事务可以开始执行。</p>
<p>就像这样：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">WATCH</span> <span class="n">number</span>
<span class="n">OK</span>
<span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>
<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">number</span> <span class="mi">10086</span>
<span class="n">QUEUED</span>
<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="mi">1</span><span class="p">)</span> <span class="n">OK</span>
</pre></div>
</div>
<p>另一种可能的情况是：
在对 KEY 进行 <code class="docutils literal"><span class="pre">WATCH</span></code> 之后，客户端执行 <code class="docutils literal"><span class="pre">EXEC</span></code> 之前，
有其他客户端对被 <code class="docutils literal"><span class="pre">WATCH</span></code> 的 KEY 进行了改动，
那么事务的执行就会被取消。</p>
<p>就像这样：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">WATCH</span> <span class="n">number</span>
<span class="n">OK</span>
<span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>
<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">number</span> <span class="mi">123456</span>
<span class="n">QUEUED</span>
<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>Redis 向客户端返回 <code class="docutils literal"><span class="pre">nil</span></code> ，
表示事务执行失败，
没有任何命令被执行。</p>
</div>
<div class="section" id="id1">
<h2>与 WATCH 有关的数据结构<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>为了实用性和操作的方便性，
Redis 将被 <code class="docutils literal"><span class="pre">WATCH</span></code> 的 KEY 的信息分别保存到两个数据结构中。</p>
<p>其中一个是 <code class="docutils literal"><span class="pre">redis.h</span></code> 文件中的 <code class="docutils literal"><span class="pre">redisClient</span></code> 结构，
它的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 是一个链表，
所有被监视的 KEY 都被保存在这个链表里：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>
    <span class="c1">// 其他属性 ...</span>
    <span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>                <span class="c1">// 当前 DB</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">watched_keys</span><span class="p">;</span>         <span class="c1">// 这个客户端 WATCH 的所有 KEY</span>
    <span class="c1">// 其他属性 ...</span>
<span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">watched_keys</span></code> 链表中的每个节点都是一个 <code class="docutils literal"><span class="pre">watchedKey</span></code> 结构：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">watchedKey</span> <span class="p">{</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>      <span class="c1">// 被 WATCH 的 KEY</span>
    <span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>    <span class="c1">// 被 WATCH 的 KEY 所在的 DB</span>
<span class="p">}</span> <span class="n">watchedKey</span><span class="p">;</span>
</pre></div>
</div>
<p>以前面执行的 <code class="docutils literal"><span class="pre">WATCH</span></code> 命令为例子，在执行 <code class="docutils literal"><span class="pre">EXEC</span></code> 的时候， <code class="docutils literal"><span class="pre">watched_keys</span></code> 的值应该类似于这样（用 JSON 结构表示）：</p>
<div class="highlight-json"><div class="highlight"><pre>redisClient.watched_keys = [
    // 链表
    {   // watchedKey struct
        &#39;key&#39;: &#39;number&#39;,
        &#39;db&#39;: 0
    }
]
</pre></div>
</div>
<p>另一方面，除了 <code class="docutils literal"><span class="pre">redisClient</span></code> 之外，Redis 还将被 <code class="docutils literal"><span class="pre">WATCH</span></code> 的 KEY 添加到 <code class="docutils literal"><span class="pre">redisDb</span></code> 结构中（这个结构也在 <code class="docutils literal"><span class="pre">redis.h</span></code> 文件里）：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>
    <span class="c1">// 其他属性 ...</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">watched_keys</span><span class="p">;</span>
<span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</pre></div>
</div>
<p>在 Redis 中，每个数据库实例都使用一个 <code class="docutils literal"><span class="pre">redisDb</span></code> 来表示，
而每个 <code class="docutils literal"><span class="pre">redisDb</span></code> 都使用一个字典 <code class="docutils literal"><span class="pre">watched_keys</span></code> ，来保存被 <code class="docutils literal"><span class="pre">WATCH</span></code> KEY 的信息。</p>
<p>这些字典使用被 <code class="docutils literal"><span class="pre">WATCH</span></code> 的 KEY 作为关键字，而字典的值则是一个链表，链表中保存了所有 <code class="docutils literal"><span class="pre">WATCH</span></code> 这个数据库的这个 KEY 的所有客户端。</p>
<p>还是用前面执行的那个 <code class="docutils literal"><span class="pre">WATCH</span></code> 作为例子，假设我们使用的客户端代号为 <code class="docutils literal"><span class="pre">client_123</span></code> ，那么 <code class="docutils literal"><span class="pre">redisDb.watched_keys</span></code> 这个属性的值应该类似于这样（用 JSON 结构表示）：</p>
<div class="highlight-json"><div class="highlight"><pre>redisDb.watched_keys = {
    // 被 WATCH 的 KEY : 所有客户端
    &#39;number&#39; : [&#39;client_123&#39;]
}
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>WATCH 数据结构的实现决策<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>上一节讲到，Redis 将 <code class="docutils literal"><span class="pre">WATCH</span></code> KEY 的信息分别放到了两个地方，
一个是 <code class="docutils literal"><span class="pre">redisClient.watched_keys</span></code> 链表，
另一个是 <code class="docutils literal"><span class="pre">redisDb.watched_keys</span></code> 字典。</p>
<p>Redis 将 <code class="docutils literal"><span class="pre">WATCH</span></code> 放在这两个不同的地方，
分别用于实现两种不同的操作：</p>
<p>对于客户端来说， <code class="docutils literal"><span class="pre">redisClient.watched_keys</span></code> 将所有被监视的 KEY 放在一个链表中，这样 Redis 就可以很方便地设置或清除当前客户端所 <code class="docutils literal"><span class="pre">WATCH</span></code> 的 KEY 。</p>
<p>举个例子，如果某个客户端同时对 <code class="docutils literal"><span class="pre">member</span></code> 、 <code class="docutils literal"><span class="pre">salary</span></code> 和 <code class="docutils literal"><span class="pre">infomation</span></code> 三个 KEY 进行 <code class="docutils literal"><span class="pre">WATCH</span></code> ，当要撤销 <code class="docutils literal"><span class="pre">WATCH</span></code> 的时候（可能是由于事务成功了，也可能是事务失败了，也可能是用户手动执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/unwatch.html">UNWATCH</a> ，谁知道呢），Redis 就可以通过遍历列表，将这个客户端 <code class="docutils literal"><span class="pre">WATCH</span></code> 的这个三个 KEY 都删除。</p>
<p>另一方面，对于数据库而言，这个数据库的某个 KEY ，可能会被多个客户端同时 <code class="docutils literal"><span class="pre">WATCH</span></code> ，因此，在 <code class="docutils literal"><span class="pre">redisDb.watched_keys</span></code> 这个字典里，使用 KEY 作为字典的键，所有 <code class="docutils literal"><span class="pre">WATCH</span></code> 这个 KEY 的客户端的链表作为字典的值，这样就可以在其中一个客户端成功对这个 KEY 进行修改之后，让所有其他客户端都失败。</p>
<p>举个例子，假设 <code class="docutils literal"><span class="pre">client_123</span></code> 、 <code class="docutils literal"><span class="pre">client_456</span></code> 和 <code class="docutils literal"><span class="pre">client_789</span></code> 三个客户端都同时对 <code class="docutils literal"><span class="pre">number</span></code> 这个 KEY 进行 <code class="docutils literal"><span class="pre">WATCH</span></code> ，那么这三个客户端都会被放进链表中，形成一个类似这样的结构（用 JSON 表示）：</p>
<div class="highlight-json"><div class="highlight"><pre>{
    &#39;number&#39;: [&#39;client_123&#39;, &#39;client_456&#39;, &#39;client_789&#39;]
}
</pre></div>
</div>
<p>之后，如果 <code class="docutils literal"><span class="pre">client_123</span></code> 成功修改了 <code class="docutils literal"><span class="pre">number</span></code> 这个 KEY ，那么 Redis 就可以（很方便地）通过遍历链表，对 <code class="docutils literal"><span class="pre">client_456</span></code> 和 <code class="docutils literal"><span class="pre">client_789</span></code> 发起通知，让它们的事务失败（因为 <code class="docutils literal"><span class="pre">number</span></code> 已经被 <code class="docutils literal"><span class="pre">client_123</span></code> 修改了）。</p>
<p>虽然将 <code class="docutils literal"><span class="pre">WATCH</span></code> KEY 的信息复制到两个地方咋看上去很奇怪，
但实际上这是一个对不同操作进行衡量之后做出的实现决策。</p>
</div>
<div class="section" id="id3">
<h2>WATCH 命令的实现<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">WATCH</span></code> 命令由 <code class="docutils literal"><span class="pre">watchCommand</span></code> 函数实现，
它对用户输入的所有 KEY 调用 <code class="docutils literal"><span class="pre">watchForKey</span></code> 函数，
然后返回 <code class="docutils literal"><span class="pre">OK</span></code> ：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">watchCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_MULTI</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;WATCH inside MULTI is not allowed&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">watchForKey</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">watchForKey</span></code> 函数需要完成三件事：</p>
<ol class="arabic simple">
<li>检查给定 KEY 是否已经被被 <code class="docutils literal"><span class="pre">WATCH</span></code> 过：也即是，检查 KEY 是否已经存在于 <code class="docutils literal"><span class="pre">redisClient.watched_keys</span></code> 这个链表中。</li>
</ol>
<p>如果 KEY 没有被 <code class="docutils literal"><span class="pre">WATCH</span></code> 过，那么执行以下两个步骤：</p>
<ol class="arabic simple" start="2">
<li>将 KEY 信息添加到当前数据库的 <code class="docutils literal"><span class="pre">redisDb.watched_keys</span></code> 属性中。</li>
<li>将 KEY 信息添加到当前客户端的 <code class="docutils literal"><span class="pre">redisClient.watched_keys</span></code> 属性中。</li>
</ol>
<p><code class="docutils literal"><span class="pre">watchForKey</span></code> 函数的完整定义如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* Watch for the specified key */</span>
<span class="c1">// WATCH 某个 KEY</span>
<span class="kt">void</span> <span class="nf">watchForKey</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">watchedKey</span> <span class="o">*</span><span class="n">wk</span><span class="p">;</span>

    <span class="cm">/* Check if we are already watching for this key */</span>
    <span class="c1">// 所有被 WATCHED 的 KEY 都被放在 redisClient.watched_keys 链表中</span>
    <span class="c1">// 遍历这个链表，查看这个 KEY 是否已经处于监视状态（WATCHED）</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">wk</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">wk</span><span class="o">-&gt;</span><span class="n">db</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span> <span class="o">&amp;&amp;</span> <span class="n">equalStringObjects</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">wk</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span> <span class="cm">/* Key already watched */</span>
    <span class="p">}</span>

    <span class="cm">/* This key is not already watched in this DB. Let&#39;s add it */</span>
    <span class="c1">// 如果 KEY 还没有被 WATCH 过，那么对它进行 WATCH</span>
    <span class="n">clients</span> <span class="o">=</span> <span class="n">dictFetchValue</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clients</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果 clients 链表不存在</span>
        <span class="c1">// 说明这个客户端是第一个监视这个 DB 的这个 KEY 的客户端</span>
        <span class="c1">// 那么创建 clients 链表，并将它添加到 c-&gt;db-&gt;watched_keys 字典中</span>
        <span class="n">clients</span> <span class="o">=</span> <span class="n">listCreate</span><span class="p">();</span>
        <span class="n">dictAdd</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">clients</span><span class="p">);</span>
        <span class="n">incrRefCount</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 将客户端添加到 clients 链表</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">clients</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>

    <span class="cm">/* Add the new key to the lits of keys watched by this client */</span>
    <span class="c1">// 除了 c-&gt;db-&gt;watched_keys 之外</span>
    <span class="c1">// 还要将被 WATCH 的 KEY 添加到 c-&gt;watched_keys</span>
    <span class="n">wk</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wk</span><span class="p">));</span>
    <span class="n">wk</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">wk</span><span class="o">-&gt;</span><span class="n">db</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">;</span>
    <span class="n">incrRefCount</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span><span class="n">wk</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>UNWATCH 命令的实现<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">UNWATCH</span></code> 命令的实现就是 <code class="docutils literal"><span class="pre">WATCH</span></code> 命令的反向操作：它从 <code class="docutils literal"><span class="pre">redisDb.watched_keys</span></code> 和 <code class="docutils literal"><span class="pre">redisClient.watched_keys</span></code> 中清除当前客户端的所有 <code class="docutils literal"><span class="pre">WATCH</span></code> KEY 的信息。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* Unwatch all the keys watched by this client. To clean the EXEC dirty</span>
<span class="cm"> * flag is up to the caller. */</span>
<span class="c1">// 撤销对这个客户端的所有 WATCH</span>
<span class="c1">// 清除 EXEC dirty FLAG 的任务由调用者完成</span>
<span class="kt">void</span> <span class="nf">unwatchAllKeys</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>

    <span class="c1">// 没有 WATCHED KEY ，直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">listRewind</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">list</span> <span class="o">*</span><span class="n">clients</span><span class="p">;</span>
        <span class="n">watchedKey</span> <span class="o">*</span><span class="n">wk</span><span class="p">;</span>

        <span class="cm">/* Lookup the watched key -&gt; clients list and remove the client</span>
<span class="cm">         * from the list */</span>
        <span class="c1">// 将当前客户端从监视 KEY 的链表中移除</span>
        <span class="n">wk</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>
        <span class="n">clients</span> <span class="o">=</span> <span class="n">dictFetchValue</span><span class="p">(</span><span class="n">wk</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span> <span class="n">wk</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
        <span class="n">redisAssertWithInfo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">clients</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">listDelNode</span><span class="p">(</span><span class="n">clients</span><span class="p">,</span><span class="n">listSearchKey</span><span class="p">(</span><span class="n">clients</span><span class="p">,</span><span class="n">c</span><span class="p">));</span>

        <span class="cm">/* Kill the entry at all if this was the only client */</span>
        <span class="c1">// 如果监视 KEY 的只有这个客户端</span>
        <span class="c1">// 那么将链表从字典中删除</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">clients</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dictDelete</span><span class="p">(</span><span class="n">wk</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span> <span class="n">wk</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

        <span class="cm">/* Remove this watched key from the client-&gt;watched list */</span>
        <span class="c1">// 还需要将 KEY 从 client-&gt;watched_keys 链表中移除</span>
        <span class="n">listDelNode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span><span class="n">ln</span><span class="p">);</span>
        <span class="n">decrRefCount</span><span class="p">(</span><span class="n">wk</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">wk</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="touchwatchedkey-touchwatchedkeysonflush">
<h2>touchWatchedKey 和 touchWatchedKeysOnFlush 函数<a class="headerlink" href="#touchwatchedkey-touchwatchedkeysonflush" title="Permalink to this headline">¶</a></h2>
<p>还有另外两个需要一提的函数，
那就是 <code class="docutils literal"><span class="pre">touchWatchedKey</span></code> 函数和 <code class="docutils literal"><span class="pre">touchWatchedKeysOnFlush</span></code> 函数。</p>
<p><code class="docutils literal"><span class="pre">touchWatchedKey</span></code> 接受一个 <code class="docutils literal"><span class="pre">redisDb</span></code> 实例和一个 KEY ，然后将所有 <code class="docutils literal"><span class="pre">WATCHE</span></code> 这个 KEY 的客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 状态都打开。</p>
<p>这样就可以在多个客户端同时 <code class="docutils literal"><span class="pre">WATCHE</span></code> 一个 KEY 的情况下，方便地让多个客户端的事务执行失败，在文章的前面也举过这样一个例子。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// 打开所有 WATCH 给定 KEY 的客户端的 REDIS_DIRTY_CAS 状态</span>
<span class="c1">// 使得接下来的 EXEC 执行失败</span>
<span class="kt">void</span> <span class="nf">touchWatchedKey</span><span class="p">(</span><span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">clients</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">clients</span> <span class="o">=</span> <span class="n">dictFetchValue</span><span class="p">(</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">watched_keys</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clients</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Mark all the clients watching this key as REDIS_DIRTY_CAS */</span>
    <span class="cm">/* Check if we are already watching for this key */</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">clients</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>

        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_DIRTY_CAS</span><span class="p">;</span>    <span class="c1">// 打开 FLAG</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">touchWatchedKeysOnFlush</span></code> 的工作和 <code class="docutils literal"><span class="pre">touchWatchedKey</span></code> 类似：它们都负责打开 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 状态，但 <code class="docutils literal"><span class="pre">touchWatchedKeysOnFlush</span></code> 仅用于 <code class="docutils literal"><span class="pre">FLUSH</span></code> 或者 <code class="docutils literal"><span class="pre">FLUSHALL</span></code> 命令执行之后。</p>
</div>
<div class="section" id="id5">
<h2>总结<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>关于 <code class="docutils literal"><span class="pre">WATCH</span></code> 和 <code class="docutils literal"><span class="pre">UNWATCH</span></code> 命令的分析就到此结束了。</p>
<p>在 Redis 2.6 版本以前， <code class="docutils literal"><span class="pre">WATCH</span></code> 命令是在事务中完成 CAS （check-and-set）动作的唯一方式。</p>
<p>从 Redis 2.6 开始，使用脚本可以更简单方便地完成事务工作。 <a class="reference external" href="http://redis.io/topics/transactions">Redis 官网上也说</a> 未来可能会废弃 <code class="docutils literal"><span class="pre">MULTI</span></code> 、 <code class="docutils literal"><span class="pre">EXEC</span></code> 和 <code class="docutils literal"><span class="pre">WATCH</span></code> 等命令，所有事务工作都交由脚本完成，这应该是一个好方向。</p>
<p>最后，和往常一样，带注释的完整代码可以在 GITHUB 查看： <a class="reference external" href="https://github.com/huangz1990/reading_redis_source">github.com/huangz1990/reading_redis_source</a> 。</p>
</div>
</div>



            <div class="section" id="discuss">

    <h2>
        留言
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'notehuangzme'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">WATCH 和 UNWATCH</a><ul>
<li><a class="reference internal" href="#watch">WATCH 命令</a></li>
<li><a class="reference internal" href="#id1">与 WATCH 有关的数据结构</a></li>
<li><a class="reference internal" href="#id2">WATCH 数据结构的实现决策</a></li>
<li><a class="reference internal" href="#id3">WATCH 命令的实现</a></li>
<li><a class="reference internal" href="#id4">UNWATCH 命令的实现</a></li>
<li><a class="reference internal" href="#touchwatchedkey-touchwatchedkeysonflush">touchWatchedKey 和 touchWatchedKeysOnFlush 函数</a></li>
<li><a class="reference internal" href="#id5">总结</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="transaction.html"
                        title="previous chapter">事务</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="keyspace-notification.html"
                        title="next chapter">键空间通知</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2014, huangz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>