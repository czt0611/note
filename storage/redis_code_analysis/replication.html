<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>复制（replication） &mdash; huangz/note</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'present',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="huangz/note" href="../../index.html" />
    <link rel="up" title="Redis 源码分析" href="index.html" />
    <link rel="next" title="Sentinel" href="sentinel.html" />
    <link rel="prev" title="PUBSUB 命令" href="pubsub_command.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->





</head>
<body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sentinel.html" title="Sentinel"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pubsub_command.html" title="PUBSUB 命令"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">huangz/note</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Redis 源码分析</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="replication">
<h1>复制（replication）<a class="headerlink" href="#replication" title="Permalink to this headline">¶</a></h1>
<p>因为时间关系，这里先贴出代码注释，代码分析如果将来有时间再补上。</p>
<p>首先是服务器状态中，和复制功能有关的属性：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>

    <span class="c1">// 其他属性 ...</span>

    <span class="cm">/* Replication (master) */</span>
    <span class="kt">int</span> <span class="n">slaveseldb</span><span class="p">;</span>                 <span class="cm">/* Last SELECTed DB in replication output */</span>
    <span class="c1">// 全局复制偏移量（一个累计值）</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">master_repl_offset</span><span class="p">;</span>   <span class="cm">/* Global replication offset */</span>
    <span class="c1">// 主服务器发送 PING 的频率</span>
    <span class="kt">int</span> <span class="n">repl_ping_slave_period</span><span class="p">;</span>     <span class="cm">/* Master pings the slave every N seconds */</span>

    <span class="c1">// backlog 本身</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">repl_backlog</span><span class="p">;</span>             <span class="cm">/* Replication backlog for partial syncs */</span>
    <span class="c1">// backlog 的长度</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_size</span><span class="p">;</span>    <span class="cm">/* Backlog circular buffer size */</span>
    <span class="c1">// backlog 中数据的长度</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_histlen</span><span class="p">;</span> <span class="cm">/* Backlog actual data length */</span>
    <span class="c1">// backlog 的当前索引</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_idx</span><span class="p">;</span>     <span class="cm">/* Backlog circular buffer current offset */</span>
    <span class="c1">// backlog 中可以被还原的第一个字节的偏移量</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_backlog_off</span><span class="p">;</span>     <span class="cm">/* Replication offset of first byte in the</span>
<span class="cm">                                       backlog buffer. */</span>
    <span class="c1">// backlog 的过期时间</span>
    <span class="kt">time_t</span> <span class="n">repl_backlog_time_limit</span><span class="p">;</span> <span class="cm">/* Time without slaves after the backlog</span>
<span class="cm">                                       gets released. */</span>

    <span class="c1">// 距离上一次有从服务器的时间</span>
    <span class="kt">time_t</span> <span class="n">repl_no_slaves_since</span><span class="p">;</span>    <span class="cm">/* We have no slaves since that time.</span>
<span class="cm">                                       Only valid if server.slaves len is 0. */</span>

    <span class="c1">// 是否开启最小数量从服务器写入功能</span>
    <span class="kt">int</span> <span class="n">repl_min_slaves_to_write</span><span class="p">;</span>   <span class="cm">/* Min number of slaves to write. */</span>
    <span class="c1">// 定义最小数量从服务器的最大延迟值</span>
    <span class="kt">int</span> <span class="n">repl_min_slaves_max_lag</span><span class="p">;</span>    <span class="cm">/* Max lag of &lt;count&gt; slaves to write. */</span>
    <span class="c1">// 延迟良好的从服务器的数量</span>
    <span class="kt">int</span> <span class="n">repl_good_slaves_count</span><span class="p">;</span>     <span class="cm">/* Number of slaves with lag &lt;= max_lag. */</span>

    <span class="cm">/* Replication (slave) */</span>
    <span class="c1">// 主服务器的验证密码</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">masterauth</span><span class="p">;</span>               <span class="cm">/* AUTH with this password with master */</span>
    <span class="c1">// 主服务器的地址</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">masterhost</span><span class="p">;</span>               <span class="cm">/* Hostname of master */</span>
    <span class="c1">// 主服务器的端口</span>
    <span class="kt">int</span> <span class="n">masterport</span><span class="p">;</span>                 <span class="cm">/* Port of master */</span>
    <span class="c1">// 超时时间</span>
    <span class="kt">int</span> <span class="n">repl_timeout</span><span class="p">;</span>               <span class="cm">/* Timeout after N seconds of master idle */</span>
    <span class="c1">// 主服务器所对应的客户端</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">master</span><span class="p">;</span>     <span class="cm">/* Client that is master for this slave */</span>
    <span class="c1">// 被缓存的主服务器，PSYNC 时使用</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">cached_master</span><span class="p">;</span> <span class="cm">/* Cached master to be reused for PSYNC. */</span>
    <span class="kt">int</span> <span class="n">repl_syncio_timeout</span><span class="p">;</span> <span class="cm">/* Timeout for synchronous I/O calls */</span>
    <span class="c1">// 复制的状态</span>
    <span class="kt">int</span> <span class="n">repl_state</span><span class="p">;</span>          <span class="cm">/* Replication status if the instance is a slave */</span>
    <span class="c1">// RDB 文件的大小</span>
    <span class="kt">off_t</span> <span class="n">repl_transfer_size</span><span class="p">;</span> <span class="cm">/* Size of RDB to read from master during sync. */</span>
    <span class="c1">// 已读 RDB 文件内容的字节数</span>
    <span class="kt">off_t</span> <span class="n">repl_transfer_read</span><span class="p">;</span> <span class="cm">/* Amount of RDB read from master during sync. */</span>
    <span class="c1">// 最近一次执行 fsync 时的偏移量</span>
    <span class="c1">// 用于 sync_file_range 函数</span>
    <span class="kt">off_t</span> <span class="n">repl_transfer_last_fsync_off</span><span class="p">;</span> <span class="cm">/* Offset when we fsync-ed last time. */</span>
    <span class="c1">// 主服务器的套接字</span>
    <span class="kt">int</span> <span class="n">repl_transfer_s</span><span class="p">;</span>     <span class="cm">/* Slave -&gt; Master SYNC socket */</span>
    <span class="c1">// 保存 RDB 文件的临时文件的描述符</span>
    <span class="kt">int</span> <span class="n">repl_transfer_fd</span><span class="p">;</span>    <span class="cm">/* Slave -&gt; Master SYNC temp file descriptor */</span>
    <span class="c1">// 保存 RDB 文件的临时文件名字</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">repl_transfer_tmpfile</span><span class="p">;</span> <span class="cm">/* Slave-&gt; master SYNC temp file name */</span>
    <span class="c1">// 最近一次读入 RDB 内容的时间</span>
    <span class="kt">time_t</span> <span class="n">repl_transfer_lastio</span><span class="p">;</span> <span class="cm">/* Unix time of the latest read, for timeout */</span>
    <span class="kt">int</span> <span class="n">repl_serve_stale_data</span><span class="p">;</span> <span class="cm">/* Serve stale data when link is down? */</span>
    <span class="c1">// 是否只读从服务器？</span>
    <span class="kt">int</span> <span class="n">repl_slave_ro</span><span class="p">;</span>          <span class="cm">/* Slave is read only? */</span>
    <span class="c1">// 连接断开的时长</span>
    <span class="kt">time_t</span> <span class="n">repl_down_since</span><span class="p">;</span> <span class="cm">/* Unix time at which link with master went down */</span>
    <span class="c1">// 是否要在 SYNC 之后关闭 NODELAY ？</span>
    <span class="kt">int</span> <span class="n">repl_disable_tcp_nodelay</span><span class="p">;</span>   <span class="cm">/* Disable TCP_NODELAY after SYNC? */</span>
    <span class="c1">// 从服务器优先级</span>
    <span class="kt">int</span> <span class="n">slave_priority</span><span class="p">;</span>             <span class="cm">/* Reported in INFO and used by Sentinel. */</span>
    <span class="c1">// 主服务器 RUN ID</span>
    <span class="kt">char</span> <span class="n">repl_master_runid</span><span class="p">[</span><span class="n">REDIS_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* Master run id for PSYNC. */</span>
    <span class="c1">// 初始化偏移量</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_master_initial_offset</span><span class="p">;</span>         <span class="cm">/* Master PSYNC offset. */</span>
    <span class="cm">/* Replication script cache. */</span>
    <span class="c1">// 复制脚本缓存</span>
    <span class="c1">// 字典</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">repl_scriptcache_dict</span><span class="p">;</span>        <span class="cm">/* SHA1 all slaves are aware of. */</span>
    <span class="c1">// FIFO 队列</span>
    <span class="n">list</span> <span class="o">*</span><span class="n">repl_scriptcache_fifo</span><span class="p">;</span>        <span class="cm">/* First in, first out LRU eviction. */</span>
    <span class="c1">// 缓存的大小</span>
    <span class="kt">int</span> <span class="n">repl_scriptcache_size</span><span class="p">;</span>          <span class="cm">/* Max number of elements. */</span>

    <span class="c1">// 其他属性 ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>以下是 <code class="docutils literal"><span class="pre">redisClient</span></code> 中和复制有关的代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span> <span class="p">{</span>

    <span class="c1">// 其他属性 ...</span>

    <span class="c1">// 复制状态</span>
    <span class="kt">int</span> <span class="n">replstate</span><span class="p">;</span>          <span class="cm">/* replication state if this is a slave */</span>
    <span class="c1">// 用于保存主服务器传来的 RDB 文件的文件描述符</span>
    <span class="kt">int</span> <span class="n">repldbfd</span><span class="p">;</span>           <span class="cm">/* replication DB file descriptor */</span>
    <span class="c1">// 读取主服务器传来的 RDB 文件的偏移量</span>
    <span class="kt">long</span> <span class="n">repldboff</span><span class="p">;</span>         <span class="cm">/* replication DB file offset */</span>
    <span class="c1">// 主服务器传来的 RDB 文件的大小</span>
    <span class="kt">off_t</span> <span class="n">repldbsize</span><span class="p">;</span>       <span class="cm">/* replication DB file size */</span>

    <span class="c1">// 主服务器的复制偏移量</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">reploff</span><span class="p">;</span>      <span class="cm">/* replication offset if this is our master */</span>
    <span class="c1">// 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_ack_off</span><span class="p">;</span> <span class="cm">/* replication ack offset, if this is a slave */</span>
    <span class="c1">// 从服务器最后一次发送 REPLCONF ACK 的时间</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">repl_ack_time</span><span class="p">;</span><span class="cm">/* replication ack time, if this is a slave */</span>
    <span class="c1">// 主服务器的 master run ID</span>
    <span class="kt">char</span> <span class="n">replrunid</span><span class="p">[</span><span class="n">REDIS_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* master run id if this is a master */</span>
    <span class="c1">// 从服务器的监听端口号</span>
    <span class="kt">int</span> <span class="n">slave_listening_port</span><span class="p">;</span> <span class="cm">/* As configured with: SLAVECONF listening-port */</span>

    <span class="c1">// 其他属性 ...</span>

<span class="p">}</span> <span class="n">redisClient</span><span class="p">;</span>
</pre></div>
</div>
<p>以下是 <code class="docutils literal"><span class="pre">replication.c</span></code> 文件的完整代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* Asynchronous replication implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * 异步复制实现</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright notice,</span>
<span class="cm"> *     this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *     documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *   * Neither the name of Redis nor the names of its contributors may be used</span>
<span class="cm"> *     to endorse or promote products derived from this software without</span>
<span class="cm"> *     specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>


<span class="cp">#include &quot;redis.h&quot;</span>

<span class="cp">#include &lt;sys/time.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;sys/socket.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>

<span class="kt">void</span> <span class="nf">replicationDiscardCachedMaster</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">replicationResurrectCachedMaster</span><span class="p">(</span><span class="kt">int</span> <span class="n">newfd</span><span class="p">);</span>

<span class="cm">/* ---------------------------------- MASTER -------------------------------- */</span>

<span class="c1">// 创建 backlog</span>
<span class="kt">void</span> <span class="nf">createReplicationBacklog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">redisAssert</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// backlog</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">);</span>
    <span class="c1">// 数据长度</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 索引值，增加数据时使用</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/* When a new backlog buffer is created, we increment the replication</span>
<span class="cm">     * offset by one to make sure we&#39;ll not be able to PSYNC with any</span>
<span class="cm">     * previous slave. This is needed because we avoid incrementing the</span>
<span class="cm">     * master_repl_offset if no backlog exists nor slaves are attached. */</span>
    <span class="c1">// 每次创建 backlog 时都将 master_repl_offset 增一</span>
    <span class="c1">// 这是为了防止之前使用过 backlog 的从服务器引发错误的 PSYNC 请求</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="o">++</span><span class="p">;</span>

    <span class="cm">/* We don&#39;t have any data inside our buffer, but virtually the first</span>
<span class="cm">     * byte we have is the next byte that will be generated for the</span>
<span class="cm">     * replication stream. */</span>
    <span class="c1">// 尽管没有任何数据，</span>
    <span class="c1">// 但 backlog 第一个字节的逻辑位置应该是 repl_offset 后的第一个字节</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function is called when the user modifies the replication backlog</span>
<span class="cm"> * size at runtime. It is up to the function to both update the</span>
<span class="cm"> * server.repl_backlog_size and to resize the buffer and setup it so that</span>
<span class="cm"> * it contains the same data as the previous one (possibly less data, but</span>
<span class="cm"> * the most recent bytes, or the same data and more free space in case the</span>
<span class="cm"> * buffer is enlarged). */</span>
<span class="c1">// 动态调整 backlog 大小</span>
<span class="c1">// 上面的注释说调整大小之后的 backlog 会保存调整前的数据，</span>
<span class="c1">// 但代码中的实现是不保留的</span>
<span class="kt">void</span> <span class="nf">resizeReplicationBacklog</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">newsize</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 不能小于最小大小</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&lt;</span> <span class="n">REDIS_REPL_BACKLOG_MIN_SIZE</span><span class="p">)</span>
        <span class="n">newsize</span> <span class="o">=</span> <span class="n">REDIS_REPL_BACKLOG_MIN_SIZE</span><span class="p">;</span>

    <span class="c1">// 大小和目前大小相等</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">==</span> <span class="n">newsize</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 设置新大小</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">=</span> <span class="n">newsize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* What we actually do is to flush the old buffer and realloc a new</span>
<span class="cm">         * empty one. It will refill with new data incrementally.</span>
<span class="cm">         * The reason is that copying a few gigabytes adds latency and even</span>
<span class="cm">         * worse often we need to alloc additional space before freeing the</span>
<span class="cm">         * old buffer. */</span>
        <span class="c1">// 释放 backlog</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span><span class="p">);</span>
        <span class="c1">// 按新大小创建新 backlog</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">);</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* Next byte we have is... the next since the buffer is emtpy. */</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 释放 backlog</span>
<span class="kt">void</span> <span class="nf">freeReplicationBacklog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add data to the replication backlog.</span>
<span class="cm"> * This function also increments the global replication offset stored at</span>
<span class="cm"> * server.master_repl_offset, because there is no case where we want to feed</span>
<span class="cm"> * the backlog without incrementing the buffer. </span>
<span class="cm"> *</span>
<span class="cm"> * 添加数据到复制 backlog ，</span>
<span class="cm"> * 并且按照添加内容的长度更新 server.master_repl_offset 偏移量。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">feedReplicationBacklog</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="c1">// 将长度累加到全局 offset 中</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

    <span class="cm">/* This is a circular buffer, so write as much data we can at every</span>
<span class="cm">     * iteration and rewind the &quot;idx&quot; index if we reach the limit. */</span>
    <span class="c1">// 环形 buffer ，每次写尽可能多的数据，并在到达尾部时将 idx 重置到头部</span>
    <span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 从 idx 到 backlog 尾部的字节数</span>
        <span class="kt">size_t</span> <span class="n">thislen</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span><span class="p">;</span>
        <span class="c1">// 如果 idx 到 backlog 尾部这段空间足以容纳要写入的内容</span>
        <span class="c1">// 那么直接将写入数据长度设为 len</span>
        <span class="c1">// 在将这些 len 字节复制之后，这个 while 循环将跳出</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">thislen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="n">thislen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="c1">// 将 p 中的 thislen 字节内容复制到 backlog</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span><span class="o">+</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">thislen</span><span class="p">);</span>
        <span class="c1">// 更新 idx ，指向新写入的数据之后</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="c1">// 如果写入达到尾部，那么将索引重置到头部</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">)</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// 减去已写入的字节数</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="c1">// 将指针移动到已被写入数据的后面，指向未被复制数据的开头</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="c1">// 增加实际长度</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// histlen 的最大值只能等于 backlog_size</span>
    <span class="c1">// 另外，当 histlen 大于 repl_backlog_size 时，</span>
    <span class="c1">// 表示写入数据的前头有一部分数据被自己的尾部覆盖了</span>
    <span class="c1">// 举个例子，例如 abcde 要写入到一个只有三个字节的环形数组中</span>
    <span class="c1">// 且假设索引为 0</span>
    <span class="c1">// 那么 abc 首先被写入，数组为 [a, b, c] </span>
    <span class="c1">// 然后 de 被写入，数组为 [d, e, c]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">)</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">;</span>
    <span class="cm">/* Set the offset of the first byte we have in the backlog. */</span>
    <span class="c1">// 记录程序可以依靠 backlog 来还原的数据的第一个字节的偏移量</span>
    <span class="c1">// 比如 master_repl_offset = 10086</span>
    <span class="c1">// repl_backlog_histlen = 30</span>
    <span class="c1">// 那么 backlog 所保存的数据的第一个字节的偏移量为</span>
    <span class="c1">// 10086 - 30 + 1 = 10056 + 1 = 10057</span>
    <span class="c1">// 这说明如果从服务器如果从 10057 至 10086 之间的任何时间断线</span>
    <span class="c1">// 那么从服务器都可以使用 PSYNC</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span> <span class="o">-</span>
                              <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wrapper for feedReplicationBacklog() that takes Redis string objects</span>
<span class="cm"> * as input. */</span>
<span class="c1">// 将 Redis 对象放进 replication backlog 里面</span>
<span class="kt">void</span> <span class="nf">feedReplicationBacklogWithObject</span><span class="p">(</span><span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">llstr</span><span class="p">[</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="p">];</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_INT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">llstr</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">llstr</span><span class="p">),(</span><span class="kt">long</span><span class="p">)</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">llstr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">feedReplicationBacklog</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define FEEDSLAVE_BUF_SIZE (1024*64)</span>
<span class="c1">// 将传入的参数发送给从服务器</span>
<span class="c1">// 操作分为三步：</span>
<span class="c1">// 1） 构建协议内容</span>
<span class="c1">// 2） 将协议内容备份到 backlog</span>
<span class="c1">// 3） 将内容发送给各个从服务器</span>
<span class="kt">void</span> <span class="nf">replicationFeedSlaves</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">slaves</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dictid</span><span class="p">,</span> <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">FEEDSLAVE_BUF_SIZE</span><span class="p">],</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">llstr</span><span class="p">[</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">buf_left</span> <span class="o">=</span> <span class="n">FEEDSLAVE_BUF_SIZE</span><span class="p">;</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

    <span class="cm">/* If there aren&#39;t slaves, and there is no backlog buffer to populate,</span>
<span class="cm">     * we can return ASAP. */</span>
    <span class="c1">// backlog 为空，且没有从服务器，直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">listLength</span><span class="p">(</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* We can&#39;t have slaves attached and no backlog. */</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">slaves</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">));</span>

    <span class="cm">/* What we do here is to try to write as much data as possible in a static</span>
<span class="cm">     * buffer &quot;buf&quot; that is used to create an object that is later sent to all</span>
<span class="cm">     * the slaves. This way we do the decoding only one time for most commands</span>
<span class="cm">     * not containing big payloads. */</span>
    <span class="c1">// 如果可能的话，将多个命令放在 buf 中，这样可以减少解码的次数</span>

    <span class="cm">/* Create the SELECT command into the static buffer if needed. */</span>
    <span class="c1">// 如果有需要，创建 SELECT 命令来指导附属服务器选择数据库</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaveseldb</span> <span class="o">!=</span> <span class="n">dictid</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">selectcmd</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">sclen</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dictid</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dictid</span> <span class="o">&lt;</span> <span class="n">REDIS_SHARED_SELECT_CMDS</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">selectcmd</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">select</span><span class="p">[</span><span class="n">dictid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
            <span class="n">sclen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">selectcmd</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">selectcmd</span><span class="p">,</span><span class="n">sclen</span><span class="p">);</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">sclen</span><span class="p">;</span>
            <span class="n">buf_left</span> <span class="o">-=</span> <span class="n">sclen</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">dictid_len</span><span class="p">;</span>

            <span class="n">dictid_len</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">llstr</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">llstr</span><span class="p">),</span><span class="n">dictid</span><span class="p">);</span>
            <span class="n">sclen</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">buf_left</span><span class="p">,</span><span class="s">&quot;*2</span><span class="se">\r\n</span><span class="s">$6</span><span class="se">\r\n</span><span class="s">SELECT</span><span class="se">\r\n</span><span class="s">$%d</span><span class="se">\r\n</span><span class="s">%s</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">dictid_len</span><span class="p">,</span> <span class="n">llstr</span><span class="p">);</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">sclen</span><span class="p">;</span>
            <span class="n">buf_left</span> <span class="o">-=</span> <span class="n">sclen</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">server</span><span class="p">.</span><span class="n">slaveseldb</span> <span class="o">=</span> <span class="n">dictid</span><span class="p">;</span>
   
    <span class="cm">/* Add the multi bulk reply size to the static buffer, that is, the number</span>
<span class="cm">     * of arguments of the command to send to every slave. */</span>
    <span class="c1">// 构建一个 multi bulk reply ，告知从服务器，将要发送的命令的参数数量</span>
    <span class="c1">// 也就是协议开头的 *&lt;len&gt;\r\n 部分</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;*&#39;</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="p">,</span><span class="n">argc</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">+=</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">buf_left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">buf_left</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="cm">/* Try to use the static buffer for as much arguments is possible. */</span>
    <span class="c1">// 将尽量多的参数放进缓冲区 b 里面</span>
    <span class="c1">// 这只是一个优化操作，没有什么特别的意思</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">objlen</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">objptr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">!=</span> <span class="n">REDIS_ENCODING_RAW</span> <span class="o">&amp;&amp;</span>
            <span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">!=</span> <span class="n">REDIS_ENCODING_INT</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisPanic</span><span class="p">(</span><span class="s">&quot;Unexpected encoding&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 计算参数的长度</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_RAW</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">objlen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="n">objptr</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">objlen</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">llstr</span><span class="p">,</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="n">objptr</span> <span class="o">=</span> <span class="n">llstr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* We need enough space for bulk reply encoding, newlines, and</span>
<span class="cm">         * the data itself. */</span>
        <span class="c1">// 如果缓冲区的容量不能满足接下来的这个参数，那么跳出</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf_left</span> <span class="o">&lt;</span> <span class="n">objlen</span><span class="o">+</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="o">+</span><span class="mi">32</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="cm">/* Write $...CRLF */</span>
        <span class="c1">// 构建协议格式的内容长度，例如 $3\r\n</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;$&#39;</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="p">,</span><span class="n">objlen</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">buf_left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">buf_left</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>

        <span class="cm">/* And data plus CRLF */</span>
        <span class="c1">// 构建协议格式的内容，例如 SET\r\n</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">objptr</span><span class="p">,</span><span class="n">objlen</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">objlen</span><span class="p">;</span>
        <span class="n">buf_left</span> <span class="o">-=</span> <span class="n">objlen</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">buf_left</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>

        <span class="c1">// 上面两个将组合成一个协议命令</span>
        <span class="c1">// 例如 $3\r\nSET\r\n</span>
    <span class="p">}</span>

    <span class="cm">/* Create an object with the static buffer content. */</span>
    <span class="c1">// 为内容创建一个对象</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">buf_left</span> <span class="o">&lt;</span> <span class="n">FEEDSLAVE_BUF_SIZE</span><span class="p">);</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">createStringObject</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">b</span><span class="o">-</span><span class="n">buf</span><span class="p">);</span>

    <span class="cm">/* If we have a backlog, populate it with data and increment</span>
<span class="cm">     * the global replication offset. */</span>
    <span class="c1">// 如果有 backlog ，那么将内容推入 backlog</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 将对象 o 推给 backlog</span>
        <span class="n">feedReplicationBacklogWithObject</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
        <span class="c1">// 将未能放进对象 o 里面的参数也推入 backlog</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">aux</span><span class="p">[</span><span class="n">REDIS_LONGSTR_SIZE</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
            <span class="kt">long</span> <span class="n">objlen</span> <span class="o">=</span> <span class="n">stringObjectLen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="cm">/* We need to feed the buffer with the object as a bulk reply</span>
<span class="cm">             * not just as a plain string, so create the $..CRLF payload len </span>
<span class="cm">             * ad add the final CRLF */</span>
            <span class="c1">// 将参数从对象转换成协议格式</span>
            <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;$&#39;</span><span class="p">;</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">ll2string</span><span class="p">(</span><span class="n">aux</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">objlen</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">aux</span><span class="p">[</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>
            <span class="n">aux</span><span class="p">[</span><span class="n">len</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
            <span class="n">feedReplicationBacklog</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">len</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
            <span class="n">feedReplicationBacklogWithObject</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">feedReplicationBacklogWithObject</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">crlf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Write data to slaves. Here we do two things:</span>
<span class="cm">     * 将数据写入到从服务器中，程序做以下两件事：</span>
<span class="cm">     *</span>
<span class="cm">     * 1) We write the &quot;o&quot; object that was created using the accumulated</span>
<span class="cm">     *    static buffer.</span>
<span class="cm">     *    将由静态缓冲区创建的对象 o 写入</span>
<span class="cm">     *</span>
<span class="cm">     * 2) We write any additional argument of the command to replicate that</span>
<span class="cm">     *    was not written inside the static buffer for lack of space.</span>
<span class="cm">     *    将因为空间不足而未被写入到 o 中的所有参数也写入</span>
<span class="cm">     */</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>

        <span class="c1">// 指向从服务器</span>
        <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

        <span class="cm">/* Don&#39;t feed slaves that are still waiting for BGSAVE to start */</span>
        <span class="c1">// 不要给正在等待 BGSAVE 开始的从服务器发送命令</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_START</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* Feed slaves that are waiting for the initial SYNC (so these commands</span>
<span class="cm">         * are queued in the output buffer until the initial SYNC completes),</span>
<span class="cm">         * or are already in sync with the master. */</span>
        <span class="c1">// 向已经接收完和正在接收 RDB 文件的从服务器发送命令</span>
        <span class="c1">// 如果从服务器正在接收主服务器发送的 RDB 文件，</span>
        <span class="c1">// 那么在初次 SYNC 完成之前，主服务器发送的内容会被放进一个缓冲区里面</span>

        <span class="cm">/* First, trasmit the object created from the static buffer. */</span>
        <span class="c1">// 发送对象 o</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span><span class="n">o</span><span class="p">);</span>

        <span class="cm">/* Finally any additional argument that was not stored inside the</span>
<span class="cm">         * static buffer if any (from j to argc). */</span>
        <span class="c1">// 发送对象</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">addReplyBulk</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">decrRefCount</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 将协议发给 Monitor</span>
<span class="kt">void</span> <span class="nf">replicationFeedMonitors</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">list</span> <span class="o">*</span><span class="n">monitors</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dictid</span><span class="p">,</span> <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdsnew</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">);</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">cmdobj</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">peerid</span><span class="p">[</span><span class="n">REDIS_PEER_ID_LEN</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

    <span class="c1">// 获取时间戳</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span><span class="s">&quot;%ld.%06ld &quot;</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_LUA_CLIENT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span><span class="s">&quot;[%d lua] &quot;</span><span class="p">,</span><span class="n">dictid</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_UNIX_SOCKET</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span><span class="s">&quot;[%d unix:%s] &quot;</span><span class="p">,</span><span class="n">dictid</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">unixsocket</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">getClientPeerId</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">peerid</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">peerid</span><span class="p">));</span>
        <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span><span class="s">&quot;[%d %s] &quot;</span><span class="p">,</span><span class="n">dictid</span><span class="p">,</span><span class="n">peerid</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 获取命令和参数</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_INT</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">%ld</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatrepr</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span>
                        <span class="n">sdslen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">argc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cmdrepr</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">cmdrepr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">cmdobj</span> <span class="o">=</span> <span class="n">createObject</span><span class="p">(</span><span class="n">REDIS_STRING</span><span class="p">,</span><span class="n">cmdrepr</span><span class="p">);</span>

    <span class="c1">// 将内容发送给所有 MONITOR </span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">monitors</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">redisClient</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span><span class="n">cmdobj</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">decrRefCount</span><span class="p">(</span><span class="n">cmdobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Feed the slave &#39;c&#39; with the replication backlog starting from the</span>
<span class="cm"> * specified &#39;offset&#39; up to the end of the backlog. */</span>
<span class="c1">// 向从服务器 c 发送 backlog 中从 offset 到 backlog 尾部之间的数据</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">addReplyReplicationBacklog</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Slave request offset: %lld&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Backlog history len is zero&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Backlog size: %lld&quot;</span><span class="p">,</span>
             <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">);</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] First byte: %lld&quot;</span><span class="p">,</span>
             <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span><span class="p">);</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] History len: %lld&quot;</span><span class="p">,</span>
             <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span><span class="p">);</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Current index: %lld&quot;</span><span class="p">,</span>
             <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span><span class="p">);</span>

    <span class="cm">/* Compute the amount of bytes we need to discard. */</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span><span class="p">;</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Skipping: %lld&quot;</span><span class="p">,</span> <span class="n">skip</span><span class="p">);</span>

    <span class="cm">/* Point j to the oldest byte, that is actaully our</span>
<span class="cm">     * server.repl_backlog_off byte. */</span>
    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_idx</span> <span class="o">+</span>
        <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span><span class="p">))</span> <span class="o">%</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">;</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Index of first byte: %lld&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

    <span class="cm">/* Discard the amount of data to seek to the specified &#39;offset&#39;. */</span>
    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">skip</span><span class="p">)</span> <span class="o">%</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">;</span>

    <span class="cm">/* Feed slave with data. Since it is a circular buffer we have to</span>
<span class="cm">     * split the reply in two parts if we are cross-boundary. */</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">-</span> <span class="n">skip</span><span class="p">;</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] Reply total length: %lld&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">thislen</span> <span class="o">=</span>
            <span class="p">((</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span>
            <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>

        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_DEBUG</span><span class="p">,</span> <span class="s">&quot;[PSYNC] addReply() length: %lld&quot;</span><span class="p">,</span> <span class="n">thislen</span><span class="p">);</span>
        <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sdsnewlen</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">thislen</span><span class="p">));</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_histlen</span> <span class="o">-</span> <span class="n">skip</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function handles the PSYNC command from the point of view of a</span>
<span class="cm"> * master receiving a request for partial resynchronization.</span>
<span class="cm"> *</span>
<span class="cm"> * On success return REDIS_OK, otherwise REDIS_ERR is returned and we proceed</span>
<span class="cm"> * with the usual full resync. */</span>
<span class="c1">// 尝试进行部分 resync ，成功返回 REDIS_OK ，失败返回 REDIS_ERR 。</span>
<span class="kt">int</span> <span class="nf">masterTryPartialResynchronization</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">psync_offset</span><span class="p">,</span> <span class="n">psync_len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">master_runid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">buflen</span><span class="p">;</span>

    <span class="cm">/* Is the runid of this master the same advertised by the wannabe slave</span>
<span class="cm">     * via PSYNC? If runid changed this master is a different instance and</span>
<span class="cm">     * there is no way to continue. */</span>
    <span class="c1">// 检查 master id 是否和 runid 一致，只有一致的情况下才有 PSYNC 的可能</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">master_runid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">runid</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Run id &quot;?&quot; is used by slaves that want to force a full resync. */</span>
        <span class="c1">// 从服务器提供的 run id 和服务器的 run id 不一致</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">master_runid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;?&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Partial resynchronization not accepted: &quot;</span>
                <span class="s">&quot;Runid mismatch (Client asked for &#39;%s&#39;, I&#39;m &#39;%s&#39;)&quot;</span><span class="p">,</span>
                <span class="n">master_runid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">runid</span><span class="p">);</span>
        <span class="c1">// 从服务器提供的 run id 为 &#39;?&#39; ，表示强制 FULL RESYNC</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Full resync requested by slave.&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 需要 full resync</span>
        <span class="k">goto</span> <span class="n">need_full_resync</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* We still have the data our slave is asking for? */</span>
    <span class="c1">// 取出 psync_offset 参数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getLongLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="o">&amp;</span><span class="n">psync_offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span>
       <span class="n">REDIS_OK</span><span class="p">)</span> <span class="k">goto</span> <span class="n">need_full_resync</span><span class="p">;</span>

        <span class="c1">// 如果没有 backlog</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">||</span>
        <span class="c1">// 或者 psync_offset 小于 server.repl_backlog_off</span>
        <span class="c1">// （想要恢复的那部分数据已经被覆盖）</span>
        <span class="n">psync_offset</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">||</span>
        <span class="c1">// 或者 psync_offset 大于 backlog 中可能保存的数据的偏移量</span>
        <span class="c1">// （这应该是出错情况）</span>
        <span class="n">psync_offset</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_off</span> <span class="o">+</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_size</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
            <span class="s">&quot;Unable to partial resync with the slave for lack of backlog (Slave request was: %lld).&quot;</span><span class="p">,</span> <span class="n">psync_offset</span><span class="p">);</span>
        <span class="c1">// 需要 full resync</span>
        <span class="k">goto</span> <span class="n">need_full_resync</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* If we reached this point, we are able to perform a partial resync:</span>
<span class="cm">     * 程序运行到这里，说明可以执行 partial resync</span>
<span class="cm">     *</span>
<span class="cm">     * 1) Set client state to make it a slave.</span>
<span class="cm">     *    将客户端状态设为 salve  </span>
<span class="cm">     *</span>
<span class="cm">     * 2) Inform the client we can continue with +CONTINUE</span>
<span class="cm">     *    向 slave 发送 +CONTINUE ，表示 partial resync 的请求被接受</span>
<span class="cm">     *</span>
<span class="cm">     * 3) Send the backlog data (from the offset to the end) to the slave. </span>
<span class="cm">     *    发送 backlog 中，客户端所需要的数据</span>
<span class="cm">     */</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_SLAVE</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_ONLINE</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_ack_time</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
    <span class="cm">/* We can&#39;t use the connection buffers since they are used to accumulate</span>
<span class="cm">     * new commands at this stage. But we are sure the socket send buffer is</span>
<span class="cm">     * emtpy so this write will never fail actually. */</span>
    <span class="c1">// 向从服务器发送一个同步 +CONTINUE ，表示 PSYNC 可以执行</span>
    <span class="n">buflen</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="s">&quot;+CONTINUE</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">buflen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 发送 backlog 中的内容（也即是从服务器缺失的那些内容）到从服务器</span>
    <span class="n">psync_len</span> <span class="o">=</span> <span class="n">addReplyReplicationBacklog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">psync_offset</span><span class="p">);</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
        <span class="s">&quot;Partial resynchronization request accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;</span><span class="p">,</span> <span class="n">psync_len</span><span class="p">,</span> <span class="n">psync_offset</span><span class="p">);</span>
    <span class="cm">/* Note that we don&#39;t need to set the selected DB at server.slaveseldb</span>
<span class="cm">     * to -1 to force the master to emit SELECT, since the slave already</span>
<span class="cm">     * has this state from the previous connection with the master. */</span>

    <span class="c1">// 刷新低延迟从服务器的数量</span>
    <span class="n">refreshGoodSlavesCount</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span> <span class="cm">/* The caller can return, no full resync needed. */</span>

<span class="nl">need_full_resync</span><span class="p">:</span>
    <span class="cm">/* We need a full resync for some reason... notify the client. */</span>
    <span class="c1">// 刷新 psync_offset</span>
    <span class="n">psync_offset</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master_repl_offset</span><span class="p">;</span>
    <span class="cm">/* Add 1 to psync_offset if it the replication backlog does not exists</span>
<span class="cm">     * as when it will be created later we&#39;ll increment the offset by one. */</span>
    <span class="c1">// 刷新 psync_offset</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">psync_offset</span><span class="o">++</span><span class="p">;</span>
    <span class="cm">/* Again, we can&#39;t use the connection buffers (see above). */</span>
    <span class="c1">// 发送 +FULLRESYNC ，表示需要完整重同步</span>
    <span class="n">buflen</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="s">&quot;+FULLRESYNC %s %lld</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span>
                      <span class="n">server</span><span class="p">.</span><span class="n">runid</span><span class="p">,</span><span class="n">psync_offset</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">buflen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">freeClientAsync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* SYNC ad PSYNC command implemenation. */</span>
<span class="kt">void</span> <span class="nf">syncCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* ignore SYNC if already slave or in monitor mode */</span>
    <span class="c1">// 已经是 SLAVE ，或者处于 MONITOR 模式，返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_SLAVE</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Refuse SYNC requests if we are a slave but the link with our master</span>
<span class="cm">     * is not ok... */</span>
    <span class="c1">// 如果这是一个从服务器，但于主服务器的连接仍未就绪，那么拒绝 SYNC</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">!=</span> <span class="n">REDIS_REPL_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Can&#39;t SYNC while not connected with my master&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* SYNC can&#39;t be issued when the server has pending data to send to</span>
<span class="cm">     * the client about already issued commands. We need a fresh reply</span>
<span class="cm">     * buffer registering the differences between the BGSAVE and the current</span>
<span class="cm">     * dataset, so that we can copy to other slaves if needed. */</span>
    <span class="c1">// 在客户端仍有输出数据等待输出，不能 SYNC</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reply</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bufpos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;SYNC and PSYNC are invalid with pending output&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Slave asks for synchronization&quot;</span><span class="p">);</span>

    <span class="cm">/* Try a partial resynchronization if this is a PSYNC command.</span>
<span class="cm">     * 如果这是一个 PSYNC 命令，那么尝试 partial resynchronization 。</span>
<span class="cm">     *</span>
<span class="cm">     * If it fails, we continue with usual full resynchronization, however</span>
<span class="cm">     * when this happens masterTryPartialResynchronization() already</span>
<span class="cm">     * replied with:</span>
<span class="cm">     *</span>
<span class="cm">     * 如果失败，那么使用 full resynchronization ，</span>
<span class="cm">     * 在这种情况下， masterTryPartialResynchronization() 返回以下内容：</span>
<span class="cm">     *</span>
<span class="cm">     * +FULLRESYNC &lt;runid&gt; &lt;offset&gt;</span>
<span class="cm">     *</span>
<span class="cm">     * So the slave knows the new runid and offset to try a PSYNC later</span>
<span class="cm">     * if the connection with the master is lost. </span>
<span class="cm">     *</span>
<span class="cm">     * 这样的话，之后如果主服务器断开，那么从服务器就可以尝试 PSYNC 了。</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;psync&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 尝试进行 PSYNC</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">masterTryPartialResynchronization</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 可执行 PSYNC</span>
            <span class="n">server</span><span class="p">.</span><span class="n">stat_sync_partial_ok</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span> <span class="cm">/* No full resync needed, return. */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 不可执行 PSYNC</span>
            <span class="kt">char</span> <span class="o">*</span><span class="n">master_runid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
            
            <span class="cm">/* Increment stats for failed PSYNCs, but only if the</span>
<span class="cm">             * runid is not &quot;?&quot;, as this is used by slaves to force a full</span>
<span class="cm">             * resync on purpose when they are not albe to partially</span>
<span class="cm">             * resync. */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">master_runid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;?&#39;</span><span class="p">)</span> <span class="n">server</span><span class="p">.</span><span class="n">stat_sync_partial_err</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* If a slave uses SYNC, we are dealing with an old implementation</span>
<span class="cm">         * of the replication protocol (like redis-cli --slave). Flag the client</span>
<span class="cm">         * so that we don&#39;t expect to receive REPLCONF ACK feedbacks. */</span>
        <span class="c1">// 旧版实现，设置标识，避免接收 REPLCONF ACK </span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_PRE_PSYNC_SLAVE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 以下是完整重同步的情况。。。</span>

    <span class="cm">/* Full resynchronization. */</span>
    <span class="c1">// 执行 full resynchronization ，增加计数</span>
    <span class="n">server</span><span class="p">.</span><span class="n">stat_sync_full</span><span class="o">++</span><span class="p">;</span>

    <span class="cm">/* Here we need to check if there is a background saving operation</span>
<span class="cm">     * in progress, or if it is required to start one */</span>
    <span class="c1">// 检查是否有 BGSAVE 在执行</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_child_pid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Ok a background save is in progress. Let&#39;s check if it is a good</span>
<span class="cm">         * one for replication, i.e. if there is another slave that is</span>
<span class="cm">         * registering differences since the server forked to save */</span>
        <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
        <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
        <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>

        <span class="c1">// 如果有至少一个 slave 在等待这个 BGSAVE 完成</span>
        <span class="c1">// 那么说明正在进行的 BGSAVE 所产生的 RDB 也可以为其他 slave 所用</span>
        <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
        <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_END</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ln</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Perfect, the server is already registering differences for</span>
<span class="cm">             * another slave. Set the right state, and copy the buffer. */</span>
            <span class="c1">// 幸运的情况，可以使用目前 BGSAVE 所生成的 RDB</span>
            <span class="n">copyClientOutputBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">slave</span><span class="p">);</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_END</span><span class="p">;</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Waiting for end of BGSAVE for SYNC&quot;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* No way, we need to wait for the next BGSAVE in order to</span>
<span class="cm">             * register differences */</span>
            <span class="c1">// 不好运的情况，必须等待下个 BGSAVE</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_START</span><span class="p">;</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Waiting for next BGSAVE for SYNC&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Ok we don&#39;t have a BGSAVE in progress, let&#39;s start one */</span>
        <span class="c1">// 没有 BGSAVE 在进行，开始一个新的 BGSAVE</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Starting BGSAVE for SYNC&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rdbSaveBackground</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_filename</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Replication failed, can&#39;t BGSAVE&quot;</span><span class="p">);</span>
            <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Unable to perform background save&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 设置状态</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_END</span><span class="p">;</span>
        <span class="cm">/* Flush the script cache for the new slave. */</span>
        <span class="c1">// 因为新 slave 进入，刷新复制脚本缓存</span>
        <span class="n">replicationScriptCacheFlush</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_disable_tcp_nodelay</span><span class="p">)</span>
        <span class="n">anetDisableTcpNoDelay</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span> <span class="cm">/* Non critical if it fails. */</span>

    <span class="n">c</span><span class="o">-&gt;</span><span class="n">repldbfd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_SLAVE</span><span class="p">;</span>

    <span class="n">server</span><span class="p">.</span><span class="n">slaveseldb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Force to re-emit the SELECT command. */</span>

    <span class="c1">// 添加到 slave 列表中</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
    <span class="c1">// 如果是第一个 slave ，那么初始化 backlog</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">createReplicationBacklog</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* REPLCONF &lt;option&gt; &lt;value&gt; &lt;option&gt; &lt;value&gt; ...</span>
<span class="cm"> * This command is used by a slave in order to configure the replication</span>
<span class="cm"> * process before starting it with the SYNC command.</span>
<span class="cm"> *</span>
<span class="cm"> * 由 slave 使用，在 SYNC 之前配置复制进程（process）</span>
<span class="cm"> *</span>
<span class="cm"> * Currently the only use of this command is to communicate to the master</span>
<span class="cm"> * what is the listening port of the Slave redis instance, so that the</span>
<span class="cm"> * master can accurately list slaves and their listening ports in</span>
<span class="cm"> * the INFO output.</span>
<span class="cm"> *</span>
<span class="cm"> * 目前这个函数的唯一作用就是，让 slave 告诉 master 它正在监听的端口号</span>
<span class="cm"> * 然后 master 就可以在 INFO 命令的输出中打印这个号码了。</span>
<span class="cm"> *</span>
<span class="cm"> * In the future the same command can be used in order to configure</span>
<span class="cm"> * the replication to initiate an incremental replication instead of a</span>
<span class="cm"> * full resync. </span>
<span class="cm"> *</span>
<span class="cm"> * 将来可能会用这个命令来实现增量式复制，取代 full resync 。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">replconfCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Number of arguments must be odd to make sure that every</span>
<span class="cm">         * option has a corresponding value. */</span>
        <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">syntaxerr</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Process every option-value pair. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 从服务器发来 REPLCONF listening-port &lt;port&gt; 命令</span>
        <span class="c1">// 主服务器将从服务器监听的端口号记录下来</span>
        <span class="c1">// 也即是 INFO replication 中的 slaveN ..., port = xxx 这一项</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;listening-port&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">long</span> <span class="n">port</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">getLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                    <span class="o">&amp;</span><span class="n">port</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">slave_listening_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

        <span class="c1">// 从服务器发来 REPLCONF ACK &lt;offset&gt; 命令</span>
        <span class="c1">// 告知主服务器，从服务器已处理的复制流的偏移量</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;ack&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* REPLCONF ACK is used by slave to inform the master the amount</span>
<span class="cm">             * of replication stream that it processed so far. It is an</span>
<span class="cm">             * internal only command that normal clients should never use. */</span>
            <span class="c1">// 从服务器使用 REPLCONF ACK 告知主服务器，</span>
            <span class="c1">// 从服务器目前已处理的复制流的偏移量</span>
            <span class="c1">// 主服务器更新它的记录值</span>
            <span class="c1">// 也即是 INFO replication 中的  slaveN ..., offset = xxx 这一项</span>
            <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_SLAVE</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">getLongLongFromObject</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="c1">// 如果 offset 已改变，那么更新</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_ack_off</span><span class="p">)</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_ack_off</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
            <span class="c1">// 更新最后一次发送 ack 的时间</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">repl_ack_time</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
            <span class="cm">/* Note: this command does not reply anything! */</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">addReplyErrorFormat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;Unrecognized REPLCONF option: %s&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// master 将 RDB 文件发送给 slave 的写事件处理器</span>
<span class="kt">void</span> <span class="nf">sendBulkToSlave</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">privdata</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">REDIS_IOBUF_LEN</span><span class="p">];</span>
    <span class="kt">ssize_t</span> <span class="n">nwritten</span><span class="p">,</span> <span class="n">buflen</span><span class="p">;</span>

    <span class="c1">// 在传送 RDB 文件之前，先发送文件的大小</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldboff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Write the bulk write count before to transfer the DB. In theory here</span>
<span class="cm">         * we don&#39;t know how much room there is in the output buffer of the</span>
<span class="cm">         * socket, but in practice SO_SNDLOWAT (the minimum count for output</span>
<span class="cm">         * operations) will never be smaller than the few bytes we need. */</span>
        <span class="n">sds</span> <span class="n">bulkcount</span><span class="p">;</span>

        <span class="n">bulkcount</span> <span class="o">=</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">sdsempty</span><span class="p">(),</span><span class="s">&quot;$%lld</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
            <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbsize</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">bulkcount</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">bulkcount</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">sdslen</span><span class="p">(</span><span class="n">bulkcount</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">sdsfree</span><span class="p">(</span><span class="n">bulkcount</span><span class="p">);</span>
            <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">bulkcount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 因为写入可能会份多次，异步地进行</span>
    <span class="c1">// 所以服务器使用 slave-&gt;repldboff 来记录每次写入的偏移量</span>
    <span class="c1">// 而在每次写入之前，需要根据这个偏移量来进行 lseek </span>
    <span class="c1">// 移动到上次未写完的地方，继续开始</span>
    <span class="n">lseek</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbfd</span><span class="p">,</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldboff</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">);</span>
    <span class="c1">// 读取 RDB 数据</span>
    <span class="n">buflen</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbfd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">REDIS_IOBUF_LEN</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Read error sending DB to slave: %s&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">buflen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;premature EOF&quot;</span> <span class="o">:</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 写入数据到 slave</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">nwritten</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">buflen</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_VERBOSE</span><span class="p">,</span><span class="s">&quot;Write error sending DB to slave: %s&quot;</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果写入成功，那么更新写入字节数到 repldboff ，等待下次继续写入</span>
    <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldboff</span> <span class="o">+=</span> <span class="n">nwritten</span><span class="p">;</span>

    <span class="c1">// 如果写入已经完成</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldboff</span> <span class="o">==</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbsize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 关闭 RDB 文件描述符</span>
        <span class="n">close</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbfd</span><span class="p">);</span>
        <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbfd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 删除之前绑定的写事件处理器</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">);</span>
        <span class="c1">// 将状态更新为 REDIS_REPL_ONLINE</span>
        <span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_ONLINE</span><span class="p">;</span>
        <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repl_ack_time</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
        <span class="c1">// 创建向从服务器发送命令的写事件处理器</span>
        <span class="c1">// 将保存并发送 RDB 期间的回复全部发送给从服务器</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_WRITABLE</span><span class="p">,</span>
            <span class="n">sendReplyToClient</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 刷新低延迟 slave 数量</span>
        <span class="n">refreshGoodSlavesCount</span><span class="p">();</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Synchronization with slave succeeded&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This function is called at the end of every background saving.</span>
<span class="cm"> * 在每次 BGSAVE 执行完毕之后使用</span>
<span class="cm"> *</span>
<span class="cm"> * The argument bgsaveerr is REDIS_OK if the background saving succeeded</span>
<span class="cm"> * otherwise REDIS_ERR is passed to the function.</span>
<span class="cm"> * bgsaveerr 可能是 REDIS_OK 或者 REDIS_ERR ，显示 BGSAVE 的执行结果</span>
<span class="cm"> *</span>
<span class="cm"> * The goal of this function is to handle slaves waiting for a successful</span>
<span class="cm"> * background saving in order to perform non-blocking synchronization. </span>
<span class="cm"> * </span>
<span class="cm"> * 这个函数是在 BGSAVE 完成之后的异步回调函数，</span>
<span class="cm"> * 它指导该怎么执行和 slave 相关的 RDB 下一步工作。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">updateSlavesWaitingBgsave</span><span class="p">(</span><span class="kt">int</span> <span class="n">bgsaveerr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">startbgsave</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>

    <span class="c1">// 遍历所有 slave</span>
    <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_START</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 之前的 RDB 文件不能被 slave 使用，</span>
            <span class="c1">// 开始新的 BGSAVE</span>
            <span class="n">startbgsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_END</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_END</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// 执行到这里，说明有 slave 在等待 BGSAVE 完成</span>

            <span class="k">struct</span> <span class="n">redis_stat</span> <span class="n">buf</span><span class="p">;</span>

            <span class="c1">// 但是 BGSAVE 执行错误</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bgsaveerr</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 释放 slave</span>
                <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;SYNC failed. BGSAVE child returned an error&quot;</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 打开 RDB 文件</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbfd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_filename</span><span class="p">,</span><span class="n">O_RDONLY</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
                <span class="n">redis_fstat</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbfd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;SYNC failed. Can&#39;t open/stat DB after BGSAVE: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 设置偏移量，各种值</span>
            <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldboff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repldbsize</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
            <span class="c1">// 更新状态</span>
            <span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">=</span> <span class="n">REDIS_REPL_SEND_BULK</span><span class="p">;</span>
            <span class="c1">// 清空之前的写事件处理器</span>
            <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">);</span>
            <span class="c1">// 将 sendBulkToSlave 安装为 slave 的写事件处理器</span>
            <span class="c1">// 它用于将 RDB 文件发送给 slave</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_WRITABLE</span><span class="p">,</span> <span class="n">sendBulkToSlave</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 需要为 slave 开始行的 BGSAVE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">startbgsave</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Since we are starting a new background save for one or more slaves,</span>
<span class="cm">         * we flush the Replication Script Cache to use EVAL to propagate every</span>
<span class="cm">         * new EVALSHA for the first time, since all the new slaves don&#39;t know</span>
<span class="cm">         * about previous scripts. */</span>
        <span class="c1">// 开始行的 BGSAVE ，并清空脚本缓存</span>
        <span class="n">replicationScriptCacheFlush</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rdbSaveBackground</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_filename</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>

            <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;SYNC failed. BGSAVE failed&quot;</span><span class="p">);</span>
            <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_START</span><span class="p">)</span>
                    <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ----------------------------------- SLAVE -------------------------------- */</span>

<span class="cm">/* Abort the async download of the bulk dataset while SYNC-ing with master */</span>
<span class="c1">// 停止下载 RDB 文件</span>
<span class="kt">void</span> <span class="nf">replicationAbortSyncTransfer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_TRANSFER</span><span class="p">);</span>

    <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_fd</span><span class="p">);</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_tmpfile</span><span class="p">);</span>
    <span class="n">zfree</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_tmpfile</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Asynchronously read the SYNC payload we receive from a master */</span>
<span class="c1">// 异步 RDB 文件读取函数</span>
<span class="cp">#define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) </span><span class="cm">/* 8 MB */</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">readSyncBulkPayload</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="n">readlen</span><span class="p">;</span>
    <span class="kt">off_t</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">privdata</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

    <span class="cm">/* If repl_transfer_size == -1 we still have to read the bulk length</span>
<span class="cm">     * from the master reply. */</span>
    <span class="c1">// 读取 RDB 文件的大小</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 调用读函数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syncReadLine</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="mi">1024</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">repl_syncio_timeout</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                <span class="s">&quot;I/O error reading bulk count from MASTER: %s&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 出错？</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                <span class="s">&quot;MASTER aborted replication with an error: %s&quot;</span><span class="p">,</span>
                <span class="n">buf</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* At this stage just a newline works as a PING in order to take</span>
<span class="cm">             * the connection live. So we refresh our last interaction</span>
<span class="cm">             * timestamp. */</span>
            <span class="c1">// 只接到了一个作用和 PING 一样的 &#39;\0&#39;</span>
            <span class="c1">// 更新最后互动时间</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_lastio</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 读入的内容出错，和协议格式不符</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Bad protocol from MASTER, the first byte is not &#39;$&#39; (we received &#39;%s&#39;), are you sure the host and port are right?&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 分析 RDB 文件大小</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_size</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
            <span class="s">&quot;MASTER &lt;-&gt; SLAVE sync: receiving %lld bytes from master&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_size</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Read bulk data */</span>
    <span class="c1">// 读数据</span>

    <span class="c1">// 还有多少字节要读？</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_size</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_read</span><span class="p">;</span>
    <span class="n">readlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">?</span> <span class="nl">left</span> <span class="p">:</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="c1">// 读取</span>
    <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">readlen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;I/O error trying to sync with MASTER: %s&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;connection lost&quot;</span><span class="p">);</span>
        <span class="n">replicationAbortSyncTransfer</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 更新最后 RDB 产生的 IO 时间</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_lastio</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">nread</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nread</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; SLAVE synchronization: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 加上刚读取好的字节数</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_read</span> <span class="o">+=</span> <span class="n">nread</span><span class="p">;</span>

    <span class="cm">/* Sync data on disk from time to time, otherwise at the end of the transfer</span>
<span class="cm">     * we may suffer a big delay as the memory buffers are copied into the</span>
<span class="cm">     * actual disk. */</span>
    <span class="c1">// 定期将读入的文件 fsync 到磁盘，以免 buffer 太多，一下子写入时撑爆 IO</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_read</span> <span class="o">&gt;=</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_last_fsync_off</span> <span class="o">+</span> <span class="n">REPL_MAX_WRITTEN_BEFORE_FSYNC</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">off_t</span> <span class="n">sync_size</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_read</span> <span class="o">-</span>
                          <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_last_fsync_off</span><span class="p">;</span>
        <span class="n">rdb_fsync_range</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_fd</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_last_fsync_off</span><span class="p">,</span> <span class="n">sync_size</span><span class="p">);</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_last_fsync_off</span> <span class="o">+=</span> <span class="n">sync_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check if the transfer is now complete */</span>
    <span class="c1">// 检查 RDB 是否已经传送完毕</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_read</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_size</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 完毕，将临时文件改名为 dump.rdb</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rename</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_tmpfile</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_filename</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; SLAVE synchronization: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="n">replicationAbortSyncTransfer</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 开始载入 RDB 文件到内存</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span> <span class="s">&quot;MASTER &lt;-&gt; SLAVE sync: Loading DB in memory&quot;</span><span class="p">);</span>
        <span class="n">signalFlushedDb</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 先清空旧数据库</span>
        <span class="n">emptyDb</span><span class="p">();</span>
        <span class="cm">/* Before loading the DB into memory we need to delete the readable</span>
<span class="cm">         * handler, otherwise it will get called recursively since</span>
<span class="cm">         * rdbLoad() will call the event loop to process events from time to</span>
<span class="cm">         * time for non blocking loading. */</span>
        <span class="c1">// 先删除主服务器的读事件监听，因为 rdbLoad() 函数也会监听读事件</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">);</span>
        <span class="c1">// 载入</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rdbLoad</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_filename</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Failed trying to load the MASTER synchronization DB from disk&quot;</span><span class="p">);</span>
            <span class="n">replicationAbortSyncTransfer</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Final setup of the connected slave &lt;- master link */</span>
        <span class="c1">// 关闭临时文件</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_tmpfile</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_fd</span><span class="p">);</span>

        <span class="c1">// 将主服务器设置成一个 redis client</span>
        <span class="c1">// 注意 createClient 会为主服务器绑定事件，为接下来接收命令做好准备</span>
        <span class="n">server</span><span class="p">.</span><span class="n">master</span> <span class="o">=</span> <span class="n">createClient</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span><span class="p">);</span>
        <span class="c1">// 标记这个客户端为主服务器</span>
        <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_MASTER</span><span class="p">;</span>
        <span class="c1">// 标记它为已验证身份</span>
        <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">authenticated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 更新复制状态</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECTED</span><span class="p">;</span>
        <span class="c1">// 设置主服务器的复制偏移量</span>
        <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">reploff</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_master_initial_offset</span><span class="p">;</span>
        <span class="c1">// 保存主服务器的 RUN ID</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">replrunid</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_master_runid</span><span class="p">,</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_master_runid</span><span class="p">));</span>

        <span class="c1">// 连接完成</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span> <span class="s">&quot;MASTER &lt;-&gt; SLAVE sync: Finished with success&quot;</span><span class="p">);</span>

        <span class="cm">/* Restart the AOF subsystem now that we finished the sync. This</span>
<span class="cm">         * will trigger an AOF rewrite, and when done will start appending</span>
<span class="cm">         * to the new file. */</span>
        <span class="c1">// 如果有开启 AOF 持久化，那么重启 AOF 功能，并强制生成新数据库的 AOF 文件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">aof_state</span> <span class="o">!=</span> <span class="n">REDIS_AOF_OFF</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">retry</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

            <span class="c1">// 关闭</span>
            <span class="n">stopAppendOnly</span><span class="p">();</span>
            <span class="c1">// 再重启</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">retry</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">startAppendOnly</span><span class="p">()</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Failed enabling the AOF after successful master synchronization! Trying it again in one second.&quot;</span><span class="p">);</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;FATAL: this slave instance finished the synchronization with its master, but the AOF can&#39;t be turned on. Exiting now.&quot;</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">;</span>

<span class="nl">error</span><span class="p">:</span>
    <span class="n">replicationAbortSyncTransfer</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send a synchronous command to the master. Used to send AUTH and</span>
<span class="cm"> * REPLCONF commands before starting the replication with SYNC.</span>
<span class="cm"> *</span>
<span class="cm"> * The command returns an sds string representing the result of the</span>
<span class="cm"> * operation. On error the first byte is a &quot;-&quot;.</span>
<span class="cm"> */</span>
<span class="c1">// Redis 通常情况下是将命令的发送和回复用不同的事件处理器来异步处理的</span>
<span class="c1">// 但这里是同步地发送然后读取</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">sendSynchronousCommand</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="cm">/* Create the command to send to the master, we use simple inline</span>
<span class="cm">     * protocol for simplicity as currently we only send simple strings. */</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">sdscat</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="n">arg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

    <span class="cm">/* Transfer command to the server. */</span>
    <span class="c1">// 发送命令到主服务器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">syncWrite</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">cmd</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span><span class="n">server</span><span class="p">.</span><span class="n">repl_syncio_timeout</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">sdsempty</span><span class="p">(),</span><span class="s">&quot;-Writing to master: %s&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

    <span class="cm">/* Read the reply from the server. */</span>
    <span class="c1">// 从主服务器中读取回复</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">syncReadLine</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="n">server</span><span class="p">.</span><span class="n">repl_syncio_timeout</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">sdscatprintf</span><span class="p">(</span><span class="n">sdsempty</span><span class="p">(),</span><span class="s">&quot;-Reading from master: %s&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sdsnew</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Try a partial resynchronization with the master if we are about to reconnect.</span>
<span class="cm"> *</span>
<span class="cm"> * 在重连接之后，尝试进行部分重同步。</span>
<span class="cm"> *</span>
<span class="cm"> * If there is no cached master structure, at least try to issue a</span>
<span class="cm"> * &quot;PSYNC ? -1&quot; command in order to trigger a full resync using the PSYNC</span>
<span class="cm"> * command in order to obtain the master run id and the master replication</span>
<span class="cm"> * global offset.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果 master 缓存为空，那么通过 &quot;PSYNC ? -1&quot; 命令来触发一次 full resync ，</span>
<span class="cm"> * 让主服务器的 run id 和复制偏移量可以传到附属节点里面。</span>
<span class="cm"> *</span>
<span class="cm"> * This function is designed to be called from syncWithMaster(), so the</span>
<span class="cm"> * following assumptions are made:</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数由 syncWithMaster() 函数调用，它做了以下假设：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) We pass the function an already connected socket &quot;fd&quot;.</span>
<span class="cm"> *    一个已连接套接字 fd 会被传入函数</span>
<span class="cm"> * 2) This function does not close the file descriptor &quot;fd&quot;. However in case</span>
<span class="cm"> *    of successful partial resynchronization, the function will reuse</span>
<span class="cm"> *    &#39;fd&#39; as file descriptor of the server.master client structure.</span>
<span class="cm"> *    函数不会关闭 fd 。</span>
<span class="cm"> *    当部分同步成功时，函数会将 fd 用作 server.master 客户端结构中的</span>
<span class="cm"> *    文件描述符。</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns:</span>
<span class="cm"> * 以下是函数的返回值：</span>
<span class="cm"> *</span>
<span class="cm"> * PSYNC_CONTINUE: If the PSYNC command succeded and we can continue.</span>
<span class="cm"> *                 PSYNC 命令成功，可以继续。</span>
<span class="cm"> * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.</span>
<span class="cm"> *                   In this case the master run_id and global replication</span>
<span class="cm"> *                   offset is saved.</span>
<span class="cm"> *                   主服务器支持 PSYNC 功能，但目前情况需要执行 full resync 。</span>
<span class="cm"> *                   在这种情况下， run_id 和全局复制偏移量会被保存。</span>
<span class="cm"> * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and</span>
<span class="cm"> *                      the caller should fall back to SYNC.</span>
<span class="cm"> *                      主服务器不支持 PSYNC ，调用者应该下降到 SYNC 命令。</span>
<span class="cm"> */</span>

<span class="cp">#define PSYNC_CONTINUE 0</span>
<span class="cp">#define PSYNC_FULLRESYNC 1</span>
<span class="cp">#define PSYNC_NOT_SUPPORTED 2</span>
<span class="kt">int</span> <span class="nf">slaveTryPartialResynchronization</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">psync_runid</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">psync_offset</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="n">sds</span> <span class="n">reply</span><span class="p">;</span>

    <span class="cm">/* Initially set repl_master_initial_offset to -1 to mark the current</span>
<span class="cm">     * master run_id and offset as not valid. Later if we&#39;ll be able to do</span>
<span class="cm">     * a FULL resync using the PSYNC command we&#39;ll set the offset at the</span>
<span class="cm">     * right value, so that this information will be propagated to the</span>
<span class="cm">     * client structure representing the master into server.master. */</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_master_initial_offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 缓存存在，尝试部分重同步</span>
        <span class="c1">// 命令为 &quot;PSYNC &lt;master_run_id&gt; &lt;repl_offset&gt;&quot;</span>
        <span class="n">psync_runid</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">replrunid</span><span class="p">;</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">),</span><span class="s">&quot;%lld&quot;</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">reploff</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Trying a partial resynchronization (request %s:%s).&quot;</span><span class="p">,</span> <span class="n">psync_runid</span><span class="p">,</span> <span class="n">psync_offset</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 缓存不存在</span>
        <span class="c1">// 发送 &quot;PSYNC ? -1&quot; ，要求完整重同步</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Partial resynchronization not possible (no cached master)&quot;</span><span class="p">);</span>
        <span class="n">psync_runid</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">psync_offset</span><span class="p">,</span><span class="s">&quot;-1&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Issue the PSYNC command */</span>
    <span class="c1">// 向主服务器发送 PSYNC 命令</span>
    <span class="n">reply</span> <span class="o">=</span> <span class="n">sendSynchronousCommand</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="s">&quot;PSYNC&quot;</span><span class="p">,</span><span class="n">psync_runid</span><span class="p">,</span><span class="n">psync_offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 接收到 FULLRESYNC ，进行 full-resync</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="s">&quot;+FULLRESYNC&quot;</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">runid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/* FULL RESYNC, parse the reply in order to extract the run id</span>
<span class="cm">         * and the replication offset. */</span>
        <span class="c1">// 分析并记录主服务器的 run id</span>
        <span class="n">runid</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">runid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">runid</span><span class="o">++</span><span class="p">;</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">runid</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="n">offset</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 检查 run id 的合法性</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">runid</span> <span class="o">||</span> <span class="o">!</span><span class="n">offset</span> <span class="o">||</span> <span class="p">(</span><span class="n">offset</span><span class="o">-</span><span class="n">runid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_RUN_ID_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                <span class="s">&quot;Master replied with wrong +FULLRESYNC syntax.&quot;</span><span class="p">);</span>
            <span class="cm">/* This is an unexpected condition, actually the +FULLRESYNC</span>
<span class="cm">             * reply means that the master supports PSYNC, but the reply</span>
<span class="cm">             * format seems wrong. To stay safe we blank the master</span>
<span class="cm">             * runid to make sure next PSYNCs will fail. */</span>
            <span class="c1">// 主服务器支持 PSYNC ，但是却发来了异常的 run id</span>
            <span class="c1">// 只好将 run id 设为 0 ，让下次 PSYNC 时失败</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_master_runid</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">REDIS_RUN_ID_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 保存 run id</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_master_runid</span><span class="p">,</span> <span class="n">runid</span><span class="p">,</span> <span class="n">offset</span><span class="o">-</span><span class="n">runid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_master_runid</span><span class="p">[</span><span class="n">REDIS_RUN_ID_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
            <span class="c1">// 以及 initial offset</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_master_initial_offset</span> <span class="o">=</span> <span class="n">strtoll</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
            <span class="c1">// 打印日志，这是一个 FULL resync</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Full resync from master: %s:%lld&quot;</span><span class="p">,</span>
                <span class="n">server</span><span class="p">.</span><span class="n">repl_master_runid</span><span class="p">,</span>
                <span class="n">server</span><span class="p">.</span><span class="n">repl_master_initial_offset</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* We are going to full resync, discard the cached master structure. */</span>
        <span class="c1">// 要开始完整重同步，缓存中的 master 已经没用了，清除它</span>
        <span class="n">replicationDiscardCachedMaster</span><span class="p">();</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
        
        <span class="c1">// 返回状态</span>
        <span class="k">return</span> <span class="n">PSYNC_FULLRESYNC</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 接收到 CONTINUE ，进行 partial resync</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="s">&quot;+CONTINUE&quot;</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Partial resync was accepted, set the replication state accordingly */</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
            <span class="s">&quot;Successful partial resynchronization with master.&quot;</span><span class="p">);</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
        <span class="c1">// 将缓存中的 master 设为当前 master</span>
        <span class="n">replicationResurrectCachedMaster</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

        <span class="c1">// 返回状态</span>
        <span class="k">return</span> <span class="n">PSYNC_CONTINUE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* If we reach this point we receied either an error since the master does</span>
<span class="cm">     * not understand PSYNC, or an unexpected reply from the master.</span>
<span class="cm">     * Reply with PSYNC_NOT_SUPPORTED in both cases. */</span>

    <span class="c1">// 接收到错误？</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span><span class="s">&quot;-ERR&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* If it&#39;s not an error, log the unexpected event. */</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
            <span class="s">&quot;Unexpected reply to PSYNC from master: %s&quot;</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
            <span class="s">&quot;Master does not support PSYNC or is in &quot;</span>
            <span class="s">&quot;error state (reply: %s)&quot;</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
    <span class="n">replicationDiscardCachedMaster</span><span class="p">();</span>

    <span class="c1">// 主服务器不支持 PSYNC</span>
    <span class="k">return</span> <span class="n">PSYNC_NOT_SUPPORTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 从服务器用于同步主服务器的回调函数</span>
<span class="kt">void</span> <span class="nf">syncWithMaster</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">el</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">tmpfile</span><span class="p">[</span><span class="mi">256</span><span class="p">],</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="n">maxtries</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sockerr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">psync_result</span><span class="p">;</span>
    <span class="kt">socklen_t</span> <span class="n">errlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sockerr</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">el</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">privdata</span><span class="p">);</span>
    <span class="n">REDIS_NOTUSED</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

    <span class="cm">/* If this event fired after the user turned the instance into a master</span>
<span class="cm">     * with SLAVEOF NO ONE we must just return ASAP. */</span>
    <span class="c1">// 如果处于 SLAVEOF NO ONE 模式，那么关闭 fd</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_NONE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check for errors in the socket. */</span>
    <span class="c1">// 检查套接字错误</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sockerr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">errlen</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sockerr</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sockerr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="o">|</span><span class="n">AE_WRITABLE</span><span class="p">);</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Error condition on socket for SYNC: %s&quot;</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">sockerr</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* If we were connecting, it&#39;s time to send a non blocking PING, we want to</span>
<span class="cm">     * make sure the master is able to reply before going into the actual</span>
<span class="cm">     * replication process where we have long timeouts in the order of</span>
<span class="cm">     * seconds (in the meantime the slave would block). */</span>
    <span class="c1">// 如果状态为 CONNECTING ，那么在进行初次同步之前，</span>
    <span class="c1">// 向主服务器发送一个非阻塞的 PONG </span>
    <span class="c1">// 因为接下来的 RDB 文件发送非常耗时，所以我们想确认主服务器真的能访问</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECTING</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Non blocking connect for SYNC fired the event.&quot;</span><span class="p">);</span>
        <span class="cm">/* Delete the writable event so that the readable event remains</span>
<span class="cm">         * registered and we can wait for the PONG reply. */</span>
        <span class="c1">// 手动发送同步 PING ，暂时取消监听写事件</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">);</span>
        <span class="c1">// 更新状态</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_RECEIVE_PONG</span><span class="p">;</span>
        <span class="cm">/* Send the PING, don&#39;t check for errors at all, we have the timeout</span>
<span class="cm">         * that will take care about this. */</span>
        <span class="c1">// 同步发送 PING</span>
        <span class="n">syncWrite</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="s">&quot;PING</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>

        <span class="c1">// 返回，等待 PONG 到达</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Receive the PONG command. */</span>
    <span class="c1">// 接收 PONG 命令</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_RECEIVE_PONG</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

        <span class="cm">/* Delete the readable event, we no longer need it now that there is</span>
<span class="cm">         * the PING reply to read. */</span>
        <span class="c1">// 手动同步接收 PONG ，暂时取消监听读事件</span>
        <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">);</span>

        <span class="cm">/* Read the reply with explicit timeout. */</span>
        <span class="c1">// 尝试在指定时间限制内读取 PONG</span>
        <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="c1">// 同步接收 PONG</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syncReadLine</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
            <span class="n">server</span><span class="p">.</span><span class="n">repl_syncio_timeout</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                <span class="s">&quot;I/O error reading PING reply from master: %s&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* We accept only two replies as valid, a positive +PONG reply</span>
<span class="cm">         * (we just check for &quot;+&quot;) or an authentication error.</span>
<span class="cm">         * Note that older versions of Redis replied with &quot;operation not</span>
<span class="cm">         * permitted&quot; instead of using a proper error code, so we test</span>
<span class="cm">         * both. */</span>
        <span class="c1">// 接收到的数据只有两种可能：</span>
        <span class="c1">// 第一种是 +PONG ，第二种是因为未验证而出现的 -NOAUTH 错误</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;+&#39;</span> <span class="o">&amp;&amp;</span>
            <span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">&quot;-NOAUTH&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">&quot;-ERR operation not permitted&quot;</span><span class="p">,</span><span class="mi">28</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 接收到未验证错误</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Error reply to PING from master: &#39;%s&#39;&quot;</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 接收到 PONG</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
                <span class="s">&quot;Master replied to PING, replication can continue...&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* AUTH with the master if required. */</span>
    <span class="c1">// 进行身份验证</span>
    <span class="k">if</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterauth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">sendSynchronousCommand</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="s">&quot;AUTH&quot;</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">masterauth</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Unable to AUTH to MASTER: %s&quot;</span><span class="p">,</span><span class="n">err</span><span class="p">);</span>
            <span class="n">sdsfree</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Set the slave port, so that Master&#39;s INFO command can list the</span>
<span class="cm">     * slave listening port correctly. */</span>
    <span class="c1">// 将从服务器的端口发送给主服务器，</span>
    <span class="c1">// 使得主服务器的 INFO 命令可以显示从服务器正在监听的端口</span>
    <span class="p">{</span>
        <span class="n">sds</span> <span class="n">port</span> <span class="o">=</span> <span class="n">sdsfromlonglong</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="p">);</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">sendSynchronousCommand</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="s">&quot;REPLCONF&quot;</span><span class="p">,</span><span class="s">&quot;listening-port&quot;</span><span class="p">,</span><span class="n">port</span><span class="p">,</span>
                                         <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
        <span class="cm">/* Ignore the error if any, not all the Redis versions support</span>
<span class="cm">         * REPLCONF listening-port. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;(Non critical) Master does not understand REPLCONF listening-port: %s&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">sdsfree</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Try a partial resynchonization. If we don&#39;t have a cached master</span>
<span class="cm">     * slaveTryPartialResynchronization() will at least try to use PSYNC</span>
<span class="cm">     * to start a full resynchronization so that we get the master run id</span>
<span class="cm">     * and the global offset, to try a partial resync at the next</span>
<span class="cm">     * reconnection attempt. */</span>
    <span class="c1">// 根据返回的结果决定是执行部分 resync ，还是 full-resync</span>
    <span class="n">psync_result</span> <span class="o">=</span> <span class="n">slaveTryPartialResynchronization</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="c1">// 可以执行部分 resync</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">psync_result</span> <span class="o">==</span> <span class="n">PSYNC_CONTINUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span> <span class="s">&quot;MASTER &lt;-&gt; SLAVE sync: Master accepted a Partial Resynchronization.&quot;</span><span class="p">);</span>
        <span class="c1">// 返回</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC</span>
<span class="cm">     * and the server.repl_master_runid and repl_master_initial_offset are</span>
<span class="cm">     * already populated. */</span>
    <span class="c1">// 主服务器不支持 PSYNC ，发送 SYNC</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">psync_result</span> <span class="o">==</span> <span class="n">PSYNC_NOT_SUPPORTED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Retrying with SYNC...&quot;</span><span class="p">);</span>
        <span class="c1">// 向主服务器发送 SYNC 命令</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syncWrite</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="s">&quot;SYNC</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">repl_syncio_timeout</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;I/O error writing to MASTER: %s&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
            <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 如果执行到这里，</span>
    <span class="c1">// 那么 psync_result == PSYNC_FULLRESYNC 或 PSYNC_NOT_SUPPORTED</span>

    <span class="cm">/* Prepare a suitable temp file for bulk transfer */</span>
    <span class="c1">// 打开一个临时文件，用于写入和保存接下来从主服务器传来的 RDB 文件数据</span>
    <span class="k">while</span><span class="p">(</span><span class="n">maxtries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span>
            <span class="s">&quot;temp-%d.%ld.rdb&quot;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">,(</span><span class="kt">long</span> <span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
        <span class="n">dfd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">,</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_EXCL</span><span class="p">,</span><span class="mo">0644</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Opening the temp file needed for MASTER &lt;-&gt; SLAVE synchronization: %s&quot;</span><span class="p">,</span><span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Setup the non blocking download of the bulk file. */</span>
    <span class="c1">// 设置一个读事件处理器，来读取主服务器的 RDB 文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span> <span class="n">AE_READABLE</span><span class="p">,</span><span class="n">readSyncBulkPayload</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="o">==</span> <span class="n">AE_ERR</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
            <span class="s">&quot;Can&#39;t create readable event for SYNC: %s (fd=%d)&quot;</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">),</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 设置状态</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_TRANSFER</span><span class="p">;</span>

    <span class="c1">// 更新统计信息</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_last_fsync_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_fd</span> <span class="o">=</span> <span class="n">dfd</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_lastio</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_tmpfile</span> <span class="o">=</span> <span class="n">zstrdup</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>

<span class="nl">error</span><span class="p">:</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECT</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 以非阻塞方式连接主服务器</span>
<span class="kt">int</span> <span class="nf">connectWithMaster</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="c1">// 连接主服务器</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">anetTcpNonBlockConnect</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">masterport</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Unable to connect to MASTER: %s&quot;</span><span class="p">,</span>
            <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 监听主服务器 fd 的读和写事件，并绑定文件事件处理器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="o">|</span><span class="n">AE_WRITABLE</span><span class="p">,</span><span class="n">syncWithMaster</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span>
            <span class="n">AE_ERR</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Can&#39;t create readable event for SYNC&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 初始化统计变量</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_lastio</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>

    <span class="c1">// 将状态改为已连接</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECTING</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function can be called when a non blocking connection is currently</span>
<span class="cm"> * in progress to undo it. */</span>
<span class="c1">// 取消正在进行的连接</span>
<span class="kt">void</span> <span class="nf">undoConnectWithMaster</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span><span class="p">;</span>

    <span class="c1">// 连接必须处于正在连接状态</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECTING</span> <span class="o">||</span>
                <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_RECEIVE_PONG</span><span class="p">);</span>
    <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="o">|</span><span class="n">AE_WRITABLE</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 回到 CONNECT 状态</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function aborts a non blocking replication attempt if there is one</span>
<span class="cm"> * in progress, by canceling the non-blocking connect attempt or</span>
<span class="cm"> * the initial bulk transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果有正在进行的非阻塞复制在进行，那么取消它。</span>
<span class="cm"> *</span>
<span class="cm"> * If there was a replication handshake in progress 1 is returned and</span>
<span class="cm"> * the replication state (server.repl_state) set to REDIS_REPL_CONNECT.</span>
<span class="cm"> *</span>
<span class="cm"> * 如果复制在握手阶段被取消，那么返回 1 ，</span>
<span class="cm"> * 并且 server.repl_state 被设置为 REDIS_REPL_CONNECT 。</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise zero is returned and no operation is perforemd at all. </span>
<span class="cm"> *</span>
<span class="cm"> * 否则返回 0 ，并且不执行任何操作。</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cancelReplicationHandshake</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_TRANSFER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">replicationAbortSyncTransfer</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECTING</span> <span class="o">||</span>
             <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_RECEIVE_PONG</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">undoConnectWithMaster</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set replication to the specified master address and port. */</span>
<span class="c1">// 将服务器设为指定地址的从服务器</span>
<span class="kt">void</span> <span class="nf">replicationSetMaster</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 清除原有的主服务器地址（如果有的话）</span>
    <span class="n">sdsfree</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span><span class="p">);</span>

    <span class="c1">// IP</span>
    <span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">=</span> <span class="n">sdsnew</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

    <span class="c1">// 端口</span>
    <span class="n">server</span><span class="p">.</span><span class="n">masterport</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

    <span class="c1">// 清除原来可能有的主服务器信息。。。</span>

    <span class="c1">// 如果之前有其他地址，那么释放它</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">)</span> <span class="n">freeClient</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">);</span>
    <span class="c1">// 断开所有从服务器的连接，强制所有从服务器执行重同步</span>
    <span class="n">disconnectSlaves</span><span class="p">();</span> <span class="cm">/* Force our slaves to resync with us as well. */</span>
    <span class="c1">// 清空可能有的 master 缓存，因为已经不会执行 PSYNC 了</span>
    <span class="n">replicationDiscardCachedMaster</span><span class="p">();</span> <span class="cm">/* Don&#39;t try a PSYNC. */</span>
    <span class="c1">// 释放 backlog ，同理， PSYNC 目前已经不会执行了</span>
    <span class="n">freeReplicationBacklog</span><span class="p">();</span> <span class="cm">/* Don&#39;t allow our chained slaves to PSYNC. */</span>
    <span class="c1">// 取消之前的复制进程（如果有的话）</span>
    <span class="n">cancelReplicationHandshake</span><span class="p">();</span>

    <span class="c1">// 进入连接状态（重点）</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Cancel replication, setting the instance as a master itself. */</span>
<span class="c1">// 取消复制，将服务器设置为主服务器</span>
<span class="kt">void</span> <span class="nf">replicationUnsetMaster</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="cm">/* Nothing to do. */</span>

    <span class="n">sdsfree</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">)</span> <span class="n">freeClient</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">);</span>

    <span class="n">replicationDiscardCachedMaster</span><span class="p">();</span>

    <span class="n">cancelReplicationHandshake</span><span class="p">();</span>

    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">slaveofCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* SLAVEOF is not allowed in cluster mode as replication is automatically</span>
<span class="cm">     * configured using the current address of the master node. */</span>
    <span class="c1">// 不允许在集群模式中使用</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster_enabled</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addReplyError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;SLAVEOF not allowed in cluster mode.&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* The special host/port combination &quot;NO&quot; &quot;ONE&quot; turns the instance</span>
<span class="cm">     * into a master. Otherwise the new master address is set. */</span>
    <span class="c1">// SLAVEOF NO ONE 让从服务器转为主服务器</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;no&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 让服务器取消复制，成为主服务器</span>
            <span class="n">replicationUnsetMaster</span><span class="p">();</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;MASTER MODE enabled (user request)&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">port</span><span class="p">;</span>

        <span class="c1">// 获取端口参数</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">getLongFromObjectOrReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="cm">/* Check if we are already attached to the specified slave */</span>
        <span class="c1">// 检查输入的 host 和 port 是否服务器目前的主服务器</span>
        <span class="c1">// 如果是的话，向客户端返回 +OK ，不做其他动作</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span>
            <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">masterport</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.&quot;</span><span class="p">);</span>
            <span class="n">addReplySds</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">sdsnew</span><span class="p">(</span><span class="s">&quot;+OK Already connected to specified master</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">));</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* There was no previous master or the user specified a different one,</span>
<span class="cm">         * we can continue. */</span>
        <span class="c1">// 没有前任主服务器，或者客户端指定了新的主服务器</span>
        <span class="c1">// 开始执行复制操作</span>
        <span class="n">replicationSetMaster</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;SLAVE OF %s:%d enabled (user request)&quot;</span><span class="p">,</span>
            <span class="n">server</span><span class="p">.</span><span class="n">masterhost</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">masterport</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">addReply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">shared</span><span class="p">.</span><span class="n">ok</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a REPLCONF ACK command to the master to inform it about the current</span>
<span class="cm"> * processed offset. If we are not connected with a master, the command has</span>
<span class="cm"> * no effects. */</span>
<span class="c1">// 向主服务器发送 REPLCONF AKC ，告知当前处理的偏移量</span>
<span class="c1">// 如果未连接上主服务器，那么这个函数没有实际效果</span>
<span class="kt">void</span> <span class="nf">replicationSendAck</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">REDIS_MASTER_FORCE_REPLY</span><span class="p">;</span>
        <span class="n">addReplyMultiBulkLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">addReplyBulkCString</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;REPLCONF&quot;</span><span class="p">);</span>
        <span class="n">addReplyBulkCString</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&quot;ACK&quot;</span><span class="p">);</span>
        <span class="c1">// 发送偏移量</span>
        <span class="n">addReplyBulkLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reploff</span><span class="p">);</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_MASTER_FORCE_REPLY</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */</span>

<span class="cm">/* In order to implement partial synchronization we need to be able to cache</span>
<span class="cm"> * our master&#39;s client structure after a transient disconnection.</span>
<span class="cm"> *</span>
<span class="cm"> * 为了实现 partial synchronization ，</span>
<span class="cm"> * slave 需要一个 cache 来在 master 断线时将 master 保存到 cache 上。</span>
<span class="cm"> *</span>
<span class="cm"> * It is cached into server.cached_master and flushed away using the following</span>
<span class="cm"> * functions. </span>
<span class="cm"> *</span>
<span class="cm"> * 以下是该 cache 的设置和清除函数。</span>
<span class="cm"> */</span>

<span class="cm">/* This function is called by freeClient() in order to cache the master</span>
<span class="cm"> * client structure instead of destryoing it. freeClient() will return</span>
<span class="cm"> * ASAP after this function returns, so every action needed to avoid problems</span>
<span class="cm"> * with a client that is really &quot;suspended&quot; has to be done by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * 这个函数由 freeClient() 函数调用，它将当前的 master 记录到 master cache 里面，</span>
<span class="cm"> * 然后返回。</span>
<span class="cm"> *</span>
<span class="cm"> * The other functions that will deal with the cached master are:</span>
<span class="cm"> *</span>
<span class="cm"> * 其他和 master cahce 有关的函数是：</span>
<span class="cm"> *</span>
<span class="cm"> * replicationDiscardCachedMaster() that will make sure to kill the client</span>
<span class="cm"> * as for some reason we don&#39;t want to use it in the future.</span>
<span class="cm"> *</span>
<span class="cm"> * replicationDiscardCachedMaster() 确认清空整个 master ，不对它进行缓存。</span>
<span class="cm"> *</span>
<span class="cm"> * replicationResurrectCachedMaster() that is used after a successful PSYNC</span>
<span class="cm"> * handshake in order to reactivate the cached master.</span>
<span class="cm"> *</span>
<span class="cm"> * replicationResurrectCachedMaster() 在 PSYNC 成功时将缓存中的 master 提取出来，</span>
<span class="cm"> * 重新成为新的 master 。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">replicationCacheMaster</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>

    <span class="n">redisAssert</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Caching the disconnected master state.&quot;</span><span class="p">);</span>

    <span class="cm">/* Remove from the list of clients, we don&#39;t want this client to be</span>
<span class="cm">     * listed by CLIENT LIST or processed in any way by batch operations. */</span>
    <span class="c1">// 从客户端链表中移除主服务器</span>
    <span class="n">ln</span> <span class="o">=</span> <span class="n">listSearchKey</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">ln</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">listDelNode</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients</span><span class="p">,</span><span class="n">ln</span><span class="p">);</span>

    <span class="cm">/* Save the master. Server.master will be set to null later by</span>
<span class="cm">     * replicationHandleMasterDisconnection(). */</span>
    <span class="c1">// 缓存 master</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">;</span>

    <span class="cm">/* Remove the event handlers and close the socket. We&#39;ll later reuse</span>
<span class="cm">     * the socket of the new connection with the master during PSYNC. */</span>
    <span class="c1">// 删除事件监视，关闭 socket</span>
    <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_READABLE</span><span class="p">);</span>
    <span class="n">aeDeleteFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">AE_WRITABLE</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>

    <span class="cm">/* Set fd to -1 so that we can safely call freeClient(c) later. */</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Caching the master happens instead of the actual freeClient() call,</span>
<span class="cm">     * so make sure to adjust the replication state. This function will</span>
<span class="cm">     * also set server.master to NULL. */</span>
    <span class="c1">// 重置复制状态，并将 server.master 设为 NULL</span>
    <span class="c1">// 并强制断开这个服务器的所有从服务器，让它们执行 resync </span>
    <span class="n">replicationHandleMasterDisconnection</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Free a cached master, called when there are no longer the conditions for</span>
<span class="cm"> * a partial resync on reconnection. </span>
<span class="cm"> *</span>
<span class="cm"> * 清空 master 缓存，在条件已经不可能执行 partial resync 时执行</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">replicationDiscardCachedMaster</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Discarding previously cached master state.&quot;</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REDIS_MASTER</span><span class="p">;</span>
    <span class="n">freeClient</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Turn the cached master into the current master, using the file descriptor</span>
<span class="cm"> * passed as argument as the socket for the new master.</span>
<span class="cm"> *</span>
<span class="cm"> * 将缓存中的 master 设置为服务器的当前 master 。</span>
<span class="cm"> *</span>
<span class="cm"> * This funciton is called when successfully setup a partial resynchronization</span>
<span class="cm"> * so the stream of data that we&#39;ll receive will start from were this</span>
<span class="cm"> * master left. </span>
<span class="cm"> *</span>
<span class="cm"> * 当部分重同步准备就绪之后，调用这个函数。</span>
<span class="cm"> * master 断开之前遗留下来的数据可以继续使用。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">replicationResurrectCachedMaster</span><span class="p">(</span><span class="kt">int</span> <span class="n">newfd</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="c1">// 设置 master</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">cached_master</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">newfd</span><span class="p">;</span>

    <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">REDIS_CLOSE_AFTER_REPLY</span><span class="o">|</span><span class="n">REDIS_CLOSE_ASAP</span><span class="p">);</span>

    <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">authenticated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">lastinteraction</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="p">;</span>

    <span class="c1">// 回到已连接状态</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">=</span> <span class="n">REDIS_REPL_CONNECTED</span><span class="p">;</span>

    <span class="cm">/* Re-add to the list of clients. */</span>
    <span class="c1">// 将 master 重新加入到客户端列表中</span>
    <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">clients</span><span class="p">,</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">);</span>
    <span class="c1">// 监听 master 的读事件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aeCreateFileEvent</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">,</span> <span class="n">newfd</span><span class="p">,</span> <span class="n">AE_READABLE</span><span class="p">,</span>
                          <span class="n">readQueryFromClient</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Error resurrecting the cached master, impossible to add the readable handler: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">freeClientAsync</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">);</span> <span class="cm">/* Close ASAP. */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */</span>

<span class="cm">/* This function counts the number of slaves with lag &lt;= min-slaves-max-lag.</span>
<span class="cm"> * </span>
<span class="cm"> * 计算那些延迟值少于等于 min-slaves-max-lag 的从服务器数量。</span>
<span class="cm"> *</span>
<span class="cm"> * If the option is active, the server will prevent writes if there are not</span>
<span class="cm"> * enough connected slaves with the specified lag (or less). </span>
<span class="cm"> *</span>
<span class="cm"> * 如果服务器开启了 min-slaves-max-lag 选项，</span>
<span class="cm"> * 那么在这个选项所指定的条件达不到时，服务器将阻止写操作执行。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">refreshGoodSlavesCount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">good</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">repl_min_slaves_to_write</span> <span class="o">||</span>
        <span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">repl_min_slaves_max_lag</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

        <span class="c1">// 计算延迟值</span>
        <span class="kt">time_t</span> <span class="n">lag</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span> <span class="o">-</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repl_ack_time</span><span class="p">;</span>

        <span class="c1">// 计入 GOOD</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_ONLINE</span> <span class="o">&amp;&amp;</span>
            <span class="n">lag</span> <span class="o">&lt;=</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_min_slaves_max_lag</span><span class="p">)</span> <span class="n">good</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 更新状态良好的从服务器数量</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_good_slaves_count</span> <span class="o">=</span> <span class="n">good</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ----------------------- REPLICATION SCRIPT CACHE --------------------------</span>
<span class="cm"> * The goal of this code is to keep track of scripts already sent to every</span>
<span class="cm"> * connected slave, in order to be able to replicate EVALSHA as it is without</span>
<span class="cm"> * translating it to EVAL every time it is possible.</span>
<span class="cm"> *</span>
<span class="cm"> * 这部分代码的目的是，</span>
<span class="cm"> * 将那些已经发送给所有已连接从服务器的脚本保存到缓存里面，</span>
<span class="cm"> * 这样在执行过一次 EVAL 之后，其他时候都可以直接发送 EVALSHA 了。</span>
<span class="cm"> *</span>
<span class="cm"> * We use a capped collection implemented by an hash table for fast lookup</span>
<span class="cm"> * of scripts we can send as EVALSHA, plus a linked list that is used for</span>
<span class="cm"> * eviction of the oldest entry when the max number of items is reached.</span>
<span class="cm"> *</span>
<span class="cm"> * 程序构建了一个固定大小的集合（capped collection），</span>
<span class="cm"> * 该集合由哈希结构和一个链表组成，</span>
<span class="cm"> * 哈希负责快速查找，而链表则负责形成一个 FIFO 队列，</span>
<span class="cm"> * 在脚本的数量超过最大值时，最先保存的脚本将被删除。</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t care about taking a different cache for every different slave</span>
<span class="cm"> * since to fill the cache again is not very costly, the goal of this code</span>
<span class="cm"> * is to avoid that the same big script is trasmitted a big number of times</span>
<span class="cm"> * per second wasting bandwidth and processor speed, but it is not a problem</span>
<span class="cm"> * if we need to rebuild the cache from scratch from time to time, every used</span>
<span class="cm"> * script will need to be transmitted a single time to reappear in the cache.</span>
<span class="cm"> *</span>
<span class="cm"> * Redis 我们为每个从服务器保存独立的脚本缓存，</span>
<span class="cm"> * 而是让所有从服务器都共用一个全局缓存。</span>
<span class="cm"> * 这是因为重新填充脚本到缓存中的操作并不昂贵，</span>
<span class="cm"> * 这个程序的目的是避免在短时间内发送同一个大脚本多次，</span>
<span class="cm"> * 造成带宽和 CPU 浪费，</span>
<span class="cm"> * 但时不时重新建立一次缓存的代码并不高昂，</span>
<span class="cm"> * 每次将一个脚本添加到缓存中时，都需要发送这个脚本一次。</span>
<span class="cm"> *</span>
<span class="cm"> * This is how the system works:</span>
<span class="cm"> *</span>
<span class="cm"> * 以下是这个系统的工作方式：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Every time a new slave connects, we flush the whole script cache.</span>
<span class="cm"> *    每次有新的从服务器连接时，清空所有脚本缓存。</span>
<span class="cm"> *</span>
<span class="cm"> * 2) We only send as EVALSHA what was sent to the master as EVALSHA, without</span>
<span class="cm"> *    trying to convert EVAL into EVALSHA specifically for slaves.</span>
<span class="cm"> *    程序只在主服务器接到 EVALSHA 时才向从服务器发送 EVALSHA ，</span>
<span class="cm"> *    它不会主动尝试将 EVAL 转换成 EVALSHA 。</span>
<span class="cm"> *</span>
<span class="cm"> * 3) Every time we trasmit a script as EVAL to the slaves, we also add the</span>
<span class="cm"> *    corresponding SHA1 of the script into the cache as we are sure every</span>
<span class="cm"> *    slave knows about the script starting from now.</span>
<span class="cm"> *    每次将脚本通过 EVAL 命令发送给所有从服务器时，</span>
<span class="cm"> *    将脚本的 SHA1 键保存到脚本字典中，字典的键为 SHA1 ，值为 NULL ，</span>
<span class="cm"> *    这样我们就知道，只要脚本的 SHA1 在字典中，</span>
<span class="cm"> *    那么这个脚本就存在于所有 slave 中。</span>
<span class="cm"> *</span>
<span class="cm"> * 4) On SCRIPT FLUSH command, we replicate the command to all the slaves</span>
<span class="cm"> *    and at the same time flush the script cache.</span>
<span class="cm"> *    当客户端执行 SCRIPT FLUSH 的时候，服务器将该命令复制给所有从服务器，</span>
<span class="cm"> *    让它们也刷新自己的脚本缓存。</span>
<span class="cm"> *</span>
<span class="cm"> * 5) When the last slave disconnects, flush the cache.</span>
<span class="cm"> *    当所有从服务器都断开时，清空脚本。</span>
<span class="cm"> *</span>
<span class="cm"> * 6) We handle SCRIPT LOAD as well since that&#39;s how scripts are loaded</span>
<span class="cm"> *    in the master sometimes.</span>
<span class="cm"> *    SCRIPT LOAD 命令对这个脚本缓存的作用和 EVAL 一样。</span>
<span class="cm"> */</span>

<span class="cm">/* Initialize the script cache, only called at startup. */</span>
<span class="c1">// 初始化缓存，只在服务器启动时调用</span>
<span class="kt">void</span> <span class="nf">replicationScriptCacheInit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 最大缓存脚本数</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_size</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
    <span class="c1">// 字典</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_dict</span> <span class="o">=</span> <span class="n">dictCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">replScriptCacheDictType</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// FIFO 队列</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span> <span class="o">=</span> <span class="n">listCreate</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Empty the script cache. Should be called every time we are no longer sure</span>
<span class="cm"> * that every slave knows about all the scripts in our set, or when the</span>
<span class="cm"> * current AOF &quot;context&quot; is no longer aware of the script. In general we</span>
<span class="cm"> * should flush the cache:</span>
<span class="cm"> *</span>
<span class="cm"> * 清空脚本缓存。</span>
<span class="cm"> *</span>
<span class="cm"> * 在以下情况下执行：</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Every time a new slave reconnects to this master and performs a</span>
<span class="cm"> *    full SYNC (PSYNC does not require flushing).</span>
<span class="cm"> *    有新从服务器连入，并且执行了一次 full SYNC ， PSYNC 无须清空缓存</span>
<span class="cm"> * 2) Every time an AOF rewrite is performed.</span>
<span class="cm"> *    每次执行 AOF 重写时</span>
<span class="cm"> * 3) Every time we are left without slaves at all, and AOF is off, in order</span>
<span class="cm"> *    to reclaim otherwise unused memory.</span>
<span class="cm"> *    在没有任何从服务器，AOF 关闭的时候，为节约内存而执行清空。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">replicationScriptCacheFlush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictEmpty</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_dict</span><span class="p">);</span>
    <span class="n">listRelease</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span> <span class="o">=</span> <span class="n">listCreate</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Add an entry into the script cache, if we reach max number of entries the</span>
<span class="cm"> * oldest is removed from the list. </span>
<span class="cm"> *</span>
<span class="cm"> * 将脚本的 SHA1 添加到缓存中，</span>
<span class="cm"> * 如果缓存的数量已达到最大值，那么删除最旧的那个脚本（FIFO）</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">replicationScriptCacheAdd</span><span class="p">(</span><span class="n">sds</span> <span class="n">sha1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">key</span> <span class="o">=</span> <span class="n">sdsdup</span><span class="p">(</span><span class="n">sha1</span><span class="p">);</span>

    <span class="cm">/* Evict oldest. */</span>
    <span class="c1">// 如果大小超过数量限制，那么删除最旧</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span><span class="p">)</span> <span class="o">==</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listLast</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span><span class="p">);</span>
        <span class="n">sds</span> <span class="n">oldest</span> <span class="o">=</span> <span class="n">listNodeValue</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">dictDelete</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_dict</span><span class="p">,</span><span class="n">oldest</span><span class="p">);</span>
        <span class="n">redisAssert</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">);</span>
        <span class="n">listDelNode</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span><span class="p">,</span><span class="n">ln</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Add current. */</span>
    <span class="c1">// 添加 SHA1</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">dictAdd</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_dict</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">listAddNodeHead</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
    <span class="n">redisAssert</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">DICT_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns non-zero if the specified entry exists inside the cache, that is,</span>
<span class="cm"> * if all the slaves are aware of this script SHA1. */</span>
<span class="c1">// 如果脚本存在于脚本，那么返回 1 ；否则，返回 0 。</span>
<span class="kt">int</span> <span class="nf">replicationScriptCacheExists</span><span class="p">(</span><span class="n">sds</span> <span class="n">sha1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dictFind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_dict</span><span class="p">,</span><span class="n">sha1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* --------------------------- REPLICATION CRON  ----------------------------- */</span>

<span class="cm">/* Replication cron funciton, called 1 time per second. */</span>
<span class="c1">// 复制 cron 函数，每秒调用一次</span>
<span class="kt">void</span> <span class="nf">replicationCron</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* Non blocking connection timeout? */</span>
    <span class="c1">// 尝试连接到主服务器，但超时</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECTING</span> <span class="o">||</span>
         <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_RECEIVE_PONG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_lastio</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_timeout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Timeout connecting to the MASTER...&quot;</span><span class="p">);</span>
        <span class="c1">// 取消连接</span>
        <span class="n">undoConnectWithMaster</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/* Bulk transfer I/O timeout? */</span>
    <span class="c1">// RDB 文件的传送已超时？</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_TRANSFER</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">repl_transfer_lastio</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_timeout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the &#39;repl-timeout&#39; parameter in redis.conf to a larger value.&quot;</span><span class="p">);</span>
        <span class="c1">// 停止传送，并删除临时文件</span>
        <span class="n">replicationAbortSyncTransfer</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/* Timed out master when we are an already connected slave? */</span>
    <span class="c1">// 从服务器曾经连接上主服务器，但现在超时</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECTED</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">lastinteraction</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_timeout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span><span class="s">&quot;MASTER timeout: no data nor PING received...&quot;</span><span class="p">);</span>
        <span class="c1">// 释放主服务器</span>
        <span class="n">freeClient</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Check if we should connect to a MASTER */</span>
    <span class="c1">// 尝试连接主服务器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_state</span> <span class="o">==</span> <span class="n">REDIS_REPL_CONNECT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;Connecting to MASTER...&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">connectWithMaster</span><span class="p">()</span> <span class="o">==</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span><span class="s">&quot;MASTER &lt;-&gt; SLAVE sync started&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Send ACK to master from time to time. */</span>
    <span class="c1">// 定时向 master 发送 ACK</span>
    <span class="c1">// 告知当前从服务器处理的偏移量</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">masterhost</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">master</span><span class="p">)</span>
        <span class="n">replicationSendAck</span><span class="p">();</span>
    
    <span class="cm">/* If we have attached slaves, PING them from time to time.</span>
<span class="cm">     *</span>
<span class="cm">     * 如果服务器有从服务器，定时向它们发送 PING 。</span>
<span class="cm">     *</span>
<span class="cm">     * So slaves can implement an explicit timeout to masters, and will</span>
<span class="cm">     * be able to detect a link disconnection even if the TCP connection</span>
<span class="cm">     * will not actually go down. </span>
<span class="cm">     *</span>
<span class="cm">     * 这样从服务器就可以实现显式的 master 超时判断机制，</span>
<span class="cm">     * 即使 TCP 连接未断开也是如此。</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cronloops</span> <span class="o">%</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_ping_slave_period</span> <span class="o">*</span> <span class="n">server</span><span class="p">.</span><span class="n">hz</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
        <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>
        <span class="n">robj</span> <span class="o">*</span><span class="n">ping_argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="cm">/* First, send PING */</span>
        <span class="c1">// 向所有已连接 slave （状态为 ONLINE）发送 PING</span>
        <span class="n">ping_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">createStringObject</span><span class="p">(</span><span class="s">&quot;PING&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
        <span class="n">replicationFeedSlaves</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span> <span class="n">server</span><span class="p">.</span><span class="n">slaveseldb</span><span class="p">,</span> <span class="n">ping_argv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">decrRefCount</span><span class="p">(</span><span class="n">ping_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

        <span class="cm">/* Second, send a newline to all the slaves in pre-synchronization</span>
<span class="cm">         * stage, that is, slaves waiting for the master to create the RDB file.</span>
<span class="cm">         *</span>
<span class="cm">         * 向那些正在等待 RDB 文件的从服务器（状态为 BGSAVE_START 或 BGSAVE_END）</span>
<span class="cm">         * 发送 &quot;\n&quot;</span>
<span class="cm">         *</span>
<span class="cm">         * The newline will be ignored by the slave but will refresh the</span>
<span class="cm">         * last-io timer preventing a timeout. </span>
<span class="cm">         *</span>
<span class="cm">         * 这个 &quot;\n&quot; 会被从服务器忽略，</span>
<span class="cm">         * 它的作用就是用来防止主服务器因为长期不发送信息而被从服务器误判为超时</span>
<span class="cm">         */</span>
        <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
        <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_START</span> <span class="o">||</span>
                <span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">==</span> <span class="n">REDIS_REPL_WAIT_BGSAVE_END</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* Don&#39;t worry, it&#39;s just a ping. */</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Disconnect timedout slaves. */</span>
    <span class="c1">// 断开超时从服务器</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">listIter</span> <span class="n">li</span><span class="p">;</span>
        <span class="n">listNode</span> <span class="o">*</span><span class="n">ln</span><span class="p">;</span>

        <span class="c1">// 遍历所有从服务器</span>
        <span class="n">listRewind</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">,</span><span class="o">&amp;</span><span class="n">li</span><span class="p">);</span>
        <span class="k">while</span><span class="p">((</span><span class="n">ln</span> <span class="o">=</span> <span class="n">listNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">redisClient</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">ln</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

            <span class="c1">// 略过未 ONLINE 的从服务器</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">replstate</span> <span class="o">!=</span> <span class="n">REDIS_REPL_ONLINE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// 略过正在发送 SYNC 的从服务器</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_PRE_PSYNC_SLAVE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// 处理超时从服务器</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span> <span class="o">-</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">repl_ack_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_timeout</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="n">REDIS_IP_STR_LEN</span><span class="p">];</span>
                <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">anetPeerToString</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ip</span><span class="p">),</span><span class="o">&amp;</span><span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_WARNING</span><span class="p">,</span>
                        <span class="s">&quot;Disconnecting timedout slave: %s:%d&quot;</span><span class="p">,</span>
                        <span class="n">ip</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">slave_listening_port</span><span class="p">);</span>
                <span class="p">}</span>
                
                <span class="c1">// 释放</span>
                <span class="n">freeClient</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* If we have no attached slaves and there is a replication backlog</span>
<span class="cm">     * using memory, free it after some (configured) time. */</span>
    <span class="c1">// 在没有任何从服务器的 N 秒之后，释放 backlog</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_time_limit</span> <span class="o">&amp;&amp;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">time_t</span> <span class="n">idle</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span> <span class="o">-</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_no_slaves_since</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_time_limit</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 释放</span>
            <span class="n">freeReplicationBacklog</span><span class="p">();</span>
            <span class="n">redisLog</span><span class="p">(</span><span class="n">REDIS_NOTICE</span><span class="p">,</span>
                <span class="s">&quot;Replication backlog freed after %d seconds &quot;</span>
                <span class="s">&quot;without connected slaves.&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">server</span><span class="p">.</span><span class="n">repl_backlog_time_limit</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* If AOF is disabled and we no longer have attached slaves, we can</span>
<span class="cm">     * free our Replication Script Cache as there is no need to propagate</span>
<span class="cm">     * EVALSHA at all. */</span>
    <span class="c1">// 在没有任何从服务器，AOF 关闭的情况下，清空 script 缓存</span>
    <span class="c1">// 因为已经没有传播 EVALSHA 的必要了</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">slaves</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">server</span><span class="p">.</span><span class="n">aof_state</span> <span class="o">==</span> <span class="n">REDIS_AOF_OFF</span> <span class="o">&amp;&amp;</span>
        <span class="n">listLength</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">repl_scriptcache_fifo</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">replicationScriptCacheFlush</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</span>
    <span class="c1">// 更新符合给定延迟值的从服务器的数量</span>
    <span class="n">refreshGoodSlavesCount</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>



            <div class="section" id="discuss">

    <h2>
        留言
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'notehuangzme'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="pubsub_command.html"
                        title="previous chapter">PUBSUB 命令</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sentinel.html"
                        title="next chapter">Sentinel</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2014, huangz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>