<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>事件驱动 &mdash; huangz/note</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'present',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="huangz/note" href="../../index.html" />
    <link rel="up" title="Redis 源码分析" href="index.html" />
    <link rel="next" title="发布/订阅" href="pubsub.html" />
    <link rel="prev" title="Lua 脚本" href="lua-scripting.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->





</head>
<body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pubsub.html" title="发布/订阅"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="lua-scripting.html" title="Lua 脚本"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">huangz/note</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Redis 源码分析</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>事件驱动<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>事件处理是 Redis 的核心机制之一，通过在客户端、文件、网络等类型的事件上进行<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a> ，为 Redis 的高性能提供了保证。</p>
<p>在这篇文章中，我们通过分析 <code class="docutils literal"><span class="pre">ae.c</span></code> 和 <code class="docutils literal"><span class="pre">ae.h</span></code> 中的<a class="reference external" href="http://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95">事件驱动</a> 实现，了解 Redis 的事件处理模型以及实现，籍此加深对 Redis 的理解。</p>
<div class="section" id="id4">
<h2>事件状态<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>和其他所有事件驱动程序一样，Redis 的事件驱动程序本质上也是一个循环回路（loop）： 一些数据结构被表示为事件的当前状态，事件处理器在循环中不断修改这些数据结构，从而实现添加事件、删除事件、处理事件等功能。</p>
<p>在 Redis 中，事件状态由 <code class="docutils literal"><span class="pre">aeEventLoop</span></code> 结构来维持：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* State of an event based program */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="p">{</span>
    <span class="c1">// 当前已注册的最大文件描述符</span>
    <span class="kt">int</span> <span class="n">maxfd</span><span class="p">;</span>   <span class="cm">/* highest file descriptor currently registered */</span>
    <span class="c1">// 允许注册的最大文件描述符数量</span>
    <span class="kt">int</span> <span class="n">setsize</span><span class="p">;</span> <span class="cm">/* max number of file descriptors tracked */</span>
    <span class="c1">// 时间事件的计数器</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">timeEventNextId</span><span class="p">;</span>
    <span class="c1">// 文件事件</span>
    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span> <span class="cm">/* Registered events */</span>
    <span class="c1">// 待处理文件事件</span>
    <span class="n">aeFiredEvent</span> <span class="o">*</span><span class="n">fired</span><span class="p">;</span> <span class="cm">/* Fired events */</span>
    <span class="c1">// 时间事件（链表）</span>
    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">timeEventHead</span><span class="p">;</span>
    <span class="c1">// 停止事件处理？</span>
    <span class="kt">int</span> <span class="n">stop</span><span class="p">;</span>
    <span class="c1">// poll API 所需的数据</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">apidata</span><span class="p">;</span> <span class="cm">/* This is used for polling API specific data */</span>
    <span class="c1">// 在处理时间前要执行的函数</span>
    <span class="n">aeBeforeSleepProc</span> <span class="o">*</span><span class="n">beforesleep</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeEventLoop</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>文件事件<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Redis 有两种事件类型，分别是文件事件和时间事件。</p>
<p><code class="docutils literal"><span class="pre">aeEventLoop.events</span></code> 数组保存当前服务器端的所有文件事件，其中每个文件事件用一个 <code class="docutils literal"><span class="pre">aeFileEvent</span></code> 结构来保存：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeFileEvent</span> <span class="p">{</span>
    <span class="c1">// 状态 mask</span>
    <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span> <span class="cm">/* one of AE_(READABLE|WRITABLE) */</span>
    <span class="c1">// 读操作函数</span>
    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">rfileProc</span><span class="p">;</span>
    <span class="c1">// 写操作函数</span>
    <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">wfileProc</span><span class="p">;</span>
    <span class="c1">// 执行命令时所需的客户端资料</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeFileEvent</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">aeFileEvent</span></code> 结构可以同时持有 <code class="docutils literal"><span class="pre">rfileProc</span></code> 和 <code class="docutils literal"><span class="pre">wfileProc</span></code> 两个事件处理函数，但每次执行事件，只能有一个函数被执行：事件要么读取，要么写入，但不能既写入又读取。</p>
<p><code class="docutils literal"><span class="pre">clientData</span></code> 保存执行命令时所需的客户端资料，每次执行事件时，它会作为参数被传入事件处理函数。</p>
<p>以下是一个执行读取事件的例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// fe 是一个 aeFileEvent 实例</span>
<span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">aeEventLoop.fired</span></code> 数组保存当前服务器端所有待处理的文件事件，其中每个待处理事件用一个 <code class="docutils literal"><span class="pre">aeFiredEvent</span></code> 结构来保存：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeFiredEvent</span> <span class="p">{</span>
    <span class="c1">// 文件描述符</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="c1">// 状态 mask</span>
    <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeFiredEvent</span><span class="p">;</span>
</pre></div>
</div>
<p>尽管听上去 <code class="docutils literal"><span class="pre">aeFiredEvent</span></code> 像是一种新的事件，但它实际上不是 ——
每个 <code class="docutils literal"><span class="pre">aeFiredEvent</span></code> 结构都保存了一个待处理文件事件的信息，通过读取 <code class="docutils literal"><span class="pre">aeEventLoop.fired</span></code> 数组，事件处理程序可以知道 <code class="docutils literal"><span class="pre">aeEventLoop.events</span></code> 数组中，哪些事件可以被（无阻塞地）执行。</p>
</div>
<div class="section" id="id6">
<h2>时间事件<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">eventLoop.timeEventHead</span></code> 是一个链表，保存了服务器端上的所有时间事件，每个时间事件用一个 <code class="docutils literal"><span class="pre">aeTimeEvent</span></code> 结构来表示：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeTimeEvent</span> <span class="p">{</span>
    <span class="c1">// 该时间事件的 id</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span> <span class="cm">/* time event identifier. */</span>
    <span class="c1">// 时间</span>
    <span class="kt">long</span> <span class="n">when_sec</span><span class="p">;</span> <span class="cm">/* seconds */</span>
    <span class="kt">long</span> <span class="n">when_ms</span><span class="p">;</span> <span class="cm">/* milliseconds */</span>
    <span class="c1">// 时间事件处理函数</span>
    <span class="n">aeTimeProc</span> <span class="o">*</span><span class="n">timeProc</span><span class="p">;</span>
    <span class="c1">// 在删除时间事件前要执行的函数</span>
    <span class="n">aeEventFinalizerProc</span> <span class="o">*</span><span class="n">finalizerProc</span><span class="p">;</span>
    <span class="c1">// 客户端资料</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">;</span>
    <span class="c1">// 指向下一时间事件，形成链表</span>
    <span class="k">struct</span> <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeTimeEvent</span><span class="p">;</span>
</pre></div>
</div>
<p>有三个属性需要额外说明：</p>
<p>Redis 服务器端会为每个时间事件赋予一个 <code class="docutils literal"><span class="pre">id</span></code> 值，这个 <code class="docutils literal"><span class="pre">id</span></code> 值就保存在 <code class="docutils literal"><span class="pre">aeTimeEvent.id</span></code> 属性中。</p>
<p><code class="docutils literal"><span class="pre">when_sec</span></code> 和 <code class="docutils literal"><span class="pre">when_ms</span></code> 两个属性决定了时间事件执行的时间，通过将当前时间和这两个值对比，可以知道是否应该执行这个时间事件。</p>
<p>在删除时间事件之前，相应的 <code class="docutils literal"><span class="pre">finalizerProc</span></code> 函数会被执行一次， <code class="docutils literal"><span class="pre">aeDeleteTimeEvent</span></code> 函数的定义中说明了这一点。</p>
</div>
<div class="section" id="id7">
<h2>事件处理器<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Redis 的事件处理主循环由 <code class="docutils literal"><span class="pre">aeMain</span></code> 函数进行：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果有需要在处理事件之前执行的函数，那么运行它</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="c1">// 开始处理事件</span>
        <span class="n">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个事件循环的流程图如下：</p>
<img alt="../../_images/event-loop.png" src="../../_images/event-loop.png" />
<p><code class="docutils literal"><span class="pre">aeProcessEvents</span></code> 函数根据不同的 <code class="docutils literal"><span class="pre">flags</span></code> 参数来执行不同的动作。以 <code class="docutils literal"><span class="pre">flags</span></code> 参数为 <code class="docutils literal"><span class="pre">AE_ALL_EVENTS</span></code> 为例子，它完成以下三部分工作：</p>
<p>1）计算处理文件事件的阻塞时间，阻塞时间也可以通过 <code class="docutils literal"><span class="pre">flags</span></code> 参数显式地设置</p>
<p>2）处理文件事件</p>
<p>3）处理时间事件</p>
<p><code class="docutils literal"><span class="pre">aeProcessEvents</span></code> 函数的完整定义如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* Process every pending time event, then every pending file event</span>
<span class="cm"> * (that may be registered by time event callbacks just processed).</span>
<span class="cm"> * Without special flags the function sleeps until some file event</span>
<span class="cm"> * fires, or when the next time event occurrs (if any).</span>
<span class="cm"> *</span>
<span class="cm"> * If flags is 0, the function does nothing and returns.</span>
<span class="cm"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</span>
<span class="cm"> * if flags has AE_FILE_EVENTS set, file events are processed.</span>
<span class="cm"> * if flags has AE_TIME_EVENTS set, time events are processed.</span>
<span class="cm"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</span>
<span class="cm"> * the events that&#39;s possible to process without to wait are processed.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns the number of events processed. */</span>
<span class="c1">// 处理所有待处理的时间事件，以及所有待处理的文件事件</span>
<span class="c1">// 如果不给函数传入特定的 flag ，那么函数会一直 sleep ，</span>
<span class="c1">// 直到有文件事件触发，或者下一个时间事件发生（如果有的话）</span>
<span class="c1">//</span>
<span class="c1">// 如果 flags 为 0 的话，函数不做动作，直接返回</span>
<span class="c1">// 如果 flags 的 AE_ALL_EVENTS 被打开，那么所有种类的事件都会被处理</span>
<span class="c1">// 如果 flags 的 AE_FILE_EVENTS 被打开，那么文件事件会被处理</span>
<span class="c1">// 如果 flags 的 AE_TIME_EVENTS 被打开，那么时间事件会被处理</span>
<span class="c1">// 如果 flags 的 AE_DONT_WAIT 被打开，那么函数在处理完所有不须等待的事件后返回</span>
<span class="c1">//</span>
<span class="c1">// 函数的返回值为处理事件的个数</span>
<span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numevents</span><span class="p">;</span>

    <span class="cm">/* Nothing to do? return ASAP */</span>
    <span class="c1">// 无操作，直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_FILE_EVENTS</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Note that we want call select() even if there are no</span>
<span class="cm">     * file events to process as long as we want to process time</span>
<span class="cm">     * events, in order to sleep until the next time event is ready</span>
<span class="cm">     * to fire. */</span>
    <span class="c1">// 如果文件事件的个数不为空</span>
    <span class="c1">// 或者 AE_TIME_EVENTS 被打开，且没有打开 AE_DONT_WAIT</span>
    <span class="c1">// 那么执行以下语句，设置处理文件事件时所使用的时间差</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
        <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">shortest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">,</span> <span class="o">*</span><span class="n">tvp</span><span class="p">;</span>

        <span class="c1">// 如果 AE_TIME_EVENTS 被打开且没有打开 AE_DONT_WAIT</span>
        <span class="c1">// 那么查找执行时间离现在最近的一个时间事件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">))</span>
            <span class="n">shortest</span> <span class="o">=</span> <span class="n">aeSearchNearestTimer</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="c1">// 如果最近时间事件不为空的话。。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">long</span> <span class="n">now_sec</span><span class="p">,</span> <span class="n">now_ms</span><span class="p">;</span>

            <span class="cm">/* Calculate the time missing for the nearest</span>
<span class="cm">             * timer to fire. */</span>
            <span class="c1">// 计算距离最近时间事件发生还需要多少时间</span>
            <span class="n">aeGetTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now_ms</span><span class="p">);</span>
            <span class="n">tvp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>
            <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">-</span> <span class="n">now_sec</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_ms</span> <span class="o">&lt;</span> <span class="n">now_ms</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">((</span><span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="o">+</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-</span> <span class="n">now_ms</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span>
                <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">--</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">shortest</span><span class="o">-&gt;</span><span class="n">when_ms</span> <span class="o">-</span> <span class="n">now_ms</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 如果时间差小于 0</span>
            <span class="c1">// 说明当前时间已经超过时间事件的执行时间了</span>
            <span class="c1">// 那么将时间差设置为 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* If we have to check for events but need to return</span>
<span class="cm">             * ASAP because of AE_DONT_WAIT we need to se the timeout</span>
<span class="cm">             * to zero */</span>
            <span class="c1">// 如果执行到这一步，说明没有时间事件</span>
            <span class="c1">// 那么根据 AE_DONT_WAIT 的设置状态，设置时间差</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 如果 AE_DONT_WAIT 被打开</span>
                <span class="c1">// 那么将时间差设置为 0 ，也即是不等待</span>
                <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">tvp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 否则，就一直等待（直到有文件事件触发，或时间事件触发）</span>
                <span class="cm">/* Otherwise we can block */</span>
                <span class="n">tvp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* wait forever */</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 处理文件事件</span>
        <span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 根据 fired 数组，从 events 数组中取出事件</span>
            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">rfired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="cm">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span>
<span class="cm">             * event removed an element that fired and we still didn&#39;t</span>
<span class="cm">             * processed, so we check if the event is still valid. */</span>
            <span class="c1">// 因为一个已处理的事件有可能对当前被执行的事件进行了修改</span>
            <span class="c1">// 因此在执行当前事件前，需要再进行一次检查</span>
            <span class="c1">// 确保事件可以被执行</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rfired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span>
                    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* Check time events */</span>
    <span class="c1">// 如果 AE_TIME_EVENTS 被打开</span>
    <span class="c1">// 那么处理时间事件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span>
        <span class="n">processed</span> <span class="o">+=</span> <span class="n">processTimeEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>

    <span class="c1">// 返回被执行事件的个数</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span> <span class="cm">/* return the number of processed file/time events */</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">aeProcessEvents</span></code> 函数中最重要的两个动作分别是对 <code class="docutils literal"><span class="pre">aeApiPoll</span></code> 的调用和对 <code class="docutils literal"><span class="pre">processTimeEvents</span></code> 的调用：</p>
<p><code class="docutils literal"><span class="pre">aeApiPoll</span></code> 获取所有可以不阻塞处理的文件事件。</p>
<p><code class="docutils literal"><span class="pre">processTimeEvents</span></code> 执行所有可运行的时间事件。</p>
<p>以上两个函数都用于对前面介绍的几个事件结构进行操作，定义都非常直观，这里不再赘述，有兴趣的话可以直接看代码。</p>
</div>
<div class="section" id="id8">
<h2>多个多路复用库可选<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>最后要提到的一点是，Redis 在几个常见的多路复用库之间实现了一个<a class="reference external" href="http://zh.wikipedia.org/zh-hk/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a> ，并且会在编译时自动选择尽可能快的库：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// ae.c</span>
<span class="cp">#ifdef HAVE_EVPORT</span>
    <span class="cp">#include &quot;ae_evport.c&quot;</span>
<span class="cp">#else</span>
    <span class="cp">#ifdef HAVE_EPOLL</span>
        <span class="cp">#include &quot;ae_epoll.c&quot;</span>
    <span class="cp">#else</span>
        <span class="cp">#ifdef HAVE_KQUEUE</span>
            <span class="cp">#include &quot;ae_kqueue.c&quot;</span>
        <span class="cp">#else</span>
            <span class="cp">#include &quot;ae_select.c&quot;</span>
        <span class="cp">#endif</span>
    <span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>总结<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>以上就是本篇文章的全部内容了。</p>
<p>文章主要介绍了几个事件结构，事件状态结构，以及事件处理循环和事件处理器的定义。</p>
<p>因为边幅所限，一些函数的只是简单地做了介绍，没有详细地进行分析，如果对细节有兴趣的话，可以到 GitHub 上查看带注释的源码： <a class="reference external" href="https://github.com/huangz1990/reading_redis_source">https://github.com/huangz1990/reading_redis_source</a> 。</p>
</div>
</div>



            <div class="section" id="discuss">

    <h2>
        留言
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'notehuangzme'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">事件驱动</a><ul>
<li><a class="reference internal" href="#id4">事件状态</a></li>
<li><a class="reference internal" href="#id5">文件事件</a></li>
<li><a class="reference internal" href="#id6">时间事件</a></li>
<li><a class="reference internal" href="#id7">事件处理器</a></li>
<li><a class="reference internal" href="#id8">多个多路复用库可选</a></li>
<li><a class="reference internal" href="#id10">总结</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="lua-scripting.html"
                        title="previous chapter">Lua 脚本</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pubsub.html"
                        title="next chapter">发布/订阅</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2014, huangz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>